text|source|chunk_id
"../cargotracker/src/main/java/org/eclipse/cargotracker/application/ApplicationEvents.java

package org.eclipse.cargotracker.application;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.interfaces.handling.HandlingEventRegistrationAttempt;

/** * This interface provides a way to let other parts of the system know about events that have * occurred. * * <p>It may be implemented synchronously or asynchronously, using for example JMS. */ public interface ApplicationEvents {

void cargoWasHandled(HandlingEvent event);

void cargoWasMisdirected(Cargo cargo);

void cargoHasArrived(Cargo cargo);

void receivedHandlingEventRegistrationAttempt(HandlingEventRegistrationAttempt attempt);

}

../cargotracker/src/main/java/org/eclipse/cargotracker/application/BookingService.java

package org.eclipse.cargotracker.application;

import java.time.LocalDate;

import java.util.List;

import jakarta.validation.Valid;

import jakarta.validation.constraints.Future;

import jakarta.validation.constraints.NotNull;

import org.eclipse.cargotracker.domain.model.cargo.Itinerary;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

/*

Cargo booking service.

/

public interface BookingService {"|data_input/cargotracker/cargotracker.txt|2300abb7618545e8bbd2f8eb30ad5c21
"import org.eclipse.cargotracker.domain.model.location.UnLocode;

/*

Cargo booking service.

/

public interface BookingService {

/** Registers a new cargo in the tracking system, not yet routed. */ TrackingId bookNewCargo( @NotNull(message = ""Origin is required."") @Valid UnLocode origin, @NotNull(message = ""Destination is required."") @Valid UnLocode destination, @NotNull(message = ""Deadline is required."") @Future(message = ""Deadline must be in the future."") LocalDate arrivalDeadline);

/** * Requests a list of itineraries describing possible routes for this cargo. * * @param trackingId Cargo tracking ID * @return A list of possible itineraries for this cargo */ List<Itinerary> requestPossibleRoutesForCargo( @NotNull(message = ""Tracking ID is required."") @Valid TrackingId trackingId);

void assignCargoToRoute( @NotNull(message = ""Itinerary is required."") @Valid Itinerary itinerary, @NotNull(message = ""Tracking ID is required."") @Valid TrackingId trackingId);

void changeDestination( @NotNull(message = ""Tracking ID is required."") @Valid TrackingId trackingId, @NotNull(message = ""Destination is required."") @Valid UnLocode unLocode);

void changeDeadline( @NotNull(message = ""Tracking ID is required."") @Valid TrackingId trackingId, @NotNull(message = ""Deadline is required."") @Future(message = ""Deadline must be in the future."") LocalDate deadline); }

../cargotracker/src/main/java/org/eclipse/cargotracker/application/CargoInspectionService.java"|data_input/cargotracker/cargotracker.txt|548d2237b01e45ac924c03a94c7ab850
"../cargotracker/src/main/java/org/eclipse/cargotracker/application/CargoInspectionService.java

package org.eclipse.cargotracker.application;

import jakarta.validation.Valid;

import jakarta.validation.constraints.NotNull;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

public interface CargoInspectionService {

/** * Inspect cargo and send relevant notifications to interested parties, for example if a cargo has * been misdirected, or unloaded at the final destination. */ public void inspectCargo( @NotNull(message = ""Tracking ID is required."") @Valid TrackingId trackingId); }

../cargotracker/src/main/java/org/eclipse/cargotracker/application/HandlingEventService.java

package org.eclipse.cargotracker.application;

import java.time.LocalDateTime;

import jakarta.validation.Valid;

import jakarta.validation.constraints.NotNull;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.handling.CannotCreateHandlingEventException;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

public interface HandlingEventService {"|data_input/cargotracker/cargotracker.txt|54a8d1ee737a4bdd87e8c46c85303902
"import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

public interface HandlingEventService {

/** * Registers a handling event in the system, and notifies interested parties that a cargo has been * handled. */ void registerHandlingEvent( @NotNull(message = ""Completion time is required."") LocalDateTime completionTime, @NotNull(message = ""Tracking ID is required."") @Valid TrackingId trackingId, @Valid VoyageNumber voyageNumber, @NotNull(message = ""Location is required."") @Valid UnLocode unLocode, @NotNull(message = ""Type is required."") HandlingEvent.Type type) throws CannotCreateHandlingEventException; }

../cargotracker/src/main/java/org/eclipse/cargotracker/application/internal/DefaultBookingService.java

package org.eclipse.cargotracker.application.internal;

import java.time.LocalDate;

import java.util.Collections;

import java.util.List;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.ejb.Stateless;

import jakarta.inject.Inject;

import org.eclipse.cargotracker.application.BookingService;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.CargoRepository;

import org.eclipse.cargotracker.domain.model.cargo.Itinerary;

import org.eclipse.cargotracker.domain.model.cargo.RouteSpecification;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.location.Location;"|data_input/cargotracker/cargotracker.txt|75527b59f6b1452ca921c60e357c0eab
"import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.location.LocationRepository;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.service.RoutingService;

@Stateless public class DefaultBookingService implements BookingService {

@Inject private CargoRepository cargoRepository;

@Inject private LocationRepository locationRepository;

@Inject private RoutingService routingService;

@Inject private Logger logger;

@Override public TrackingId bookNewCargo( UnLocode originUnLocode, UnLocode destinationUnLocode, LocalDate arrivalDeadline) { TrackingId trackingId = cargoRepository.nextTrackingId(); Location origin = locationRepository.find(originUnLocode); Location destination = locationRepository.find(destinationUnLocode); RouteSpecification routeSpecification = new RouteSpecification(origin, destination, arrivalDeadline);

Cargo cargo = new Cargo(trackingId, routeSpecification);

cargoRepository.store(cargo); logger.log( Level.INFO, ""Booked new cargo with tracking ID {0}"", cargo.getTrackingId().getIdString());

return cargo.getTrackingId();

}

@Override public List<Itinerary> requestPossibleRoutesForCargo(TrackingId trackingId) { Cargo cargo = cargoRepository.find(trackingId);

if (cargo == null) { return Collections.emptyList(); }"|data_input/cargotracker/cargotracker.txt|0cde8ee3640f45af805352680d1d451a
"if (cargo == null) { return Collections.emptyList(); }

return routingService.fetchRoutesForSpecification(cargo.getRouteSpecification());

}

@Override public void assignCargoToRoute(Itinerary itinerary, TrackingId trackingId) { Cargo cargo = cargoRepository.find(trackingId);

cargo.assignToRoute(itinerary);

cargoRepository.store(cargo);

logger.log(Level.INFO, ""Assigned cargo {0} to new route"", trackingId); }

@Override public void changeDestination(TrackingId trackingId, UnLocode unLocode) { Cargo cargo = cargoRepository.find(trackingId); Location newDestination = locationRepository.find(unLocode);

RouteSpecification routeSpecification =

new RouteSpecification(

cargo.getOrigin(), newDestination, cargo.getRouteSpecification().getArrivalDeadline());

cargo.specifyNewRoute(routeSpecification);

cargoRepository.store(cargo);

logger.log( Level.INFO, ""Changed destination for cargo {0} to {1}"", new Object[] {trackingId, routeSpecification.getDestination()}); }

@Override public void changeDeadline(TrackingId trackingId, LocalDate newDeadline) { Cargo cargo = cargoRepository.find(trackingId);

RouteSpecification routeSpecification =

new RouteSpecification(

cargo.getOrigin(), cargo.getRouteSpecification().getDestination(), newDeadline);

cargo.specifyNewRoute(routeSpecification);

cargoRepository.store(cargo);

logger.log( Level.INFO, ""Changed deadline for cargo {0} to {1}"", new Object[] {trackingId, newDeadline}); } }"|data_input/cargotracker/cargotracker.txt|c2b210b275974950912956df420c2957
"cargoRepository.store(cargo);

logger.log( Level.INFO, ""Changed deadline for cargo {0} to {1}"", new Object[] {trackingId, newDeadline}); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/application/internal/DefaultCargoInspectionService.java

package org.eclipse.cargotracker.application.internal;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.ejb.Stateless;

import jakarta.inject.Inject;

import org.eclipse.cargotracker.application.ApplicationEvents;

import org.eclipse.cargotracker.application.CargoInspectionService;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.CargoRepository;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.handling.HandlingEventRepository;

import org.eclipse.cargotracker.domain.model.handling.HandlingHistory;

@Stateless public class DefaultCargoInspectionService implements CargoInspectionService {

@Inject private Logger logger;

@Inject private ApplicationEvents applicationEvents;

@Inject private CargoRepository cargoRepository;

@Inject private HandlingEventRepository handlingEventRepository;

@Override public void inspectCargo(TrackingId trackingId) { Cargo cargo = cargoRepository.find(trackingId);

if (cargo == null) { logger.log(Level.WARNING, ""Can't inspect non-existing cargo {0}"", trackingId); return; }

HandlingHistory handlingHistory ="|data_input/cargotracker/cargotracker.txt|772c71436c9a45d9a905f0de3a432849
"if (cargo == null) { logger.log(Level.WARNING, ""Can't inspect non-existing cargo {0}"", trackingId); return; }

HandlingHistory handlingHistory =

handlingEventRepository.lookupHandlingHistoryOfCargo(trackingId);

cargo.deriveDeliveryProgress(handlingHistory);

if (cargo.getDelivery().isMisdirected()) {

applicationEvents.cargoWasMisdirected(cargo);

}

if (cargo.getDelivery().isUnloadedAtDestination()) {

applicationEvents.cargoHasArrived(cargo);

}

cargoRepository.store(cargo);

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/application/internal/DefaultHandlingEventService.java

package org.eclipse.cargotracker.application.internal;

import java.time.LocalDateTime;

import java.util.logging.Logger;

import jakarta.ejb.Stateless;

import jakarta.inject.Inject;

import org.eclipse.cargotracker.application.ApplicationEvents;

import org.eclipse.cargotracker.application.HandlingEventService;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.handling.CannotCreateHandlingEventException;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.handling.HandlingEventFactory;

import org.eclipse.cargotracker.domain.model.handling.HandlingEventRepository;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;"|data_input/cargotracker/cargotracker.txt|c35ccfa4daf64710b647e83fede14587
"import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

@Stateless public class DefaultHandlingEventService implements HandlingEventService {

@Inject private ApplicationEvents applicationEvents;

@Inject private HandlingEventRepository handlingEventRepository;

@Inject private HandlingEventFactory handlingEventFactory;

@Inject private Logger logger;

@Override

public void registerHandlingEvent(

LocalDateTime completionTime,

TrackingId trackingId,

VoyageNumber voyageNumber,

UnLocode unLocode,

HandlingEvent.Type type)

throws CannotCreateHandlingEventException {

LocalDateTime registrationTime = LocalDateTime.now();

/* * Using a factory to create a HandlingEvent (aggregate). This is where it is * determined wether the incoming data, the attempt, actually is capable of * representing a real handling event. */ HandlingEvent event = handlingEventFactory.createHandlingEvent( registrationTime, completionTime, trackingId, voyageNumber, unLocode, type);

/* * Store the new handling event, which updates the persistent state of the * handling event aggregate (but not the cargo aggregate - that happens * asynchronously!) */ handlingEventRepository.store(event);

/* Publish an event stating that a cargo has been handled. */ applicationEvents.cargoWasHandled(event);

logger.info(""Registered handling event"");

}

}"|data_input/cargotracker/cargotracker.txt|9e57532429b9487e8fdaa10302439de9
"logger.info(""Registered handling event"");

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/application/util/ApplicationSettings.java

package org.eclipse.cargotracker.application.util;

import java.io.Serializable;

import jakarta.persistence.Entity;

import jakarta.persistence.Id;

/** * Application settings. Although this is stored in the database, it is not a true part of the * domain model but simply an application infrastructure artifact. */ @Entity public class ApplicationSettings implements Serializable { private static final long serialVersionUID = 1L;

@Id private Long id;

private boolean sampleLoaded = false;

public boolean isSampleLoaded() {

return sampleLoaded;

}

public void setSampleLoaded(boolean sampleLoaded) { this.sampleLoaded = sampleLoaded; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/application/util/DateConverter.java

package org.eclipse.cargotracker.application.util;

import java.time.LocalDate;

import java.time.LocalDateTime;

import java.time.ZoneId;

import java.time.format.DateTimeFormatter;

// TODO [Clean Code] Make this a CDI singleton? public class DateConverter { public static final String DATE_FORMAT = ""M/d/yyyy""; public static final String DATE_TIME_FORMAT = ""M/d/yyyy h:m a"";

private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(DATE_FORMAT).withZone(ZoneId.systemDefault());"|data_input/cargotracker/cargotracker.txt|aa7e96513f484508b56157d361022afa
"private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(DATE_FORMAT).withZone(ZoneId.systemDefault());

private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(DATE_TIME_FORMAT).withZone(ZoneId.systemDefault());

private DateConverter() {}

public static LocalDate toDate(String date) { return LocalDate.parse(date, DATE_FORMATTER); }

public static LocalDateTime toDateTime(String datetime) { return LocalDateTime.parse(datetime, DATE_TIME_FORMATTER); }

public static String toString(LocalDateTime dateTime) { return dateTime.format(DATE_TIME_FORMATTER); }

public static String toString(LocalDate date) { return date.format(DATE_FORMATTER); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/application/util/RestConfiguration.java

package org.eclipse.cargotracker.application.util;

import java.util.HashMap;

import java.util.Map;

import jakarta.ws.rs.ApplicationPath;

import jakarta.ws.rs.core.Application;

import org.glassfish.jersey.server.ServerProperties;

/** Jakarta REST configuration. */ @ApplicationPath(""rest"") public class RestConfiguration extends Application {

@Override public Map<String, Object> getProperties() { Map<String, Object> properties = new HashMap<String, Object>(); properties.put(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true); return properties; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/application/util/SampleDataGenerator.java"|data_input/cargotracker/cargotracker.txt|b79e0dcfc82b4e31b6f4d7587df42fef
"../cargotracker/src/main/java/org/eclipse/cargotracker/application/util/SampleDataGenerator.java

package org.eclipse.cargotracker.application.util;

import java.time.LocalDate;

import java.time.LocalDateTime;

import java.util.Arrays;

import java.util.logging.Logger;

import jakarta.annotation.PostConstruct;

import jakarta.ejb.Singleton;

import jakarta.ejb.Startup;

import jakarta.ejb.TransactionAttribute;

import jakarta.ejb.TransactionAttributeType;

import jakarta.inject.Inject;

import jakarta.persistence.EntityManager;

import jakarta.persistence.LockModeType;

import jakarta.persistence.NoResultException;

import jakarta.persistence.PersistenceContext;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.Itinerary;

import org.eclipse.cargotracker.domain.model.cargo.Leg;

import org.eclipse.cargotracker.domain.model.cargo.RouteSpecification;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.handling.CannotCreateHandlingEventException;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.handling.HandlingEventFactory;

import org.eclipse.cargotracker.domain.model.handling.HandlingEventRepository;

import org.eclipse.cargotracker.domain.model.handling.HandlingHistory;

import org.eclipse.cargotracker.domain.model.location.SampleLocations;"|data_input/cargotracker/cargotracker.txt|6a8a3762b8f24eb0814429eb013edc8a
"import org.eclipse.cargotracker.domain.model.handling.HandlingHistory;

import org.eclipse.cargotracker.domain.model.location.SampleLocations;

import org.eclipse.cargotracker.domain.model.voyage.SampleVoyages;

/** Loads sample data for demo. */ @Singleton @Startup public class SampleDataGenerator {

@Inject private Logger logger;

@PersistenceContext private EntityManager entityManager;

@Inject private HandlingEventFactory handlingEventFactory;

@Inject private HandlingEventRepository handlingEventRepository;

@PostConstruct @TransactionAttribute(TransactionAttributeType.REQUIRED) public void loadSampleData() { if (!isSampleLoaded()) { logger.info(""Loading sample data. ""); loadSampleLocations(); loadSampleVoyages(); loadSampleCargos(); } else { logger.info(""Sample data already loaded, skipping. ""); } }

private boolean isSampleLoaded() {

boolean sampleLoaded = false;

try { ApplicationSettings settings = entityManager.find(ApplicationSettings.class, 1L, LockModeType.PESSIMISTIC_WRITE); sampleLoaded = settings.isSampleLoaded(); settings.setSampleLoaded(true); } catch (NoResultException e) { throw new RuntimeException(""Could not retrieve application settings. "", e); }

return sampleLoaded;

}

private void loadSampleLocations() {

logger.info(""Loading sample locations. "");

entityManager.persist(SampleLocations.HONGKONG);

entityManager.persist(SampleLocations.MELBOURNE);

entityManager.persist(SampleLocations.STOCKHOLM);

entityManager.persist(SampleLocations.HELSINKI);"|data_input/cargotracker/cargotracker.txt|0b74607a2b854596953796fe34bb3fb8
"entityManager.persist(SampleLocations.STOCKHOLM);

entityManager.persist(SampleLocations.HELSINKI);

entityManager.persist(SampleLocations.CHICAGO);

entityManager.persist(SampleLocations.TOKYO);

entityManager.persist(SampleLocations.HAMBURG);

entityManager.persist(SampleLocations.SHANGHAI);

entityManager.persist(SampleLocations.ROTTERDAM);

entityManager.persist(SampleLocations.GOTHENBURG);

entityManager.persist(SampleLocations.HANGZOU);

entityManager.persist(SampleLocations.NEWYORK);

entityManager.persist(SampleLocations.DALLAS);

}

private void loadSampleVoyages() {

logger.info(""Loading sample voyages. "");

entityManager.persist(SampleVoyages.HONGKONG_TO_NEW_YORK);

entityManager.persist(SampleVoyages.NEW_YORK_TO_DALLAS);

entityManager.persist(SampleVoyages.DALLAS_TO_HELSINKI);

entityManager.persist(SampleVoyages.HELSINKI_TO_HONGKONG);

entityManager.persist(SampleVoyages.DALLAS_TO_HELSINKI_ALT);

}

private void loadSampleCargos() {

logger.info(""Loading sample cargo data. "");

// Cargo ABC123. This one is en-route. TrackingId trackingId1 = new TrackingId(""ABC123"");

RouteSpecification routeSpecification1 = new RouteSpecification( SampleLocations.HONGKONG, SampleLocations.HELSINKI, LocalDate.now().plusDays(15)); Cargo abc123 = new Cargo(trackingId1, routeSpecification1);

Itinerary itinerary1 =

new Itinerary(

Arrays.asList(

new Leg(

SampleVoyages.HONGKONG_TO_NEW_YORK,

SampleLocations.HONGKONG,

SampleLocations.NEWYORK,"|data_input/cargotracker/cargotracker.txt|771eb6192ae44c6f8d57c6f64d8e4511
"new Itinerary(

Arrays.asList(

new Leg(

SampleVoyages.HONGKONG_TO_NEW_YORK,

SampleLocations.HONGKONG,

SampleLocations.NEWYORK,

LocalDateTime.now().minusDays(7).minusHours(2).minusMinutes(4),

LocalDateTime.now().minusDays(1).minusHours(10).minusMinutes(52)),

new Leg(

SampleVoyages.NEW_YORK_TO_DALLAS,

SampleLocations.NEWYORK,

SampleLocations.DALLAS,

LocalDateTime.now().plusDays(2).minusHours(18).minusMinutes(38),

LocalDateTime.now().plusDays(6).minusHours(3).minusMinutes(22)),

new Leg(

SampleVoyages.DALLAS_TO_HELSINKI,

SampleLocations.DALLAS,

SampleLocations.HELSINKI,

LocalDateTime.now().plusDays(8).minusHours(8).minusMinutes(18),

LocalDateTime.now().plusDays(14).minusHours(12).minusMinutes(29))));

abc123.assignToRoute(itinerary1);

entityManager.persist(abc123);

try {

HandlingEvent event1 =

handlingEventFactory.createHandlingEvent(

LocalDateTime.now().minusHours(5).minusMinutes(5),

LocalDateTime.now().minusDays(10).minusHours(9).minusMinutes(11),

trackingId1,

null,

SampleLocations.HONGKONG.getUnLocode(),

HandlingEvent.Type.RECEIVE);

entityManager.persist(event1);

HandlingEvent event2 =

handlingEventFactory.createHandlingEvent(

LocalDateTime.now().minusHours(6).minusMinutes(46),

LocalDateTime.now().minusDays(7).minusHours(2).minusMinutes(50),

trackingId1,

SampleVoyages.HONGKONG_TO_NEW_YORK.getVoyageNumber(),

SampleLocations.HONGKONG.getUnLocode(),

HandlingEvent.Type.LOAD);

entityManager.persist(event2);"|data_input/cargotracker/cargotracker.txt|15d9bc7337044af198bd0175398a553f
"SampleLocations.HONGKONG.getUnLocode(),

HandlingEvent.Type.LOAD);

entityManager.persist(event2);

HandlingEvent event3 = handlingEventFactory.createHandlingEvent( LocalDateTime.now().minusHours(15).minusMinutes(26), LocalDateTime.now().minusDays(1).minusHours(4).minusMinutes(32), trackingId1, SampleVoyages.HONGKONG_TO_NEW_YORK.getVoyageNumber(), SampleLocations.NEWYORK.getUnLocode(), HandlingEvent.Type.UNLOAD); entityManager.persist(event3); } catch (CannotCreateHandlingEventException e) { throw new RuntimeException(e); }

HandlingHistory handlingHistory1 =

handlingEventRepository.lookupHandlingHistoryOfCargo(trackingId1);

abc123.deriveDeliveryProgress(handlingHistory1);

entityManager.persist(abc123);

// Cargo JKL567. This one was loaded on the wrong voyage. TrackingId trackingId2 = new TrackingId(""JKL567"");

RouteSpecification routeSpecification2 = new RouteSpecification( SampleLocations.HANGZOU, SampleLocations.STOCKHOLM, LocalDate.now().plusDays(18)); Cargo jkl567 = new Cargo(trackingId2, routeSpecification2);

Itinerary itinerary2 =

new Itinerary(

Arrays.asList(

new Leg(

SampleVoyages.HONGKONG_TO_NEW_YORK,

SampleLocations.HANGZOU,

SampleLocations.NEWYORK,

LocalDateTime.now().minusDays(10).minusHours(1).minusMinutes(19),

LocalDateTime.now().minusDays(3).minusHours(7).minusMinutes(2)),

new Leg(

SampleVoyages.NEW_YORK_TO_DALLAS,

SampleLocations.NEWYORK,

SampleLocations.DALLAS,

LocalDateTime.now().minusDays(2).minusHours(17).minusMinutes(3),"|data_input/cargotracker/cargotracker.txt|fb45298db3554cd4b057072bb76d83a7
"SampleLocations.NEWYORK,

SampleLocations.DALLAS,

LocalDateTime.now().minusDays(2).minusHours(17).minusMinutes(3),

LocalDateTime.now().plusDays(2).minusHours(5).minusMinutes(20)),

new Leg(

SampleVoyages.DALLAS_TO_HELSINKI,

SampleLocations.DALLAS,

SampleLocations.STOCKHOLM,

LocalDateTime.now().plusDays(6).minusHours(11).minusMinutes(38),

LocalDateTime.now().plusDays(15).minusHours(4).minusMinutes(1))));

jkl567.assignToRoute(itinerary2);

entityManager.persist(jkl567);

try {

HandlingEvent event1 =

handlingEventFactory.createHandlingEvent(

LocalDateTime.now().minusHours(2).minusMinutes(44),

LocalDateTime.now().minusDays(15).minusHours(14).minusMinutes(33),

trackingId2,

null,

SampleLocations.HANGZOU.getUnLocode(),

HandlingEvent.Type.RECEIVE);

entityManager.persist(event1);

HandlingEvent event2 =

handlingEventFactory.createHandlingEvent(

LocalDateTime.now().minusHours(3).minusMinutes(12),

LocalDateTime.now().minusDays(10).minusHours(3).minusMinutes(17),

trackingId2,

SampleVoyages.HONGKONG_TO_NEW_YORK.getVoyageNumber(),

SampleLocations.HANGZOU.getUnLocode(),

HandlingEvent.Type.LOAD);

entityManager.persist(event2);

HandlingEvent event3 =

handlingEventFactory.createHandlingEvent(

LocalDateTime.now().minusHours(3).minusMinutes(21),

LocalDateTime.now().minusDays(3).minusHours(22).minusMinutes(1),

trackingId2,

SampleVoyages.HONGKONG_TO_NEW_YORK.getVoyageNumber(),

SampleLocations.NEWYORK.getUnLocode(),

HandlingEvent.Type.UNLOAD);"|data_input/cargotracker/cargotracker.txt|27b48a8cd855499abab140a93738bfd5
"trackingId2,

SampleVoyages.HONGKONG_TO_NEW_YORK.getVoyageNumber(),

SampleLocations.NEWYORK.getUnLocode(),

HandlingEvent.Type.UNLOAD);

entityManager.persist(event3);

// The wrong voyage! HandlingEvent event4 = handlingEventFactory.createHandlingEvent( LocalDateTime.now().minusHours(18).minusMinutes(36), LocalDateTime.now().minusDays(2).minusHours(8).minusMinutes(7), trackingId2, SampleVoyages.HONGKONG_TO_NEW_YORK.getVoyageNumber(), SampleLocations.NEWYORK.getUnLocode(), HandlingEvent.Type.LOAD); entityManager.persist(event4); } catch (CannotCreateHandlingEventException e) { throw new RuntimeException(e); }

HandlingHistory handlingHistory2 =

handlingEventRepository.lookupHandlingHistoryOfCargo(trackingId2);

jkl567.deriveDeliveryProgress(handlingHistory2);

entityManager.persist(jkl567);

// Cargo definition DEF789. This one will remain un-routed. TrackingId trackingId3 = new TrackingId(""DEF789"");

RouteSpecification routeSpecification3 =

new RouteSpecification(

SampleLocations.HONGKONG, SampleLocations.MELBOURNE, LocalDate.now().plusMonths(2));

Cargo def789 = new Cargo(trackingId3, routeSpecification3); entityManager.persist(def789);

// Cargo definition MNO456. This one will be claimed properly. TrackingId trackingId4 = new TrackingId(""MNO456""); RouteSpecification routeSpecification4 = new RouteSpecification( SampleLocations.NEWYORK, SampleLocations.DALLAS, LocalDate.now().minusDays(24));

Cargo mno456 = new Cargo(trackingId4, routeSpecification4);"|data_input/cargotracker/cargotracker.txt|d1e6b25261954966ae0a3e9255083020
"Cargo mno456 = new Cargo(trackingId4, routeSpecification4);

Itinerary itinerary4 =

new Itinerary(

Arrays.asList(

new Leg(

SampleVoyages.NEW_YORK_TO_DALLAS,

SampleLocations.NEWYORK,

SampleLocations.DALLAS,

LocalDateTime.now().minusDays(34).minusHours(1).minusMinutes(1),

LocalDateTime.now().minusDays(28).minusHours(10).minusMinutes(1))));

mno456.assignToRoute(itinerary4);

entityManager.persist(mno456);

try {

HandlingEvent event1 =

handlingEventFactory.createHandlingEvent(

LocalDateTime.now().minusHours(16).minusMinutes(9),

LocalDateTime.now().minusDays(37).minusHours(2).minusMinutes(21),

trackingId4,

null,

SampleLocations.NEWYORK.getUnLocode(),

HandlingEvent.Type.RECEIVE);

entityManager.persist(event1);

HandlingEvent event2 =

handlingEventFactory.createHandlingEvent(

LocalDateTime.now().minusHours(3).minusMinutes(9),

LocalDateTime.now().minusDays(34).minusHours(3).minusMinutes(8),

trackingId4,

SampleVoyages.NEW_YORK_TO_DALLAS.getVoyageNumber(),

SampleLocations.NEWYORK.getUnLocode(),

HandlingEvent.Type.LOAD);

entityManager.persist(event2);

HandlingEvent event3 =

handlingEventFactory.createHandlingEvent(

LocalDateTime.now().minusHours(14).minusMinutes(10),

LocalDateTime.now().minusDays(28).minusHours(7).minusMinutes(7),

trackingId4,

SampleVoyages.NEW_YORK_TO_DALLAS.getVoyageNumber(),

SampleLocations.DALLAS.getUnLocode(),

HandlingEvent.Type.UNLOAD);

entityManager.persist(event3);

HandlingEvent event4 ="|data_input/cargotracker/cargotracker.txt|2b2146f423b04a4aa1a9b91af37f7535
"SampleLocations.DALLAS.getUnLocode(),

HandlingEvent.Type.UNLOAD);

entityManager.persist(event3);

HandlingEvent event4 =

handlingEventFactory.createHandlingEvent(

LocalDateTime.now().minusHours(22).minusMinutes(1),

LocalDateTime.now().minusDays(27).minusHours(18).minusMinutes(3),

trackingId4,

null,

SampleLocations.DALLAS.getUnLocode(),

HandlingEvent.Type.CUSTOMS);

entityManager.persist(event4);

HandlingEvent event5 =

handlingEventFactory.createHandlingEvent(

LocalDateTime.now().minusHours(9).minusMinutes(30),

LocalDateTime.now().minusDays(26).minusHours(14).minusMinutes(15),

trackingId4,

null,

SampleLocations.DALLAS.getUnLocode(),

HandlingEvent.Type.CLAIM);

entityManager.persist(event5);

HandlingHistory handlingHistory3 =

handlingEventRepository.lookupHandlingHistoryOfCargo(trackingId4);

mno456.deriveDeliveryProgress(handlingHistory3);

entityManager.persist(mno456); } catch (CannotCreateHandlingEventException e) { throw new RuntimeException(e); } } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/cargo/Cargo.java

package org.eclipse.cargotracker.domain.model.cargo;

import java.io.Serializable;

import jakarta.persistence.Embedded;

import jakarta.persistence.Entity;

import jakarta.persistence.GeneratedValue;

import jakarta.persistence.Id;

import jakarta.persistence.JoinColumn;

import jakarta.persistence.ManyToOne;

import jakarta.persistence.NamedQuery;

import jakarta.validation.constraints.NotNull;"|data_input/cargotracker/cargotracker.txt|7b855901f0e849e29d10015a8e5970d8
"import jakarta.persistence.ManyToOne;

import jakarta.persistence.NamedQuery;

import jakarta.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.handling.HandlingHistory;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.shared.DomainObjectUtils;

/** * A Cargo. This is the central class in the domain model, and it is the root of the * Cargo-Itinerary-Leg-Delivery-RouteSpecification aggregate. */ @Entity @NamedQuery(name = ""Cargo.findAll"", query = ""Select c from Cargo c"") @NamedQuery( name = ""Cargo.findByTrackingId"", query = ""Select c from Cargo c where c.trackingId = :trackingId"") public class Cargo implements Serializable {

private static final long serialVersionUID = 1L;

@Id @GeneratedValue private Long id;

@Embedded @NotNull(message = ""Tracking ID is required."") private TrackingId trackingId;

@ManyToOne @JoinColumn(name = ""origin_id"", updatable = false) @NotNull private Location origin;

@Embedded @NotNull(message = ""Route specification is required."") private RouteSpecification routeSpecification;

@Embedded @NotNull private Itinerary itinerary; @Embedded @NotNull private Delivery delivery;

public Cargo() {

// Nothing to initialize.

}"|data_input/cargotracker/cargotracker.txt|09c33688a4864c23a7a81bd5a5d92877
"@Embedded @NotNull private Itinerary itinerary; @Embedded @NotNull private Delivery delivery;

public Cargo() {

// Nothing to initialize.

}

public Cargo(TrackingId trackingId, RouteSpecification routeSpecification) { Validate.notNull(trackingId, ""Tracking ID is required. ""); Validate.notNull(routeSpecification, ""Route specification is required. "");

this.trackingId = trackingId; // Cargo origin never changes, even if the route specification changes. // However, at creation, cargo origin can be derived from the initial // route specification. this.origin = routeSpecification.getOrigin(); this.routeSpecification = routeSpecification;

this.delivery =

Delivery.derivedFrom(this.routeSpecification, this.itinerary, HandlingHistory.EMPTY);

this.itinerary = Itinerary.EMPTY_ITINERARY;

}

public TrackingId getTrackingId() {

return trackingId;

}

public Location getOrigin() {

return origin;

}

public void setOrigin(Location origin) { this.origin = origin; }

public RouteSpecification getRouteSpecification() {

return routeSpecification;

}

/** @return The delivery. Never null. */ public Delivery getDelivery() { return delivery; }

/** @return The itinerary. Never null. */ public Itinerary getItinerary() { return DomainObjectUtils.nullSafe(this.itinerary, Itinerary.EMPTY_ITINERARY); }

/** Specifies a new route for this cargo. */ public void specifyNewRoute(RouteSpecification routeSpecification) { Validate.notNull(routeSpecification, ""Route specification is required. "");"|data_input/cargotracker/cargotracker.txt|4f60d53c4a894b1cabc963992c6871ea
"this.routeSpecification = routeSpecification; // Handling consistency within the Cargo aggregate synchronously this.delivery = delivery.updateOnRouting(this.routeSpecification, this.itinerary); }

public void assignToRoute(Itinerary itinerary) { Validate.notNull(itinerary, ""Itinerary is required for assignment. "");

this.itinerary = itinerary; // Handling consistency within the Cargo aggregate synchronously this.delivery = delivery.updateOnRouting(this.routeSpecification, this.itinerary); }

/** * Updates all aspects of the cargo aggregate status based on the current route specification, * itinerary and handling of the cargo. * */ public void deriveDeliveryProgress(HandlingHistory handlingHistory) { this.delivery = Delivery.derivedFrom(getRouteSpecification(), getItinerary(), handlingHistory); }

/** * @param object to compare * @return True if they have the same identity * @see #sameIdentityAs(Cargo) */ @Override public boolean equals(Object object) { if (this == object) { return true; } if (object == null || ! (object instanceof Cargo)) { return false; }

Cargo other = (Cargo) object; return sameIdentityAs(other); }

private boolean sameIdentityAs(Cargo other) { return other != null && trackingId.sameValueAs(other.trackingId); }

/** @return Hash code of tracking id. */ @Override public int hashCode() { return trackingId.hashCode(); }

@Override

public String toString() {

return trackingId.toString();

}

}"|data_input/cargotracker/cargotracker.txt|553ab1a177bf47fba5ea700406302875
"@Override

public String toString() {

return trackingId.toString();

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/cargo/CargoRepository.java

package org.eclipse.cargotracker.domain.model.cargo;

import java.util.List;

public interface CargoRepository {

Cargo find(TrackingId trackingId);

List<Cargo> findAll();

void store(Cargo cargo);

TrackingId nextTrackingId();

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/cargo/Delivery.java

package org.eclipse.cargotracker.domain.model.cargo;

import static org.eclipse.cargotracker.domain.model.cargo.RoutingStatus.MISROUTED;

import static org.eclipse.cargotracker.domain.model.cargo.RoutingStatus.NOT_ROUTED;

import static org.eclipse.cargotracker.domain.model.cargo.RoutingStatus.ROUTED;

import static org.eclipse.cargotracker.domain.model.cargo.TransportStatus.CLAIMED;

import static org.eclipse.cargotracker.domain.model.cargo.TransportStatus.IN_PORT;

import static org.eclipse.cargotracker.domain.model.cargo.TransportStatus.NOT_RECEIVED;

import static org.eclipse.cargotracker.domain.model.cargo.TransportStatus.ONBOARD_CARRIER;

import static org.eclipse.cargotracker.domain.model.cargo.TransportStatus.UNKNOWN;

import java.io.Serializable;

import java.time.LocalDateTime;

import java.time.temporal.ChronoUnit;

import java.util.Iterator;

import jakarta.persistence.Column;

import jakarta.persistence.Embeddable;

import jakarta.persistence.Embedded;"|data_input/cargotracker/cargotracker.txt|65c3e0b3f4c3460f81a6927093480919
"import java.util.Iterator;

import jakarta.persistence.Column;

import jakarta.persistence.Embeddable;

import jakarta.persistence.Embedded;

import jakarta.persistence.EnumType;

import jakarta.persistence.Enumerated;

import jakarta.persistence.JoinColumn;

import jakarta.persistence.ManyToOne;

import jakarta.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;

import org.apache.commons.lang3.builder.EqualsBuilder;

import org.apache.commons.lang3.builder.HashCodeBuilder;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.handling.HandlingHistory;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.voyage.Voyage;

import org.eclipse.cargotracker.domain.shared.DomainObjectUtils;

/** * The actual transportation of the cargo, as opposed to the customer requirement * (RouteSpecification) and the plan (Itinerary). */ @Embeddable public class Delivery implements Serializable {

private static final long serialVersionUID = 1L;

// Null object pattern. public static final LocalDateTime ETA_UNKOWN = null; public static final HandlingActivity NO_ACTIVITY = new HandlingActivity();

@Enumerated(EnumType.STRING)

@Column(name = ""transport_status"")

@NotNull

private TransportStatus transportStatus;

@ManyToOne

@JoinColumn(name = ""last_known_location_id"")

private Location lastKnownLocation;

@ManyToOne"|data_input/cargotracker/cargotracker.txt|8307f264bda04b6e839d096dac00ee03
"private TransportStatus transportStatus;

@ManyToOne

@JoinColumn(name = ""last_known_location_id"")

private Location lastKnownLocation;

@ManyToOne

@JoinColumn(name = ""current_voyage_id"")

private Voyage currentVoyage;

@NotNull private boolean misdirected;

private LocalDateTime eta;

@Embedded private HandlingActivity nextExpectedActivity;

@Column(name = ""unloaded_at_dest"")

@NotNull

private boolean isUnloadedAtDestination;

@Enumerated(EnumType.STRING)

@Column(name = ""routing_status"")

@NotNull

private RoutingStatus routingStatus;

@Column(name = ""calculated_at"")

@NotNull

private LocalDateTime calculatedAt;

@ManyToOne

@JoinColumn(name = ""last_event_id"")

private HandlingEvent lastEvent;

public Delivery() {

// Nothing to initialize

}

public Delivery( HandlingEvent lastEvent, Itinerary itinerary, RouteSpecification routeSpecification) {

}

static Delivery derivedFrom( RouteSpecification routeSpecification, Itinerary itinerary, HandlingHistory handlingHistory) { Validate.notNull(routeSpecification, ""Route specification is required""); Validate.notNull(handlingHistory, ""Delivery history is required"");

HandlingEvent lastEvent = handlingHistory.getMostRecentlyCompletedEvent();

return new Delivery(lastEvent, itinerary, routeSpecification); }"|data_input/cargotracker/cargotracker.txt|05d477c599244da5b91cef7672bdf121
"HandlingEvent lastEvent = handlingHistory.getMostRecentlyCompletedEvent();

return new Delivery(lastEvent, itinerary, routeSpecification); }

/** * Creates a new delivery snapshot to reflect changes in routing, i.e. when the route * specification or the itinerary has changed but no additional handling of the cargo has been * performed. */ Delivery updateOnRouting(RouteSpecification routeSpecification, Itinerary itinerary) { Validate.notNull(routeSpecification, ""Route specification is required"");

return new Delivery(this.lastEvent, itinerary, routeSpecification); }

public TransportStatus getTransportStatus() {

return transportStatus;

}

public void setTransportStatus(TransportStatus transportStatus) { this.transportStatus = transportStatus; }

public Location getLastKnownLocation() {

return DomainObjectUtils.nullSafe(lastKnownLocation, Location.UNKNOWN);

}

public void setLastKnownLocation(Location lastKnownLocation) { this.lastKnownLocation = lastKnownLocation; }

public void setLastEvent(HandlingEvent lastEvent) { this.lastEvent = lastEvent; }

public Voyage getCurrentVoyage() {

return DomainObjectUtils.nullSafe(currentVoyage, Voyage.NONE);

}

/** * Check if cargo is misdirected. */ public boolean isMisdirected() { return misdirected; }

public void setMisdirected(boolean misdirected) { this.misdirected = misdirected; }

public LocalDateTime getEstimatedTimeOfArrival() {

return eta;

}

public HandlingActivity getNextExpectedActivity() {"|data_input/cargotracker/cargotracker.txt|b7d9e3fa7f334c0abefb489aa70217e9
"public LocalDateTime getEstimatedTimeOfArrival() {

return eta;

}

public HandlingActivity getNextExpectedActivity() {

return nextExpectedActivity;

}

/** @return True if the cargo has been unloaded at the final destination. */ public boolean isUnloadedAtDestination() { return isUnloadedAtDestination; }

public void setUnloadedAtDestination(boolean isUnloadedAtDestination) { this.isUnloadedAtDestination = isUnloadedAtDestination; }

public RoutingStatus getRoutingStatus() {

return routingStatus;

}

public void setRoutingStatus(RoutingStatus routingStatus) { this.routingStatus = routingStatus; }

public LocalDateTime getCalculatedAt() {

return calculatedAt;

}

public void setCalculatedAt(LocalDateTime calculatedAt) { this.calculatedAt = calculatedAt; }

private TransportStatus calculateTransportStatus() { if (lastEvent == null) { return NOT_RECEIVED; }

switch (lastEvent.getType()) {

case LOAD:

return ONBOARD_CARRIER;

case UNLOAD:

case RECEIVE:

case CUSTOMS:

return IN_PORT;

case CLAIM:

return CLAIMED;

default:

return UNKNOWN;

}

}

private Location calculateLastKnownLocation() { if (lastEvent != null) { return lastEvent.getLocation(); } else { return null; } }

private Voyage calculateCurrentVoyage() { if (getTransportStatus().equals(ONBOARD_CARRIER) && lastEvent != null) { return lastEvent.getVoyage(); } else { return null; } }"|data_input/cargotracker/cargotracker.txt|3ac9f0454d1f46f1a9bd4e5b06e4fc70
"private boolean calculateMisdirectionStatus(Itinerary itinerary) { if (lastEvent == null) { return false; } else { return !itinerary.isExpected(lastEvent); } }

private LocalDateTime calculateEta(Itinerary itinerary) { if (onTrack()) { // This is a workaround to a Hibernate issue. when the `LocalDateTime` field is persisted into // the DB, and retrieved from the DB, the values are different by nanoseconds. return itinerary.getFinalArrivalDate().truncatedTo(ChronoUnit.SECONDS); } else { return ETA_UNKOWN; } }

private HandlingActivity calculateNextExpectedActivity( RouteSpecification routeSpecification, Itinerary itinerary) { if (!onTrack()) { return NO_ACTIVITY; }

if (lastEvent == null) { return new HandlingActivity(HandlingEvent.Type.RECEIVE, routeSpecification.getOrigin()); }

switch (lastEvent.getType()) { case LOAD: for (Leg leg : itinerary.getLegs()) { if (leg.getLoadLocation().sameIdentityAs(lastEvent.getLocation())) { return new HandlingActivity( HandlingEvent.Type.UNLOAD, leg.getUnloadLocation(), leg.getVoyage()); } }

return NO_ACTIVITY;

case UNLOAD: for (Iterator<Leg> iterator = itinerary.getLegs().iterator(); iterator.hasNext(); ) { Leg leg = iterator.next();

if (leg.getUnloadLocation().sameIdentityAs(lastEvent.getLocation())) {

if (iterator.hasNext()) {

Leg nextLeg = iterator.next();

return new HandlingActivity(

HandlingEvent.Type.LOAD, nextLeg.getLoadLocation(), nextLeg.getVoyage());

} else {"|data_input/cargotracker/cargotracker.txt|c87c346d49234282875158633446ef77
"Leg nextLeg = iterator.next();

return new HandlingActivity(

HandlingEvent.Type.LOAD, nextLeg.getLoadLocation(), nextLeg.getVoyage());

} else {

return new HandlingActivity(HandlingEvent.Type.CLAIM, leg.getUnloadLocation());

}

}

}

return NO_ACTIVITY;

case RECEIVE:

Leg firstLeg = itinerary.getLegs().iterator().next();

return new HandlingActivity(

HandlingEvent.Type.LOAD, firstLeg.getLoadLocation(), firstLeg.getVoyage());

case CLAIM:

default:

return NO_ACTIVITY;

}

}

private RoutingStatus calculateRoutingStatus( Itinerary itinerary, RouteSpecification routeSpecification) { if (itinerary == null || itinerary == Itinerary.EMPTY_ITINERARY) { return NOT_ROUTED; } else { if (routeSpecification.isSatisfiedBy(itinerary)) { return ROUTED; } else { return MISROUTED; } } }

private boolean calculateUnloadedAtDestination(RouteSpecification routeSpecification) { return lastEvent != null && HandlingEvent.Type.UNLOAD.sameValueAs(lastEvent.getType()) && routeSpecification.getDestination().sameIdentityAs(lastEvent.getLocation()); }

private boolean onTrack() {

return routingStatus.equals(ROUTED) && !misdirected;

}"|data_input/cargotracker/cargotracker.txt|ccdbb163b6be49a4ab5264167f12c4f1
"private boolean onTrack() {

return routingStatus.equals(ROUTED) && !misdirected;

}

private boolean sameValueAs(Delivery other) { return other != null && new EqualsBuilder() .append(this.transportStatus, other.transportStatus) .append(this.lastKnownLocation, other.lastKnownLocation) .append(this.currentVoyage, other.currentVoyage) .append(this.misdirected, other.misdirected) .append(this.eta, other.eta) .append(this.nextExpectedActivity, other.nextExpectedActivity) .append(this.isUnloadedAtDestination, other.isUnloadedAtDestination) .append(this.routingStatus, other.routingStatus) .append(this.calculatedAt, other.calculatedAt) .append(this.lastEvent, other.lastEvent) .isEquals(); }

@Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || ! (o instanceof Delivery)) { return false; }

Delivery other = (Delivery) o;

return sameValueAs(other);

}

@Override

public int hashCode() {

return new HashCodeBuilder()

.append(transportStatus)

.append(lastKnownLocation)

.append(currentVoyage)

.append(misdirected)

.append(eta)

.append(nextExpectedActivity)

.append(isUnloadedAtDestination)

.append(routingStatus)

.append(calculatedAt)

.append(lastEvent)

.toHashCode();

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/cargo/HandlingActivity.java

package org.eclipse.cargotracker.domain.model.cargo;

import java.io.Serializable;

import jakarta.persistence.Column;

import jakarta.persistence.Embeddable;"|data_input/cargotracker/cargotracker.txt|a3dd6f7c8ce74a70ab6ebd2a9e20fa8c
"import java.io.Serializable;

import jakarta.persistence.Column;

import jakarta.persistence.Embeddable;

import jakarta.persistence.EnumType;

import jakarta.persistence.Enumerated;

import jakarta.persistence.JoinColumn;

import jakarta.persistence.ManyToOne;

import jakarta.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;

import org.apache.commons.lang3.builder.EqualsBuilder;

import org.apache.commons.lang3.builder.HashCodeBuilder;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.voyage.Voyage;

/** * A handling activity represents how and where a cargo can be handled, and can be used to express * predictions about what is expected to happen to a cargo in the future. */ @Embeddable public class HandlingActivity implements Serializable {

private static final long serialVersionUID = 1L;

@Enumerated(EnumType.STRING) @Column(name = ""next_expected_handling_event_type"") @NotNull(message = ""Handling event type is required."") private HandlingEvent.Type type;

@ManyToOne @JoinColumn(name = ""next_expected_location_id"") @NotNull(message = ""Location is required."") private Location location;

@ManyToOne

@JoinColumn(name = ""next_expected_voyage_id"")

private Voyage voyage;

public HandlingActivity() {}"|data_input/cargotracker/cargotracker.txt|f6a9957a59e14c2ca4a8bcdd1c1eccae
text|source|chunk_id
"@ManyToOne

@JoinColumn(name = ""next_expected_voyage_id"")

private Voyage voyage;

public HandlingActivity() {}

public HandlingActivity(HandlingEvent.Type type, Location location) { Validate.notNull(type, ""Handling event type is required. ""); Validate.notNull(location, ""Location is required. "");

this.type = type;

this.location = location;

}

public HandlingActivity(HandlingEvent.Type type, Location location, Voyage voyage) { Validate.notNull(type, ""Handling event type is required""); Validate.notNull(location, ""Location is required""); Validate.notNull(voyage, ""Voyage is required"");

this.type = type;

this.location = location;

this.voyage = voyage;

}

public HandlingEvent.Type getType() {

return type;

}

public Location getLocation() {

return location;

}

public Voyage getVoyage() {

return voyage;

}

private boolean sameValueAs(HandlingActivity other) { return other != null && new EqualsBuilder() .append(this.type, other.type) .append(this.location, other.location) .append(this.voyage, other.voyage) .isEquals(); }

@Override

public int hashCode() {

return new HashCodeBuilder()

.append(this.type)

.append(this.location)

.append(this.voyage)

.toHashCode();

}

@Override public boolean equals(Object obj) { if (obj == this) { return true; }

if (obj == null) { return false; }

if (! (obj instanceof HandlingActivity)) { return false; }

HandlingActivity other = (HandlingActivity) obj;

return sameValueAs(other);

}"|data_input/cargotracker/cargotracker.txt|341620f2c3c54275b85c1a9aa9d44c6c
"if (! (obj instanceof HandlingActivity)) { return false; }

HandlingActivity other = (HandlingActivity) obj;

return sameValueAs(other);

}

public boolean isEmpty() { if (type != null) { return false; }

if (location != null) { return false; }

return voyage == null;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/cargo/Itinerary.java

package org.eclipse.cargotracker.domain.model.cargo;

import java.io.Serializable;

import java.time.LocalDateTime;

import java.util.Collections;

import java.util.List;

import jakarta.persistence.CascadeType;

import jakarta.persistence.Embeddable;

import jakarta.persistence.JoinColumn;

import jakarta.persistence.OneToMany;

import jakarta.persistence.OrderColumn;

import jakarta.validation.constraints.NotEmpty;

import jakarta.validation.constraints.Size;

import org.apache.commons.lang3.Validate;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.location.Location;

@Embeddable public class Itinerary implements Serializable {

private static final long serialVersionUID = 1L;

// Null object pattern. public static final Itinerary EMPTY_ITINERARY = new Itinerary();

// TODO [Clean Code] Look into why cascade delete doesn't work. @OneToMany(cascade = CascadeType.ALL) @JoinColumn(name = ""cargo_id"") @OrderColumn(name = ""leg_order"") @Size(min = 1) @NotEmpty(message = ""Legs must not be empty."") private List<Leg> legs = Collections.emptyList();"|data_input/cargotracker/cargotracker.txt|f96d1a8d7e144c5c867c65c686de6da7
"public Itinerary() {

// Nothing to initialize.

}

public Itinerary(List<Leg> legs) {

Validate.notEmpty(legs);

Validate.noNullElements(legs);

this.legs = legs;

}

public List<Leg> getLegs() {

return Collections.unmodifiableList(legs);

}

/** Test if the given handling event is expected when executing this itinerary. */ public boolean isExpected(HandlingEvent event) { if (legs.isEmpty()) { return true; }

switch (event.getType()) { case RECEIVE: { // Check that the first leg's origin is the event's location Leg leg = legs.get(0); return leg.getLoadLocation().equals(event.getLocation()); }

case LOAD:

{

return legs.stream()

.anyMatch(

leg

>

leg.getLoadLocation().equals(event.getLocation())

&& leg.getVoyage().equals(event.getVoyage()));

}

case UNLOAD: { // Check that the there is one leg with same unload location and // voyage return legs.stream() .anyMatch( leg -> leg.getUnloadLocation().equals(event.getLocation()) && leg.getVoyage().equals(event.getVoyage())); }

case CLAIM: { // Check that the last leg's destination is from the event's // location Leg leg = getLastLeg();

return leg.getUnloadLocation().equals(event.getLocation());

}

case CUSTOMS:

{

return true;

}

default: throw new RuntimeException(""Event case is not handled""); } }

Location getInitialDepartureLocation() {

if (legs.isEmpty()) {

return Location.UNKNOWN;

} else {

return legs.get(0).getLoadLocation();

}

}

Location getFinalArrivalLocation() {

if (legs.isEmpty()) {"|data_input/cargotracker/cargotracker.txt|ae9319c9f99d44538f70b13864265d7b
"return Location.UNKNOWN;

} else {

return legs.get(0).getLoadLocation();

}

}

Location getFinalArrivalLocation() {

if (legs.isEmpty()) {

return Location.UNKNOWN;

} else {

return getLastLeg().getUnloadLocation();

}

}

/** @return Date when cargo arrives at final destination. */ LocalDateTime getFinalArrivalDate() { Leg lastLeg = getLastLeg();

if (lastLeg == null) { return LocalDateTime.MAX; } else { return lastLeg.getUnloadTime(); } }

/** @return The last leg on the itinerary. */ Leg getLastLeg() { if (legs.isEmpty()) { return null; } else { return legs.get(legs.size() - 1); } }

private boolean sameValueAs(Itinerary other) { return other != null && legs.equals(other.legs); }

@Override public boolean equals(Object o) { if (this == o) { return true; }

if (o == null || ! (o instanceof Itinerary)) { return false; }

Itinerary itinerary = (Itinerary) o;

return sameValueAs(itinerary);

}

@Override

public int hashCode() {

return legs.hashCode();

}

@Override public String toString() { return ""Itinerary{"" + ""legs="" + legs + '}'; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/cargo/Leg.java

package org.eclipse.cargotracker.domain.model.cargo;

import java.io.Serializable;

import java.time.LocalDateTime;

import java.time.temporal.ChronoUnit;

import jakarta.persistence.Column;

import jakarta.persistence.Entity;

import jakarta.persistence.GeneratedValue;

import jakarta.persistence.Id;

import jakarta.persistence.JoinColumn;"|data_input/cargotracker/cargotracker.txt|7e31b80d3ed342c7aea5b74e7f119aa1
"import jakarta.persistence.GeneratedValue;

import jakarta.persistence.Id;

import jakarta.persistence.JoinColumn;

import jakarta.persistence.ManyToOne;

import jakarta.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;

import org.apache.commons.lang3.builder.EqualsBuilder;

import org.apache.commons.lang3.builder.HashCodeBuilder;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.voyage.Voyage;

@Entity public class Leg implements Serializable {

private static final long serialVersionUID = 1L;

@Id @GeneratedValue private Long id;

@ManyToOne

@JoinColumn(name = ""voyage_id"")

@NotNull

private Voyage voyage;

@ManyToOne

@JoinColumn(name = ""load_location_id"")

@NotNull

private Location loadLocation;

@ManyToOne

@JoinColumn(name = ""unload_location_id"")

@NotNull

private Location unloadLocation;

@Column(name = ""load_time"")

@NotNull

private LocalDateTime loadTime;

@Column(name = ""unload_time"")

@NotNull

private LocalDateTime unloadTime;

public Leg() {

// Nothing to initialize.

}

public Leg( Voyage voyage, Location loadLocation, Location unloadLocation, LocalDateTime loadTime, LocalDateTime unloadTime) { Validate.noNullElements( new Object[] {voyage, loadLocation, unloadLocation, loadTime, unloadTime});

this.voyage = voyage;

this.loadLocation = loadLocation;

this.unloadLocation = unloadLocation;"|data_input/cargotracker/cargotracker.txt|f6c3efc58eec4f969086ef46b2450d01
"this.voyage = voyage;

this.loadLocation = loadLocation;

this.unloadLocation = unloadLocation;

// This is a workaround to a Hibernate issue. when the `LocalDateTime` field is persisted into // the DB, and retrieved from the DB, the values are different by nanoseconds. this.loadTime = loadTime.truncatedTo(ChronoUnit.SECONDS); this.unloadTime = unloadTime.truncatedTo(ChronoUnit.SECONDS); }

public Voyage getVoyage() {

return voyage;

}

public Location getLoadLocation() {

return loadLocation;

}

public Location getUnloadLocation() {

return unloadLocation;

}

public LocalDateTime getLoadTime() {

return this.loadTime;

}

public LocalDateTime getUnloadTime() {

return this.unloadTime;

}

private boolean sameValueAs(Leg other) { return other != null && new EqualsBuilder() .append(this.voyage, other.voyage) .append(this.loadLocation, other.loadLocation) .append(this.unloadLocation, other.unloadLocation) .append(this.loadTime, other.loadTime) .append(this.unloadTime, other.unloadTime) .isEquals(); }

@Override public boolean equals(Object o) { if (this == o) { return true; }

if (o == null || ! (o instanceof Leg)) { return false; }

Leg leg = (Leg) o;

return sameValueAs(leg);

}

@Override

public int hashCode() {

return new HashCodeBuilder()

.append(voyage)

.append(loadLocation)

.append(unloadLocation)

.append(loadTime)

.append(unloadTime)

.toHashCode();

}

@Override

public String toString() {

return ""Leg{""

+ ""id=""

+ id

+ "", voyage=""

+ voyage"|data_input/cargotracker/cargotracker.txt|d0e3748647194702a2ffc5d9d4b282a1
".append(unloadTime)

.toHashCode();

}

@Override

public String toString() {

return ""Leg{""

+ ""id=""

+ id

+ "", voyage=""

+ voyage

+ "", loadLocation=""

+ loadLocation

+ "", unloadLocation=""

+ unloadLocation

+ "", loadTime=""

+ loadTime

+ "", unloadTime=""

+ unloadTime

+ '}';

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/cargo/RouteSpecification.java

package org.eclipse.cargotracker.domain.model.cargo;

import java.io.Serializable;

import java.time.LocalDate;

import jakarta.persistence.Column;

import jakarta.persistence.Embeddable;

import jakarta.persistence.JoinColumn;

import jakarta.persistence.ManyToOne;

import jakarta.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;

import org.apache.commons.lang3.builder.EqualsBuilder;

import org.apache.commons.lang3.builder.HashCodeBuilder;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.shared.AbstractSpecification;

/** * Route specification. Describes where a cargo origin and destination is, and the arrival deadline. */ @Embeddable public class RouteSpecification extends AbstractSpecification<Itinerary> implements Serializable {

private static final long serialVersionUID = 1L;

@ManyToOne @JoinColumn(name = ""spec_origin_id"", updatable = false) private Location origin;

@ManyToOne

@JoinColumn(name = ""spec_destination_id"")

private Location destination;

@Column(name = ""spec_arrival_deadline"")

@NotNull"|data_input/cargotracker/cargotracker.txt|0625aad18ce74e03979de5874c2fd52d
"@ManyToOne

@JoinColumn(name = ""spec_destination_id"")

private Location destination;

@Column(name = ""spec_arrival_deadline"")

@NotNull

private LocalDate arrivalDeadline;

public RouteSpecification() {}

/** * @param origin origin location - can't be the same as the destination * @param destination destination location - can't be the same as the origin * @param arrivalDeadline arrival deadline */ public RouteSpecification(Location origin, Location destination, LocalDate arrivalDeadline) { Validate.notNull(origin, ""Origin is required""); Validate.notNull(destination, ""Destination is required""); Validate.notNull(arrivalDeadline, ""Arrival deadline is required""); Validate.isTrue( !origin.sameIdentityAs(destination), ""Origin and destination can't be the same: "" + origin);

this.origin = origin;

this.destination = destination;

this.arrivalDeadline = arrivalDeadline;

}

public Location getOrigin() {

return origin;

}

public Location getDestination() {

return destination;

}

public LocalDate getArrivalDeadline() {

return arrivalDeadline;

}

@Override public boolean isSatisfiedBy(Itinerary itinerary) { return itinerary != null && getOrigin().sameIdentityAs(itinerary.getInitialDepartureLocation()) && getDestination().sameIdentityAs(itinerary.getFinalArrivalLocation()) && getArrivalDeadline().isAfter(itinerary.getFinalArrivalDate().toLocalDate()); }"|data_input/cargotracker/cargotracker.txt|c29fa61d8bc744da89d09358eb89cfd5
"private boolean sameValueAs(RouteSpecification other) { return other != null && new EqualsBuilder() .append(this.origin, other.origin) .append(this.destination, other.destination) .append(this.arrivalDeadline, other.arrivalDeadline) .isEquals(); }

@Override public boolean equals(Object o) { if (this == o) { return true; }

if (o == null || ! (o instanceof RouteSpecification)) { return false; }

RouteSpecification that = (RouteSpecification) o;

return sameValueAs(that);

}

@Override

public int hashCode() {

return new HashCodeBuilder()

.append(this.origin)

.append(this.destination)

.append(this.arrivalDeadline)

.toHashCode();

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/cargo/RoutingStatus.java

package org.eclipse.cargotracker.domain.model.cargo;

public enum RoutingStatus {

NOT_ROUTED,

ROUTED,

MISROUTED;

public boolean sameValueAs(RoutingStatus other) { return this.equals(other); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/cargo/TrackingId.java

package org.eclipse.cargotracker.domain.model.cargo;

import java.io.Serializable;

import jakarta.persistence.Column;

import jakarta.persistence.Embeddable;

import jakarta.validation.constraints.NotEmpty;

import org.apache.commons.lang3.Validate;

/** Uniquely identifies a particular cargo. Automatically generated by the application. */ @Embeddable public class TrackingId implements Serializable {

private static final long serialVersionUID = 1L;"|data_input/cargotracker/cargotracker.txt|da496683cc7b46cba1660c798df20959
"private static final long serialVersionUID = 1L;

@Column(name = ""tracking_id"", unique = true, updatable = false) @NotEmpty(message = ""Tracking ID cannot be empty."") private String id;

public TrackingId() {}

public TrackingId(String id) {

Validate.notNull(id);

this.id = id;

}

public String getIdString() {

return id;

}

@Override public boolean equals(Object o) { if (this == o) { return true; }

if (o == null || ! (o instanceof TrackingId)) { return false; }

TrackingId other = (TrackingId) o;

return sameValueAs(other);

}

@Override

public int hashCode() {

return id.hashCode();

}

boolean sameValueAs(TrackingId other) { return other != null && this.id.equals(other.id); }

@Override

public String toString() {

return id;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/cargo/TransportStatus.java

package org.eclipse.cargotracker.domain.model.cargo;

public enum TransportStatus {

NOT_RECEIVED,

IN_PORT,

ONBOARD_CARRIER,

CLAIMED,

UNKNOWN;

public boolean sameValueAs(TransportStatus other) { return this.equals(other); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/handling/CannotCreateHandlingEventException.java

package org.eclipse.cargotracker.domain.model.handling;

import jakarta.ejb.ApplicationException;"|data_input/cargotracker/cargotracker.txt|71a3f4a2ca4049099bd86a98931ba222
"package org.eclipse.cargotracker.domain.model.handling;

import jakarta.ejb.ApplicationException;

/** * If a {@link HandlingEvent} can't be created from a given set of parameters. * * <p>It is a checked exception because it's not a programming error, but rather a special case that * the application is built to handle. It can occur during normal program execution. */ @ApplicationException(rollback = true) public class CannotCreateHandlingEventException extends Exception {

private static final long serialVersionUID = 1L;

public CannotCreateHandlingEventException(Exception e) {

super(e);

}

public CannotCreateHandlingEventException() {

super();

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/handling/HandlingEvent.java

package org.eclipse.cargotracker.domain.model.handling;

import java.io.Serializable;

import java.time.LocalDateTime;

import java.time.temporal.ChronoUnit;

import jakarta.persistence.Column;

import jakarta.persistence.Entity;

import jakarta.persistence.EnumType;

import jakarta.persistence.Enumerated;

import jakarta.persistence.GeneratedValue;

import jakarta.persistence.Id;

import jakarta.persistence.JoinColumn;

import jakarta.persistence.ManyToOne;

import jakarta.persistence.NamedQuery;

import jakarta.persistence.Transient;

import jakarta.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;

import org.apache.commons.lang3.builder.EqualsBuilder;"|data_input/cargotracker/cargotracker.txt|cbd7a939123f4f4fa7ffb08faa9ce9e0
"import jakarta.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;

import org.apache.commons.lang3.builder.EqualsBuilder;

import org.apache.commons.lang3.builder.HashCodeBuilder;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.voyage.Voyage;

import org.eclipse.cargotracker.domain.shared.DomainObjectUtils;"|data_input/cargotracker/cargotracker.txt|faa24cf0f2d04692991b61dbb7f09e7f
"import org.eclipse.cargotracker.domain.model.voyage.Voyage;

import org.eclipse.cargotracker.domain.shared.DomainObjectUtils;

/** * A HandlingEvent is used to register the event when, for instance, a cargo is unloaded from a * carrier at a some location at a given time. * * <p>The HandlingEvent's are sent from different Incident Logging Applications some time after the * event occurred and contain information about the null {@link TrackingId}, {@link Location}, time * stamp of the completion of the event, and possibly, if applicable a {@link Voyage}. * * <p>This class is the only member, and consequently the root, of the HandlingEvent aggregate. * * <p>HandlingEvent's could contain information about a {@link Voyage} and if so, the event type * must be either {@link Type#LOAD} or {@link Type#UNLOAD}. * * <p>All other events must be of {@link Type#RECEIVE}, {@link Type#CLAIM} or {@link Type#CUSTOMS}. */ @Entity @NamedQuery( name = ""HandlingEvent.findByTrackingId"", query = ""Select e from HandlingEvent e where e.cargo.trackingId = :trackingId"") public class HandlingEvent implements Serializable {

private static final long serialVersionUID = 1L;

@Id @GeneratedValue private Long id;

@Enumerated(EnumType.STRING)

@NotNull

private Type type;

@ManyToOne

@JoinColumn(name = ""voyage_id"")

private Voyage voyage;

@ManyToOne

@JoinColumn(name = ""location_id"")

@NotNull

private Location location;

@NotNull

@Column(name = ""completionTime"")

private LocalDateTime completionTime;"|data_input/cargotracker/cargotracker.txt|8389bffcb5134b729bceee575c78b829
"@NotNull

private Location location;

@NotNull

@Column(name = ""completionTime"")

private LocalDateTime completionTime;

@NotNull

@Column(name = ""registration"")

private LocalDateTime registrationTime;

@ManyToOne

@JoinColumn(name = ""cargo_id"")

@NotNull

private Cargo cargo;

@Transient private String summary;

public HandlingEvent() {

// Nothing to initialize.

}

/** * @param cargo The cargo * @param completionTime completion time, the reported time that the event actually happened (e.g. *     the receive took place). * @param registrationTime registration time, the time the message is received * @param type type of event * @param location where the event took place * @param voyage the voyage */ public HandlingEvent( Cargo cargo, LocalDateTime completionTime, LocalDateTime registrationTime, Type type, Location location, Voyage voyage) { Validate.notNull(cargo, ""Cargo is required""); Validate.notNull(completionTime, ""Completion time is required""); Validate.notNull(registrationTime, ""Registration time is required""); Validate.notNull(type, ""Handling event type is required""); Validate.notNull(location, ""Location is required""); Validate.notNull(voyage, ""Voyage is required"");

if (type.prohibitsVoyage()) { throw new IllegalArgumentException(""Voyage is not allowed with event type "" + type); }

this.voyage = voyage;"|data_input/cargotracker/cargotracker.txt|21517b74a2de42618730d29ba0abfb47
"if (type.prohibitsVoyage()) { throw new IllegalArgumentException(""Voyage is not allowed with event type "" + type); }

this.voyage = voyage;

// This is a workaround to a Hibernate issue. when the `LocalDateTime` field is persisted into // the DB, and retrieved from the DB, the values are different by nanoseconds. this.completionTime = completionTime.truncatedTo(ChronoUnit.SECONDS); this.registrationTime = registrationTime.truncatedTo(ChronoUnit.SECONDS); this.type = type; this.location = location; this.cargo = cargo; }

/** * @param cargo cargo * @param completionTime completion time, the reported time that the event actually happened (e.g. *     the receive took place). * @param registrationTime registration time, the time the message is received * @param type type of event * @param location where the event took place */ public HandlingEvent( Cargo cargo, LocalDateTime completionTime, LocalDateTime registrationTime, Type type, Location location) { Validate.notNull(cargo, ""Cargo is required""); Validate.notNull(completionTime, ""Completion time is required""); Validate.notNull(registrationTime, ""Registration time is required""); Validate.notNull(type, ""Handling event type is required""); Validate.notNull(location, ""Location is required"");

if (type.requiresVoyage()) { throw new IllegalArgumentException(""Voyage is required for event type "" + type); }"|data_input/cargotracker/cargotracker.txt|ec64738e4c424af4a2a38e2465d9a5f9
"if (type.requiresVoyage()) { throw new IllegalArgumentException(""Voyage is required for event type "" + type); }

// This is a workaround to a Hibernate issue. when the `LocalDateTime` field is persisted into // the DB, and retrieved from the DB, the values are different by nanoseconds. this.completionTime = completionTime.truncatedTo(ChronoUnit.SECONDS); this.registrationTime = registrationTime.truncatedTo(ChronoUnit.SECONDS); this.type = type; this.location = location; this.cargo = cargo; this.voyage = null; }

public Type getType() {

return this.type;

}

public Voyage getVoyage() {

return DomainObjectUtils.nullSafe(this.voyage, Voyage.NONE);

}

public LocalDateTime getCompletionTime() {

return completionTime;

}

public LocalDateTime getRegistrationTime() {

return registrationTime;

}

public Location getLocation() {

return this.location;

}

public Cargo getCargo() {

return this.cargo;

}

public String getSummary() {

StringBuilder builder =

new StringBuilder(location.getName())

.append(""\n"")

.append(completionTime)

.append(""\n"")

.append(""Type: "")

.append(type)

.append(""\n"")

.append(""Reg. : "")

.append(registrationTime)

.append(""\n"");

if (voyage != null) { builder.append(""Voyage: "").append(voyage.getVoyageNumber()); }

return builder.toString();

}

@Override public boolean equals(Object o) { if (this == o) { return true; }

if (o == null || ! (o instanceof HandlingEvent)) { return false; }

HandlingEvent event = (HandlingEvent) o;"|data_input/cargotracker/cargotracker.txt|015ec6faec6f41588ca9d2505a249055
"if (o == null || ! (o instanceof HandlingEvent)) { return false; }

HandlingEvent event = (HandlingEvent) o;

return sameEventAs(event);

}

private boolean sameEventAs(HandlingEvent other) { return other != null && new EqualsBuilder() .append(this.cargo, other.cargo) .append(this.voyage, other.voyage) .append(this.completionTime, other.completionTime) .append(this.location, other.location) .append(this.type, other.type) .isEquals(); }

@Override

public int hashCode() {

return new HashCodeBuilder()

.append(cargo)

.append(voyage)

.append(completionTime)

.append(location)

.append(type)

.toHashCode();

}

@Override

public String toString() {

StringBuilder builder =

new StringBuilder(""\n--

Handling event --

\n"")

.append(""Cargo: "")

.append(cargo.getTrackingId())

.append(""\n"")

.append(""Type: "")

.append(type)

.append(""\n"")

.append(""Location: "")

.append(location.getName())

.append(""\n"")

.append(""Completed on: "")

.append(completionTime)

.append(""\n"")

.append(""Registered on: "")

.append(registrationTime)

.append(""\n"");

if (voyage != null) { builder.append(""Voyage: "").append(voyage.getVoyageNumber()).append(""\n""); }

return builder.toString();

}

/** * Handling event type. Either requires or prohibits a carrier movement association, it's never * optional. */ public enum Type {"|data_input/cargotracker/cargotracker.txt|201e50a864624b20a16d2da16b4c968b
"}

/** * Handling event type. Either requires or prohibits a carrier movement association, it's never * optional. */ public enum Type {

// Loaded onto voyage from port location. LOAD(true), // Unloaded from voyage to port location UNLOAD(true), // Received by carrier RECEIVE(false), // Cargo claimed by recepient CLAIM(false), // Cargo went through customs CUSTOMS(false);

private final boolean voyageRequired;

/** * Private enum constructor. * * @param voyageRequired whether or not a voyage is associated with this event type */ private Type(boolean voyageRequired) { this.voyageRequired = voyageRequired; }

/** @return True if a voyage association is required for this event type. */ public boolean requiresVoyage() { return voyageRequired; }

/** @return True if a voyage association is prohibited for this event type. */ public boolean prohibitsVoyage() { return !requiresVoyage(); }

public boolean sameValueAs(Type other) { return other != null && this.equals(other); } } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/handling/HandlingEventFactory.java

package org.eclipse.cargotracker.domain.model.handling;

import java.io.Serializable;

import java.time.LocalDateTime;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.inject.Inject;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.CargoRepository;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;"|data_input/cargotracker/cargotracker.txt|b306cbead91c4686a19baf88d630df98
"import org.eclipse.cargotracker.domain.model.cargo.CargoRepository;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.location.LocationRepository;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.Voyage;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

import org.eclipse.cargotracker.domain.model.voyage.VoyageRepository;

@ApplicationScoped public class HandlingEventFactory implements Serializable {

private static final long serialVersionUID = 1L;

@Inject private CargoRepository cargoRepository;

@Inject private VoyageRepository voyageRepository;

@Inject private LocationRepository locationRepository;"|data_input/cargotracker/cargotracker.txt|a8b8391e5fa94915abbe4834a9f2c980
"@Inject private VoyageRepository voyageRepository;

@Inject private LocationRepository locationRepository;

/** * @param registrationTime time when this event was received by the system * @param completionTime when the event was completed, for example finished loading * @param trackingId cargo tracking id * @param voyageNumber voyage number * @param unlocode United Nations Location Code for the location of the event * @param type type of event * @return A handling event. * @throws UnknownVoyageException if there's no voyage with this number * @throws UnknownCargoException if there's no cargo with this tracking id * @throws UnknownLocationException if there's no location with this UN Locode */ // TODO [Clean Code] Look at the exception handling more seriously. public HandlingEvent createHandlingEvent( LocalDateTime registrationTime, LocalDateTime completionTime, TrackingId trackingId, VoyageNumber voyageNumber, UnLocode unlocode, HandlingEvent.Type type) throws CannotCreateHandlingEventException { Cargo cargo = findCargo(trackingId); Voyage voyage = findVoyage(voyageNumber); Location location = findLocation(unlocode);

try { if (voyage == null) { return new HandlingEvent(cargo, completionTime, registrationTime, type, location); } else { return new HandlingEvent(cargo, completionTime, registrationTime, type, location, voyage); } } catch (Exception e) { throw new CannotCreateHandlingEventException(e); } }"|data_input/cargotracker/cargotracker.txt|b448329820794cd8ad95f1858f02e62c
"private Cargo findCargo(TrackingId trackingId) throws UnknownCargoException { Cargo cargo = cargoRepository.find(trackingId);

if (cargo == null) { throw new UnknownCargoException(trackingId); }

return cargo;

}

private Voyage findVoyage(VoyageNumber voyageNumber) throws UnknownVoyageException { if (voyageNumber == null) { return null; }

Voyage voyage = voyageRepository.find(voyageNumber);

if (voyage == null) { throw new UnknownVoyageException(voyageNumber); }

return voyage;

}

private Location findLocation(UnLocode unlocode) throws UnknownLocationException { Location location = locationRepository.find(unlocode);

if (location == null) { throw new UnknownLocationException(unlocode); }

return location;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/handling/HandlingEventRepository.java

package org.eclipse.cargotracker.domain.model.handling;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

public interface HandlingEventRepository {

void store(HandlingEvent event);

HandlingHistory lookupHandlingHistoryOfCargo(TrackingId trackingId);

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/handling/HandlingHistory.java

package org.eclipse.cargotracker.domain.model.handling;

import java.util.ArrayList;

import java.util.Collection;

import java.util.Collections;

import java.util.Comparator;

import java.util.HashSet;

import java.util.List;

import org.apache.commons.lang3.Validate;"|data_input/cargotracker/cargotracker.txt|e75c0b2cafd2482a8a1ad06a6f522f85
"import java.util.Comparator;

import java.util.HashSet;

import java.util.List;

import org.apache.commons.lang3.Validate;

public class HandlingHistory {

// Null object pattern. public static final HandlingHistory EMPTY = new HandlingHistory(Collections.<HandlingEvent>emptyList()); private static final Comparator<HandlingEvent> BY_COMPLETION_TIME_COMPARATOR = Comparator.comparing(HandlingEvent::getCompletionTime);

private final List<HandlingEvent> handlingEvents;

public HandlingHistory(Collection<HandlingEvent> handlingEvents) { Validate.notNull(handlingEvents, ""Handling events are required. "");

this.handlingEvents = new ArrayList<>(handlingEvents);

}

public List<HandlingEvent> getAllHandlingEvents() {

return handlingEvents;

}

/** * @return A distinct list (no duplicate registrations) of handling events, ordered by completion *     time. */ public List<HandlingEvent> getDistinctEventsByCompletionTime() { List<HandlingEvent> ordered = new ArrayList<>(new HashSet<>(handlingEvents)); ordered.sort(BY_COMPLETION_TIME_COMPARATOR);

return Collections.unmodifiableList(ordered);

}

/** @return Most recently completed event, or null if the delivery history is empty. */ public HandlingEvent getMostRecentlyCompletedEvent() { List<HandlingEvent> distinctEvents = getDistinctEventsByCompletionTime();

if (distinctEvents.isEmpty()) {

return null;

} else {

return distinctEvents.get(distinctEvents.size()

1);

}

}"|data_input/cargotracker/cargotracker.txt|a2f2cf8e5be749a08cd7482c80136b7d
"if (distinctEvents.isEmpty()) {

return null;

} else {

return distinctEvents.get(distinctEvents.size()

1);

}

}

private boolean sameValueAs(HandlingHistory other) { return other != null && this.handlingEvents.equals(other.handlingEvents); }

@Override public boolean equals(Object o) { if (this == o) { return true; }

if (o == null || ! (o instanceof HandlingHistory)) { return false; }

HandlingHistory other = (HandlingHistory) o;

return sameValueAs(other);

}

@Override

public int hashCode() {

return handlingEvents.hashCode();

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/handling/UnknownCargoException.java

package org.eclipse.cargotracker.domain.model.handling;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

/** Thrown when trying to register an event with an unknown tracking id. */ public class UnknownCargoException extends CannotCreateHandlingEventException {

private static final long serialVersionUID = 1L;

private final TrackingId trackingId;

/** @param trackingId cargo tracking id */ public UnknownCargoException(TrackingId trackingId) { this.trackingId = trackingId; }

/** {@inheritDoc} */ @Override public String getMessage() { return ""No cargo with tracking id "" + trackingId.getIdString() + "" exists in the system. ""; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/handling/UnknownLocationException.java

package org.eclipse.cargotracker.domain.model.handling;"|data_input/cargotracker/cargotracker.txt|7ad1b86afb434af692010c5e179f53d4
"package org.eclipse.cargotracker.domain.model.handling;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

public class UnknownLocationException extends CannotCreateHandlingEventException {

private static final long serialVersionUID = 1L;

private final UnLocode unlocode;

public UnknownLocationException(UnLocode unlocode) {

this.unlocode = unlocode;

}

@Override public String getMessage() { return ""No location with UN locode "" + unlocode.getIdString() + "" exists in the system. ""; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/handling/UnknownVoyageException.java

package org.eclipse.cargotracker.domain.model.handling;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

/** Thrown when trying to register an event with an unknown carrier movement id. */ public class UnknownVoyageException extends CannotCreateHandlingEventException {

private static final long serialVersionUID = 1L;

private final VoyageNumber voyageNumber;

public UnknownVoyageException(VoyageNumber voyageNumber) {

this.voyageNumber = voyageNumber;

}

@Override public String getMessage() { return ""No voyage with number "" + voyageNumber.getIdString() + "" exists in the system. ""; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/location/Location.java

package org.eclipse.cargotracker.domain.model.location;

import java.io.Serializable;

import jakarta.persistence.Embedded;

import jakarta.persistence.Entity;"|data_input/cargotracker/cargotracker.txt|ff5cc3d4686241eab9b66c1b5e658faa
"import java.io.Serializable;

import jakarta.persistence.Embedded;

import jakarta.persistence.Entity;

import jakarta.persistence.GeneratedValue;

import jakarta.persistence.Id;

import jakarta.persistence.NamedQuery;

import jakarta.validation.constraints.NotEmpty;

import jakarta.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;

/** * A location in our model is stops on a journey, such as cargo origin or destination, or carrier * movement end points. * * <p>It is uniquely identified by a UN location code. */ @Entity @NamedQuery(name = ""Location.findAll"", query = ""Select l from Location l"") @NamedQuery( name = ""Location.findByUnLocode"", query = ""Select l from Location l where l.unLocode = :unLocode"") public class Location implements Serializable {

private static final long serialVersionUID = 1L;

// Special Location object that marks an unknown location. public static final Location UNKNOWN = new Location(new UnLocode(""XXXXX""), ""Unknown location"");

@Id @GeneratedValue private Long id; @Embedded @NotNull private UnLocode unLocode; @NotEmpty private String name;

public Location() {

// Nothing to do.

}

/** * @param unLocode UN Locode * @param name Location name * @throws IllegalArgumentException if the UN Locode or name is null */ public Location(UnLocode unLocode, String name) { Validate.notNull(unLocode); Validate.notNull(name);

this.unLocode = unLocode;

this.name = name;

}"|data_input/cargotracker/cargotracker.txt|d5128a1bd3884d43bbb778b269b1b579
"this.unLocode = unLocode;

this.name = name;

}

/** @return UN location code for this location. */ public UnLocode getUnLocode() { return unLocode; }

/** @return Actual name of this location, e.g. ""Stockholm"". */ public String getName() { return name; }

/** * @param object to compare * @return Since this is an entiy this will be true iff UN locodes are equal. */ @Override public boolean equals(Object object) { if (object == null) { return false; }

if (this == object) { return true; }

if (! (object instanceof Location)) { return false; }

Location other = (Location) object;

return sameIdentityAs(other);

}

public boolean sameIdentityAs(Location other) { return this.unLocode.sameValueAs(other.unLocode); }

/** @return Hash code of UN locode. */ @Override public int hashCode() { return unLocode.hashCode(); }

@Override public String toString() { return name + "" ["" + unLocode + ""]""; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/location/LocationRepository.java

package org.eclipse.cargotracker.domain.model.location;

import java.util.List;

public interface LocationRepository {

Location find(UnLocode unLocode);

List<Location> findAll();

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/location/SampleLocations.java

package org.eclipse.cargotracker.domain.model.location;

/** Sample locations, for test purposes. */ public class SampleLocations {"|data_input/cargotracker/cargotracker.txt|60e9643c5e604df98a6d8289d959c5b1
"package org.eclipse.cargotracker.domain.model.location;

/** Sample locations, for test purposes. */ public class SampleLocations {

public static final Location HONGKONG = new Location(new UnLocode(""CNHKG""), ""Hong Kong""); public static final Location MELBOURNE = new Location(new UnLocode(""AUMEL""), ""Melbourne""); public static final Location STOCKHOLM = new Location(new UnLocode(""SESTO""), ""Stockholm""); public static final Location HELSINKI = new Location(new UnLocode(""FIHEL""), ""Helsinki""); public static final Location CHICAGO = new Location(new UnLocode(""USCHI""), ""Chicago""); public static final Location TOKYO = new Location(new UnLocode(""JNTKO""), ""Tokyo""); public static final Location HAMBURG = new Location(new UnLocode(""DEHAM""), ""Hamburg""); public static final Location SHANGHAI = new Location(new UnLocode(""CNSHA""), ""Shanghai""); public static final Location ROTTERDAM = new Location(new UnLocode(""NLRTM""), ""Rotterdam""); public static final Location GOTHENBURG = new Location(new UnLocode(""SEGOT""), ""Gothenburg""); public static final Location HANGZOU = new Location(new UnLocode(""CNHGH""), ""Hangzhou""); public static final Location NEWYORK = new Location(new UnLocode(""USNYC""), ""New York""); public static final Location DALLAS = new Location(new UnLocode(""USDAL""), ""Dallas""); }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/location/UnLocode.java

package org.eclipse.cargotracker.domain.model.location;

import java.io.Serializable;"|data_input/cargotracker/cargotracker.txt|b1e71e56567e425c81a70658bd12c8bc
"package org.eclipse.cargotracker.domain.model.location;

import java.io.Serializable;

import jakarta.persistence.Embeddable;

import jakarta.validation.constraints.NotEmpty;

import jakarta.validation.constraints.Pattern;

import org.apache.commons.lang3.Validate;

/** * United nations location code. * * <p>http://www.unece.org/cefact/locode/ * http://www.unece.org/cefact/locode/DocColumnDescription.htm#LOCODE */ @Embeddable public class UnLocode implements Serializable {

private static final long serialVersionUID = 1L;

private static final java.util.regex.Pattern VALID_PATTERN = java.util.regex.Pattern.compile(""[a-zA-Z]{2}[a-zA-Z2-9]{3}"");

@NotEmpty(message = ""Location code must not be empty."") // Country code is exactly two letters. // Location code is usually three letters, but may contain the numbers 2-9 // as well. @Pattern(regexp = ""[a-zA-Z]{2}[a-zA-Z2-9]{3}"") private String unlocode;

public UnLocode() {

// Nothing to initialize.

}

/** @param countryAndLocation Location string. */ public UnLocode(String countryAndLocation) { Validate.notNull(countryAndLocation, ""Country and location may not be null. ""); Validate.isTrue( VALID_PATTERN.matcher(countryAndLocation).matches(), countryAndLocation + "" is not a valid UN/LOCODE (does not match pattern)"");

this.unlocode = countryAndLocation.toUpperCase();

}

/** @return country code and location code concatenated, always upper case. */ public String getIdString() { return unlocode; }"|data_input/cargotracker/cargotracker.txt|b96866b702e04bd2b370fe5e433302ad
"}

/** @return country code and location code concatenated, always upper case. */ public String getIdString() { return unlocode; }

@Override public boolean equals(Object o) { if (this == o) { return true; }

if (o == null || ! (o instanceof UnLocode)) { return false; }

UnLocode other = (UnLocode) o;

return sameValueAs(other);

}

@Override

public int hashCode() {

return unlocode.hashCode();

}

boolean sameValueAs(UnLocode other) { return other != null && this.unlocode.equals(other.unlocode); }

@Override

public String toString() {

return getIdString();

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/voyage/CarrierMovement.java

package org.eclipse.cargotracker.domain.model.voyage;

import java.io.Serializable;

import java.time.LocalDateTime;

import java.time.temporal.ChronoUnit;

import jakarta.persistence.Column;

import jakarta.persistence.Entity;

import jakarta.persistence.GeneratedValue;

import jakarta.persistence.Id;

import jakarta.persistence.JoinColumn;

import jakarta.persistence.ManyToOne;

import jakarta.persistence.Table;

import jakarta.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;

import org.apache.commons.lang3.builder.EqualsBuilder;

import org.apache.commons.lang3.builder.HashCodeBuilder;

import org.eclipse.cargotracker.domain.model.location.Location;"|data_input/cargotracker/cargotracker.txt|583a9b3b806c4585a09e2422abd74933
"import org.apache.commons.lang3.builder.HashCodeBuilder;

import org.eclipse.cargotracker.domain.model.location.Location;

/** A carrier movement is a vessel voyage from one location to another. */ @Entity @Table(name = ""carrier_movement"") public class CarrierMovement implements Serializable {

private static final long serialVersionUID = 1L;

// Null object pattern public static final CarrierMovement NONE = new CarrierMovement(Location.UNKNOWN, Location.UNKNOWN, LocalDateTime.MIN, LocalDateTime.MIN);

@Id @GeneratedValue private Long id;

@ManyToOne

@JoinColumn(name = ""departure_location_id"")

@NotNull

private Location departureLocation;

@ManyToOne

@JoinColumn(name = ""arrival_location_id"")

@NotNull

private Location arrivalLocation;

@Column(name = ""departure_time"")

@NotNull

private LocalDateTime departureTime;

@Column(name = ""arrival_time"")

@NotNull

private LocalDateTime arrivalTime;

public CarrierMovement() {

// Nothing to initialize.

}

public CarrierMovement( Location departureLocation, Location arrivalLocation, LocalDateTime departureTime, LocalDateTime arrivalTime) { Validate.noNullElements( new Object[] {departureLocation, arrivalLocation, departureTime, arrivalTime});"|data_input/cargotracker/cargotracker.txt|88a7809c779f4b8eaa5e0cca1f69a394
"// This is a workaround to a Hibernate issue. when the `LocalDateTime` field is persisted into // the DB, and retrieved from the DB, the values are different by nanoseconds. this.departureTime = departureTime.truncatedTo(ChronoUnit.SECONDS); this.arrivalTime = arrivalTime.truncatedTo(ChronoUnit.SECONDS); this.departureLocation = departureLocation; this.arrivalLocation = arrivalLocation; }

public Location getDepartureLocation() {

return departureLocation;

}

public Location getArrivalLocation() {

return arrivalLocation;

}

public LocalDateTime getDepartureTime() {

return departureTime;

}

public LocalDateTime getArrivalTime() {

return arrivalTime;

}

@Override public boolean equals(Object o) { if (this == o) { return true; }

if (o == null || ! (o instanceof CarrierMovement)) { return false; }

CarrierMovement that = (CarrierMovement) o;

return sameValueAs(that);

}

@Override

public int hashCode() {

return new HashCodeBuilder()

.append(this.departureLocation)

.append(this.departureTime)

.append(this.arrivalLocation)

.append(this.arrivalTime)

.toHashCode();

}

private boolean sameValueAs(CarrierMovement other) { return other != null && new EqualsBuilder() .append(this.departureLocation, other.departureLocation) .append(this.departureTime, other.departureTime) .append(this.arrivalLocation, other.arrivalLocation) .append(this.arrivalTime, other.arrivalTime) .isEquals(); } }"|data_input/cargotracker/cargotracker.txt|8b33bc7a7ac44984aebbb71eef7b0492
"../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/voyage/SampleVoyages.java

package org.eclipse.cargotracker.domain.model.voyage;

import java.lang.reflect.Field;

import java.time.LocalDateTime;

import java.util.ArrayList;

import java.util.Collections;

import java.util.HashMap;

import java.util.List;

import java.util.Map;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.location.SampleLocations;

/** Sample carrier movements, for demo/test purposes. */ public class SampleVoyages {"|data_input/cargotracker/cargotracker.txt|3a4f6e71453544439e923fb685a49ade
text|source|chunk_id
"public static final Voyage CM001 = createVoyage(""CM001"", SampleLocations.STOCKHOLM, SampleLocations.HAMBURG); public static final Voyage CM002 = createVoyage(""CM002"", SampleLocations.HAMBURG, SampleLocations.HONGKONG); public static final Voyage CM003 = createVoyage(""CM003"", SampleLocations.HONGKONG, SampleLocations.NEWYORK); public static final Voyage CM004 = createVoyage(""CM004"", SampleLocations.NEWYORK, SampleLocations.CHICAGO); public static final Voyage CM005 = createVoyage(""CM005"", SampleLocations.CHICAGO, SampleLocations.HAMBURG); public static final Voyage CM006 = createVoyage(""CM006"", SampleLocations.HAMBURG, SampleLocations.HANGZOU); public static final Voyage v100 = new Voyage.Builder(new VoyageNumber(""V100""), SampleLocations.HONGKONG) .addMovement( SampleLocations.TOKYO, LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(3).plusHours(6), LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(5).plusHours(18)) .addMovement( SampleLocations.NEWYORK, LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(6).plusHours(11), LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(9).plusHours(11)) .build(); public static final Voyage v200 = new Voyage.Builder(new VoyageNumber(""V200""), SampleLocations.TOKYO) .addMovement( SampleLocations.NEWYORK, LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(6).plusHours(14), LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(8).plusHours(7)) .addMovement( SampleLocations.CHICAGO,"|data_input/cargotracker/cargotracker.txt|446342eb50b14d2896bf4b8feac049a1
"LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(10).plusHours(21), LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(14).plusHours(2)) .addMovement( SampleLocations.STOCKHOLM, LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(14).plusHours(1), LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(16).plusHours(23)) .build(); public static final Voyage v300 = new Voyage.Builder(new VoyageNumber(""V300""), SampleLocations.TOKYO) .addMovement( SampleLocations.ROTTERDAM, LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(8).plusHours(8), LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(11).plusHours(16)) .addMovement( SampleLocations.HAMBURG, LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(11).plusHours(4), LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(12).plusHours(17)) .addMovement( SampleLocations.MELBOURNE, LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(14).plusHours(9), LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(18).plusHours(10)) .addMovement( SampleLocations.TOKYO, LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(19).plusHours(17), LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(21).plusHours(4)) .build(); public static final Voyage v400 = new Voyage.Builder(new VoyageNumber(""V400""), SampleLocations.HAMBURG) .addMovement( SampleLocations.STOCKHOLM, LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(14).plusHours(9),"|data_input/cargotracker/cargotracker.txt|7a67f2c51ec34cddb533b2025e293b8b
"LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(15).plusHours(18)) .addMovement( SampleLocations.HELSINKI, LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(15).plusHours(11), LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(16).plusHours(16)) .addMovement( SampleLocations.HAMBURG, LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(20).plusHours(18), LocalDateTime.now().minusYears(1).plusMonths(3).plusDays(22).plusHours(9)) .build(); /** * Voyage number 0100S (by ship) * * <p>Hongkong - Hangzou - Tokyo - Melbourne - New York */ public static final Voyage HONGKONG_TO_NEW_YORK = new Voyage.Builder(new VoyageNumber(""0100S""), SampleLocations.HONGKONG) .addMovement( SampleLocations.HANGZOU, LocalDateTime.now().minusYears(1).plusMonths(10).plusDays(1).plusHours(12), LocalDateTime.now() .minusYears(1) .plusMonths(10) .plusDays(3) .plusHours(14) .plusMinutes(30)) .addMovement( SampleLocations.TOKYO, LocalDateTime.now().minusYears(1).plusMonths(10).plusDays(4).plusHours(21), LocalDateTime.now() .minusYears(1) .plusMonths(10) .plusDays(6) .plusHours(6) .plusMinutes(15)) .addMovement( SampleLocations.MELBOURNE, LocalDateTime.now().minusYears(1).plusMonths(10).plusDays(9).plusHours(11), LocalDateTime.now() .minusYears(1) .plusMonths(10) .plusDays(12) .plusHours(11) .plusMinutes(30)) .addMovement( SampleLocations.NEWYORK, LocalDateTime.now().minusYears(1).plusMonths(10).plusDays(14).plusHours(12), LocalDateTime.now() .minusYears(1) .plusMonths(10)"|data_input/cargotracker/cargotracker.txt|8fb087d2fc9a4a158e924a6a8c6f2e06
".plusDays(23) .plusHours(23) .plusMinutes(10)) .build(); /** * Voyage number 0200T (by train) * * <p>New York - Chicago - Dallas */ public static final Voyage NEW_YORK_TO_DALLAS = new Voyage.Builder(new VoyageNumber(""0200T""), SampleLocations.NEWYORK) .addMovement( SampleLocations.CHICAGO, LocalDateTime.now().minusYears(1).plusMonths(10).plusDays(24).plusHours(7), LocalDateTime.now() .minusYears(1) .plusMonths(10) .plusDays(24) .plusHours(17) .plusMinutes(45)) .addMovement( SampleLocations.DALLAS, LocalDateTime.now() .minusYears(1) .plusMonths(10) .plusDays(24) .plusHours(21) .plusMinutes(25), LocalDateTime.now() .minusYears(1) .plusMonths(10) .plusDays(25) .plusHours(19) .plusMinutes(30)) .build(); /** * Voyage number 0300A (by airplane) * * <p>Dallas - Hamburg - Stockholm - Helsinki */ public static final Voyage DALLAS_TO_HELSINKI = new Voyage.Builder(new VoyageNumber(""0300A""), SampleLocations.DALLAS) .addMovement( SampleLocations.HAMBURG, LocalDateTime.now() .minusYears(1) .plusMonths(10) .plusDays(29) .plusHours(3) .plusMinutes(30), LocalDateTime.now().minusYears(1).plusMonths(10).plusDays(31).plusHours(14)) .addMovement( SampleLocations.STOCKHOLM, LocalDateTime.now() .minusYears(1) .plusMonths(11) .plusDays(1) .plusHours(15) .plusMinutes(20), LocalDateTime.now() .minusYears(1) .plusMonths(11) .plusDays(1) .plusHours(18) .plusMinutes(40)) .addMovement( SampleLocations.HELSINKI, LocalDateTime.now().minusYears(1).plusMonths(11).plusDays(2).plusHours(9), LocalDateTime.now()"|data_input/cargotracker/cargotracker.txt|36f319d5cac143c98df64306de59c357
".minusYears(1) .plusMonths(11) .plusDays(2) .plusHours(11) .plusMinutes(15)) .build(); /** * Voyage number 0301S (by ship) * * <p>Dallas - Hamburg - Stockholm - Helsinki, alternate route */ public static final Voyage DALLAS_TO_HELSINKI_ALT = new Voyage.Builder(new VoyageNumber(""0301S""), SampleLocations.DALLAS) .addMovement( SampleLocations.HELSINKI, LocalDateTime.now() .minusYears(1) .plusMonths(10) .plusDays(29) .plusHours(3) .plusMinutes(30), LocalDateTime.now() .minusYears(1) .plusMonths(11) .plusDays(5) .plusHours(15) .plusMinutes(45)) .build(); /** * Voyage number 0400S (by ship) * * <p>Helsinki - Rotterdam - Shanghai - Hongkong */ public static final Voyage HELSINKI_TO_HONGKONG = new Voyage.Builder(new VoyageNumber(""0400S""), SampleLocations.HELSINKI) .addMovement( SampleLocations.ROTTERDAM, LocalDateTime.now() .minusYears(1) .plusMonths(11) .plusDays(4) .plusHours(5) .plusMinutes(50), LocalDateTime.now() .minusYears(1) .plusMonths(11) .plusDays(6) .plusHours(14) .plusMinutes(10)) .addMovement( SampleLocations.SHANGHAI, LocalDateTime.now() .minusYears(1) .plusMonths(11) .plusDays(10) .plusHours(21) .plusMinutes(45), LocalDateTime.now() .minusYears(1) .plusMonths(11) .plusDays(22) .plusHours(16) .plusMinutes(40)) .addMovement( SampleLocations.HONGKONG, LocalDateTime.now().minusYears(1).plusMonths(11).plusDays(24).plusHours(7), LocalDateTime.now() .minusYears(1) .plusMonths(11) .plusDays(28) .plusHours(13) .plusMinutes(37)) .build();"|data_input/cargotracker/cargotracker.txt|30b55b0c259b48eda14a228c8d0c8b52
"public static final Map<VoyageNumber, Voyage> ALL = new HashMap<>();

static { for (Field field : SampleVoyages.class.getDeclaredFields()) { if (field.getType().equals(Voyage.class)) { try { Voyage voyage = (Voyage) field.get(null); ALL.put(voyage.getVoyageNumber(), voyage); } catch (IllegalAccessException e) { throw new RuntimeException(e); } } } }

private static Voyage createVoyage(String id, Location from, Location to) { return new Voyage( new VoyageNumber(id), new Schedule( Collections.singletonList( new CarrierMovement(from, to, LocalDateTime.now(), LocalDateTime.now())))); }

public static List<Voyage> getAll() { return new ArrayList<>(ALL.values()); }

public static Voyage lookup(VoyageNumber voyageNumber) { return ALL.get(voyageNumber); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/voyage/Schedule.java

package org.eclipse.cargotracker.domain.model.voyage;

import java.io.Serializable;

import java.util.Collections;

import java.util.List;

import jakarta.persistence.CascadeType;

import jakarta.persistence.Embeddable;

import jakarta.persistence.JoinColumn;

import jakarta.persistence.OneToMany;

import jakarta.persistence.OrderColumn;

import jakarta.validation.constraints.NotNull;

import jakarta.validation.constraints.Size;

import org.apache.commons.lang3.Validate;

import org.apache.commons.lang3.builder.HashCodeBuilder;

/** A voyage schedule. */ @Embeddable public class Schedule implements Serializable {"|data_input/cargotracker/cargotracker.txt|0465b4cee9244c81aa45f80de6684436
"import org.apache.commons.lang3.builder.HashCodeBuilder;

/** A voyage schedule. */ @Embeddable public class Schedule implements Serializable {

private static final long serialVersionUID = 1L;

// Null object pattern. public static final Schedule EMPTY = new Schedule();

// TODO [Clean Code] Look into why cascade delete doesn't work. @OneToMany(cascade = CascadeType.ALL) @JoinColumn(name = ""voyage_id"") @OrderColumn(name = ""movement_order"") @NotNull @Size(min = 1) private List<CarrierMovement> carrierMovements = Collections.emptyList();

public Schedule() {

// Nothing to initialize.

}

Schedule(List<CarrierMovement> carrierMovements) {

Validate.notNull(carrierMovements);

Validate.noNullElements(carrierMovements);

Validate.notEmpty(carrierMovements);

this.carrierMovements = carrierMovements;

}

public List<CarrierMovement> getCarrierMovements() {

return Collections.unmodifiableList(carrierMovements);

}

private boolean sameValueAs(Schedule other) { return other != null && this.carrierMovements.equals(other.carrierMovements); }

@Override public boolean equals(Object o) { if (this == o) { return true; }

if (o == null || ! (o instanceof Schedule)) { return false; }

Schedule that = (Schedule) o;

return sameValueAs(that);

}

@Override

public int hashCode() {

return new HashCodeBuilder().append(this.carrierMovements).toHashCode();

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/voyage/Voyage.java"|data_input/cargotracker/cargotracker.txt|a67e7fcfbabf4e6fa9e19fe77b6fbfa9
"}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/voyage/Voyage.java

package org.eclipse.cargotracker.domain.model.voyage;

import java.io.Serializable;

import java.time.LocalDateTime;

import java.util.ArrayList;

import java.util.List;

import jakarta.persistence.Embedded;

import jakarta.persistence.Entity;

import jakarta.persistence.GeneratedValue;

import jakarta.persistence.Id;

import jakarta.persistence.NamedQuery;

import jakarta.validation.constraints.NotNull;

import org.apache.commons.lang3.Validate;

import org.eclipse.cargotracker.domain.model.location.Location;

@Entity @NamedQuery( name = ""Voyage.findByVoyageNumber"", query = ""Select v from Voyage v where v.voyageNumber = :voyageNumber"") @NamedQuery(name = ""Voyage.findAll"", query = ""Select v from Voyage v order by v.voyageNumber"") public class Voyage implements Serializable { private static final long serialVersionUID = 1L;

// Null object pattern public static final Voyage NONE = new Voyage(new VoyageNumber(""""), Schedule.EMPTY);

@Id @GeneratedValue private Long id;

@Embedded @NotNull(message = ""Voyage number is required."") private VoyageNumber voyageNumber;

@Embedded @NotNull(message = ""Schedule is required."") private Schedule schedule;

public Voyage() {

// Nothing to initialize

}

public Voyage(VoyageNumber voyageNumber, Schedule schedule) { Validate.notNull(voyageNumber, ""Voyage number is required. ""); Validate.notNull(schedule, ""Schedule is required. "");"|data_input/cargotracker/cargotracker.txt|4aa02c30a7fb4c27a5441176e0dac0ff
"this.voyageNumber = voyageNumber;

this.schedule = schedule;

}

public VoyageNumber getVoyageNumber() {

return voyageNumber;

}

public Schedule getSchedule() {

return schedule;

}

@Override

public int hashCode() {

return voyageNumber.hashCode();

}

@Override public boolean equals(Object o) { if (this == o) { return true; }

if (o == null) { return false; }

if (! (o instanceof Voyage)) { return false; }

Voyage that = (Voyage) o;

return sameIdentityAs(that);

}

public boolean sameIdentityAs(Voyage other) { return other != null && this.getVoyageNumber().sameValueAs(other.getVoyageNumber()); }

@Override public String toString() { return ""Voyage "" + voyageNumber; }

/** * Builder pattern is used for incremental construction of a Voyage aggregate. This serves as an * aggregate factory. */ public static class Builder {

private List<CarrierMovement> carrierMovements = new ArrayList<>(); private VoyageNumber voyageNumber; private Location departureLocation;

public Builder(VoyageNumber voyageNumber, Location departureLocation) { Validate.notNull(voyageNumber, ""Voyage number is required""); Validate.notNull(departureLocation, ""Departure location is required"");

this.voyageNumber = voyageNumber;

this.departureLocation = departureLocation;

}

public Builder addMovement( Location arrivalLocation, LocalDateTime departureTime, LocalDateTime arrivalTime) { carrierMovements.add( new CarrierMovement(departureLocation, arrivalLocation, departureTime, arrivalTime));"|data_input/cargotracker/cargotracker.txt|8dbfc9bedcb84dc9bb8217f181090d95
"// Next departure location is the same as this arrival location this.departureLocation = arrivalLocation;

return this;

}

public Voyage build() { return new Voyage(voyageNumber, new Schedule(carrierMovements)); } } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/voyage/VoyageNumber.java

package org.eclipse.cargotracker.domain.model.voyage;

import java.io.Serializable;

import jakarta.persistence.Column;

import jakarta.persistence.Embeddable;

import jakarta.validation.constraints.NotEmpty;

import org.apache.commons.lang3.Validate;

@Embeddable public class VoyageNumber implements Serializable {

private static final long serialVersionUID = 1L;

@Column(name = ""voyage_number"") @NotEmpty(message = ""Voyage number cannot be empty."") private String number;

public VoyageNumber() {

// Nothing to initialize.

}

public VoyageNumber(String number) {

Validate.notNull(number);

this.number = number;

}

@Override public boolean equals(Object o) { if (this == o) { return true; }

if (o == null) { return false; }

if (! (o instanceof VoyageNumber)) { return false; }

VoyageNumber other = (VoyageNumber) o;

return sameValueAs(other);

}

@Override

public int hashCode() {

return number.hashCode();

}

boolean sameValueAs(VoyageNumber other) { return other != null && this.number.equals(other.number); }

@Override

public String toString() {

return number;

}

public String getIdString() {

return number;

}

}"|data_input/cargotracker/cargotracker.txt|6f71b786fbe54e25ab482e41eff7b582
"@Override

public String toString() {

return number;

}

public String getIdString() {

return number;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/model/voyage/VoyageRepository.java

package org.eclipse.cargotracker.domain.model.voyage;

import java.util.List;

public interface VoyageRepository {

Voyage find(VoyageNumber voyageNumber);

List<Voyage> findAll();

}

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/service/RoutingService.java

package org.eclipse.cargotracker.domain.service;

import java.util.List;

import org.eclipse.cargotracker.domain.model.cargo.Itinerary;

import org.eclipse.cargotracker.domain.model.cargo.RouteSpecification;

public interface RoutingService {

/** * @param routeSpecification Route specification * @return A list of itineraries that satisfy the specification. May be an empty list if no route *     is found. */ List<Itinerary> fetchRoutesForSpecification(RouteSpecification routeSpecification); }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/shared/AbstractSpecification.java

package org.eclipse.cargotracker.domain.shared;

/** * Abstract base implementation of composite {@link Specification} with default implementations for * {@code and}, {@code or} and {@code not}. */ public abstract class AbstractSpecification<T> implements Specification<T> {

/** {@inheritDoc} */ @Override public abstract boolean isSatisfiedBy(T t);"|data_input/cargotracker/cargotracker.txt|78211de129a8475283dd2a103710fe10
"/** {@inheritDoc} */ @Override public abstract boolean isSatisfiedBy(T t);

/** {@inheritDoc} */ @Override public Specification<T> and(Specification<T> specification) { return new AndSpecification<>(this, specification); }

/** {@inheritDoc} */ @Override public Specification<T> or(Specification<T> specification) { return new OrSpecification<>(this, specification); }

/** {@inheritDoc} */ @Override public Specification<T> not(Specification<T> specification) { return new NotSpecification<>(specification); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/shared/AndSpecification.java

package org.eclipse.cargotracker.domain.shared;

/** * AND specification, used to create a new specification that is the AND of two other * specifications. */ public class AndSpecification<T> extends AbstractSpecification<T> {

private final Specification<T> spec1;

private final Specification<T> spec2;

/** * Create a new AND specification based on two other spec. * * @param spec1 Specification one. * @param spec2 Specification two. */ public AndSpecification(Specification<T> spec1, Specification<T> spec2) { this.spec1 = spec1; this.spec2 = spec2; }

/** {@inheritDoc} */ @Override public boolean isSatisfiedBy(T t) { return spec1.isSatisfiedBy(t) && spec2.isSatisfiedBy(t); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/shared/DomainObjectUtils.java

package org.eclipse.cargotracker.domain.shared;"|data_input/cargotracker/cargotracker.txt|bc2ec3caa2644c859a33a1abafff4bd1
"../cargotracker/src/main/java/org/eclipse/cargotracker/domain/shared/DomainObjectUtils.java

package org.eclipse.cargotracker.domain.shared;

// TODO [Clean Code] Make this a CDI singleton? public class DomainObjectUtils {

/*

Prevent instantiation.

/

private DomainObjectUtils() {}

/** * @param actual actual value * @param safe a null-safe value * @param <T> type * @return actual value, if it's not null, or safe value if the actual value is null. */ public static <T> T nullSafe(T actual, T safe) { return actual == null ? safe : actual; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/shared/NotSpecification.java

package org.eclipse.cargotracker.domain.shared;

/** NOT decorator, used to create a new specifcation that is the inverse (NOT) of the given spec. */ public class NotSpecification<T> extends AbstractSpecification<T> {

private final Specification<T> spec1;

/** * Create a new NOT specification based on another spec. * * @param spec1 Specification instance to not. */ public NotSpecification(Specification<T> spec1) { this.spec1 = spec1; }

/** {@inheritDoc} */ @Override public boolean isSatisfiedBy(T t) { return !spec1.isSatisfiedBy(t); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/shared/OrSpecification.java

package org.eclipse.cargotracker.domain.shared;"|data_input/cargotracker/cargotracker.txt|b908309eaf5f49e5bf96e6735e66fc93
"../cargotracker/src/main/java/org/eclipse/cargotracker/domain/shared/OrSpecification.java

package org.eclipse.cargotracker.domain.shared;

/** * OR specification, used to create a new specification that is the OR of two other specifications. */ public class OrSpecification<T> extends AbstractSpecification<T> {

private final Specification<T> spec1;

private final Specification<T> spec2;

/** * Create a new OR specification based on two other spec. * * @param spec1 Specification one. * @param spec2 Specification two. */ public OrSpecification(Specification<T> spec1, Specification<T> spec2) { this.spec1 = spec1; this.spec2 = spec2; }

/** {@inheritDoc} */ @Override public boolean isSatisfiedBy(T t) { return spec1.isSatisfiedBy(t) || spec2.isSatisfiedBy(t); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/domain/shared/Specification.java

package org.eclipse.cargotracker.domain.shared;

/** * Specification interface. * * <p>Use {@link AbstractSpecification} as base for creating specifications, and only the method * {@link #isSatisfiedBy(Object)} must be implemented. */ public interface Specification<T> {

/** * Check if {@code t} is satisfied by the specification. * * @param t Object to test. * @return {@code true} if {@code t} satisfies the specification. */ boolean isSatisfiedBy(T t);"|data_input/cargotracker/cargotracker.txt|7c344f26bedc47e7acb56e345263a420
"/** * Create a new specification that is the AND operation of {@code this} specification and another * specification. * * @param specification Specification to AND. * @return A new specification. */ Specification<T> and(Specification<T> specification);

/** * Create a new specification that is the OR operation of {@code this} specification and another * specification. * * @param specification Specification to OR. * @return A new specification. */ Specification<T> or(Specification<T> specification);

/** * Create a new specification that is the NOT operation of {@code this} specification. * * @param specification Specification to NOT. * @return A new specification. */ Specification<T> not(Specification<T> specification); }

../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/events/cdi/CargoUpdated.java

package org.eclipse.cargotracker.infrastructure.events.cdi;

import static java.lang.annotation.ElementType.FIELD;

import static java.lang.annotation.ElementType.PARAMETER;

import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;

import java.lang.annotation.Target;

import jakarta.inject.Qualifier;

@Qualifier

@Retention(RUNTIME)

@Target({FIELD, PARAMETER})

public @interface CargoUpdated {}

../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/logging/LoggerProducer.java

package org.eclipse.cargotracker.infrastructure.logging;

import java.io.Serializable;

import java.util.logging.Logger;"|data_input/cargotracker/cargotracker.txt|75ab7faee3c147588bd0c26b24c614c7
"package org.eclipse.cargotracker.infrastructure.logging;

import java.io.Serializable;

import java.util.logging.Logger;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.enterprise.inject.Produces;

import jakarta.enterprise.inject.spi.InjectionPoint;

@ApplicationScoped public class LoggerProducer implements Serializable {

private static final long serialVersionUID = 1L;

@Produces public Logger produceLogger(InjectionPoint injectionPoint) { String loggerName = extractLoggerName(injectionPoint);

return Logger.getLogger(loggerName);

}

private String extractLoggerName(InjectionPoint injectionPoint) { if (injectionPoint.getBean() == null) { return injectionPoint.getMember().getDeclaringClass().getName(); }

if (injectionPoint.getBean().getName() == null) { return injectionPoint.getBean().getBeanClass().getName(); }

return injectionPoint.getBean().getName();

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/messaging/jms/CargoHandledConsumer.java

package org.eclipse.cargotracker.infrastructure.messaging.jms;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.ejb.ActivationConfigProperty;

import jakarta.ejb.MessageDriven;

import jakarta.inject.Inject;

import jakarta.jms.JMSException;

import jakarta.jms.Message;

import jakarta.jms.MessageListener;

import jakarta.jms.TextMessage;

import org.eclipse.cargotracker.application.CargoInspectionService;"|data_input/cargotracker/cargotracker.txt|b8da156aaa1a4f8caf716d79299c27e8
"import jakarta.jms.MessageListener;

import jakarta.jms.TextMessage;

import org.eclipse.cargotracker.application.CargoInspectionService;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

/** * Consumes JMS messages and delegates notification of misdirected cargo to the tracking service. * * <p>This is a programmatic hook into the JMS infrastructure to make cargo inspection * message-driven. */ @MessageDriven( activationConfig = { @ActivationConfigProperty( propertyName = ""destinationType"", propertyValue = ""jakarta.jms.Queue""), @ActivationConfigProperty( propertyName = ""destinationLookup"", propertyValue = ""java:app/jms/CargoHandledQueue"") }) public class CargoHandledConsumer implements MessageListener {

@Inject private Logger logger;

@Inject private CargoInspectionService cargoInspectionService;

@Override public void onMessage(Message message) { try { TextMessage textMessage = (TextMessage) message; String trackingIdString = textMessage.getText();

cargoInspectionService.inspectCargo(new TrackingId(trackingIdString)); } catch (JMSException e) { logger.log(Level.SEVERE, ""Error procesing JMS message"", e); } } }

../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/messaging/jms/DeliveredCargoConsumer.java

package org.eclipse.cargotracker.infrastructure.messaging.jms;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.ejb.ActivationConfigProperty;

import jakarta.ejb.MessageDriven;"|data_input/cargotracker/cargotracker.txt|ef658f022c6848e7a9100bdd9cb3df90
"import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.ejb.ActivationConfigProperty;

import jakarta.ejb.MessageDriven;

import jakarta.inject.Inject;

import jakarta.jms.JMSException;

import jakarta.jms.Message;

import jakarta.jms.MessageListener;

@MessageDriven( activationConfig = { @ActivationConfigProperty( propertyName = ""destinationType"", propertyValue = ""jakarta.jms.Queue""), @ActivationConfigProperty( propertyName = ""destinationLookup"", propertyValue = ""java:app/jms/DeliveredCargoQueue"") }) public class DeliveredCargoConsumer implements MessageListener {

@Inject private Logger logger;

@Override public void onMessage(Message message) { try { logger.log( Level.INFO, ""Cargo with tracking ID {0} delivered. "", message.getBody(String.class)); } catch (JMSException ex) { logger.log(Level.WARNING, ""Error processing message. "", ex); } } }

../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/messaging/jms/HandlingEventRegistrationAttemptConsumer.java

package org.eclipse.cargotracker.infrastructure.messaging.jms;

import jakarta.ejb.ActivationConfigProperty;

import jakarta.ejb.MessageDriven;

import jakarta.inject.Inject;

import jakarta.jms.JMSException;

import jakarta.jms.Message;

import jakarta.jms.MessageListener;

import jakarta.jms.ObjectMessage;

import org.eclipse.cargotracker.application.HandlingEventService;

import org.eclipse.cargotracker.domain.model.handling.CannotCreateHandlingEventException;"|data_input/cargotracker/cargotracker.txt|d32bf999905f42aaaf1167fd7490f196
"import org.eclipse.cargotracker.domain.model.handling.CannotCreateHandlingEventException;

import org.eclipse.cargotracker.interfaces.handling.HandlingEventRegistrationAttempt;

/** Consumes handling event registration attempt messages and delegates to proper registration. */ @MessageDriven( activationConfig = { @ActivationConfigProperty( propertyName = ""destinationType"", propertyValue = ""jakarta.jms.Queue""), @ActivationConfigProperty( propertyName = ""destinationLookup"", propertyValue = ""java:app/jms/HandlingEventRegistrationAttemptQueue"") }) public class HandlingEventRegistrationAttemptConsumer implements MessageListener {

@Inject private HandlingEventService handlingEventService;

@Override public void onMessage(Message message) { try { ObjectMessage objectMessage = (ObjectMessage) message; HandlingEventRegistrationAttempt attempt = (HandlingEventRegistrationAttempt) objectMessage.getObject(); handlingEventService.registerHandlingEvent( attempt.getCompletionTime(), attempt.getTrackingId(), attempt.getVoyageNumber(), attempt.getUnLocode(), attempt.getType()); } catch (JMSException | CannotCreateHandlingEventException e) { // Poison messages will be placed on dead-letter queue. throw new RuntimeException(""Error occurred processing message"", e); } } }

../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/messaging/jms/JmsApplicationEvents.java

package org.eclipse.cargotracker.infrastructure.messaging.jms;

import java.io.Serializable;"|data_input/cargotracker/cargotracker.txt|3bc4986b9c874e38ad4c5a26ac660f40
"package org.eclipse.cargotracker.infrastructure.messaging.jms;

import java.io.Serializable;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.annotation.Resource;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.inject.Inject;

import jakarta.jms.Destination;

import jakarta.jms.JMSContext;

import org.eclipse.cargotracker.application.ApplicationEvents;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.interfaces.handling.HandlingEventRegistrationAttempt;

@ApplicationScoped public class JmsApplicationEvents implements ApplicationEvents, Serializable {

private static final long serialVersionUID = 1L; private static final int LOW_PRIORITY = 0; @Inject JMSContext jmsContext;

@Resource(lookup = ""java:app/jms/CargoHandledQueue"")

private Destination cargoHandledQueue;

@Resource(lookup = ""java:app/jms/MisdirectedCargoQueue"")

private Destination misdirectedCargoQueue;

@Resource(lookup = ""java:app/jms/DeliveredCargoQueue"")

private Destination deliveredCargoQueue;

@Resource(lookup = ""java:app/jms/HandlingEventRegistrationAttemptQueue"")

private Destination handlingEventQueue;

@Inject private Logger logger;"|data_input/cargotracker/cargotracker.txt|a5fca5d8cd354dedb641070cea540c1b
"@Resource(lookup = ""java:app/jms/HandlingEventRegistrationAttemptQueue"")

private Destination handlingEventQueue;

@Inject private Logger logger;

@Override public void cargoWasHandled(HandlingEvent event) { Cargo cargo = event.getCargo(); logger.log(Level.INFO, ""Cargo was handled {0}"", cargo); jmsContext .createProducer() .setPriority(LOW_PRIORITY) .setDisableMessageID(true) .setDisableMessageTimestamp(true) .send(cargoHandledQueue, cargo.getTrackingId().getIdString()); }

@Override public void cargoWasMisdirected(Cargo cargo) { logger.log(Level.INFO, ""Cargo was misdirected {0}"", cargo); jmsContext .createProducer() .setPriority(LOW_PRIORITY) .setDisableMessageID(true) .setDisableMessageTimestamp(true) .send(misdirectedCargoQueue, cargo.getTrackingId().getIdString()); }

@Override public void cargoHasArrived(Cargo cargo) { logger.log(Level.INFO, ""Cargo has arrived {0}"", cargo); jmsContext .createProducer() .setPriority(LOW_PRIORITY) .setDisableMessageID(true) .setDisableMessageTimestamp(true) .send(deliveredCargoQueue, cargo.getTrackingId().getIdString()); }

@Override public void receivedHandlingEventRegistrationAttempt(HandlingEventRegistrationAttempt attempt) { logger.log(Level.INFO, ""Received handling event registration attempt {0}"", attempt); jmsContext .createProducer() .setPriority(LOW_PRIORITY) .setDisableMessageID(true) .setDisableMessageTimestamp(true) .setTimeToLive(1000) .send(handlingEventQueue, attempt); } }"|data_input/cargotracker/cargotracker.txt|87e886e108be48fba4111d92f19c0000
"../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/messaging/jms/MisdirectedCargoConsumer.java

package org.eclipse.cargotracker.infrastructure.messaging.jms;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.ejb.ActivationConfigProperty;

import jakarta.ejb.MessageDriven;

import jakarta.inject.Inject;

import jakarta.jms.JMSException;

import jakarta.jms.Message;

import jakarta.jms.MessageListener;

@MessageDriven( activationConfig = { @ActivationConfigProperty( propertyName = ""destinationType"", propertyValue = ""jakarta.jms.Queue""), @ActivationConfigProperty( propertyName = ""destinationLookup"", propertyValue = ""java:app/jms/MisdirectedCargoQueue"") }) public class MisdirectedCargoConsumer implements MessageListener {

@Inject private Logger logger;

@Override public void onMessage(Message message) { try { logger.log( Level.INFO, ""Cargo with tracking ID {0} misdirected. "", message.getBody(String.class)); } catch (JMSException ex) { logger.log(Level.WARNING, ""Error processing message. "", ex); } } }

../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/messaging/jms/RejectedRegistrationAttemptsConsumer.java

package org.eclipse.cargotracker.infrastructure.messaging.jms;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.ejb.ActivationConfigProperty;

import jakarta.ejb.MessageDriven;

import jakarta.inject.Inject;

import jakarta.jms.JMSException;

import jakarta.jms.Message;"|data_input/cargotracker/cargotracker.txt|79f593e988974884b4584e0eb74e290f
"import jakarta.ejb.MessageDriven;

import jakarta.inject.Inject;

import jakarta.jms.JMSException;

import jakarta.jms.Message;

import jakarta.jms.MessageListener;

@MessageDriven( activationConfig = { @ActivationConfigProperty( propertyName = ""destinationType"", propertyValue = ""jakarta.jms.Queue""), @ActivationConfigProperty( propertyName = ""destinationLookup"", propertyValue = ""java:app/jms/RejectedRegistrationAttemptsQueue"") }) public class RejectedRegistrationAttemptsConsumer implements MessageListener {

@Inject private Logger logger;

@Override public void onMessage(Message message) { try { logger.log( Level.INFO, ""Rejected registration attempt of cargo with tracking ID {0}. "", message.getBody(String.class)); } catch (JMSException ex) { logger.log(Level.WARNING, ""Error processing message. "", ex); } } }

../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/persistence/jpa/JpaCargoRepository.java

package org.eclipse.cargotracker.infrastructure.persistence.jpa;

import java.io.Serializable;

import java.util.List;

import java.util.UUID;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.enterprise.event.Event;

import jakarta.inject.Inject;

import jakarta.persistence.EntityManager;

import jakarta.persistence.NoResultException;

import jakarta.persistence.PersistenceContext;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;"|data_input/cargotracker/cargotracker.txt|39c4223d9b2744c2849c721d0c58e0b2
"import jakarta.persistence.PersistenceContext;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.CargoRepository;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.infrastructure.events.cdi.CargoUpdated;

@ApplicationScoped public class JpaCargoRepository implements CargoRepository, Serializable {

private static final long serialVersionUID = 1L;

@Inject private Logger logger;

@PersistenceContext private EntityManager entityManager;

@Inject @CargoUpdated private Event<Cargo> cargoUpdated;

@Override public Cargo find(TrackingId trackingId) { Cargo cargo;

try { cargo = entityManager .createNamedQuery(""Cargo.findByTrackingId"", Cargo.class) .setParameter(""trackingId"", trackingId) .getSingleResult(); } catch (NoResultException e) { logger.log(Level.FINE, ""Find called on non-existant tracking ID. "", e); cargo = null; }

return cargo;

}

@Override

public List<Cargo> findAll() {

return entityManager.createNamedQuery(""Cargo.findAll"", Cargo.class).getResultList();

}

@Override public void store(Cargo cargo) { // TODO [Clean Code] See why cascade is not working correctly for legs. cargo.getItinerary().getLegs().forEach(leg -> entityManager.persist(leg));

entityManager.persist(cargo);

cargoUpdated.fireAsync(cargo);

}

@Override

public TrackingId nextTrackingId() {

String random = UUID.randomUUID().toString().toUpperCase();"|data_input/cargotracker/cargotracker.txt|c4125bbff5364d45b0a785df3b640d8c
"cargoUpdated.fireAsync(cargo);

}

@Override

public TrackingId nextTrackingId() {

String random = UUID.randomUUID().toString().toUpperCase();

return new TrackingId(random.substring(0, random.indexOf(""

"")));

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/persistence/jpa/JpaHandlingEventRepository.java

package org.eclipse.cargotracker.infrastructure.persistence.jpa;

import java.io.Serializable;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.persistence.EntityManager;

import jakarta.persistence.PersistenceContext;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.handling.HandlingEventRepository;

import org.eclipse.cargotracker.domain.model.handling.HandlingHistory;

@ApplicationScoped public class JpaHandlingEventRepository implements HandlingEventRepository, Serializable {

private static final long serialVersionUID = 1L;

@PersistenceContext private EntityManager entityManager;

@Override public void store(HandlingEvent event) { entityManager.persist(event); }

@Override public HandlingHistory lookupHandlingHistoryOfCargo(TrackingId trackingId) { return new HandlingHistory( entityManager .createNamedQuery(""HandlingEvent.findByTrackingId"", HandlingEvent.class) .setParameter(""trackingId"", trackingId) .getResultList()); } }"|data_input/cargotracker/cargotracker.txt|4017dba3c2f646b5a0d39767de87cfdc
"../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/persistence/jpa/JpaLocationRepository.java

package org.eclipse.cargotracker.infrastructure.persistence.jpa;

import java.io.Serializable;

import java.util.List;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.persistence.EntityManager;

import jakarta.persistence.PersistenceContext;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.location.LocationRepository;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

@ApplicationScoped public class JpaLocationRepository implements LocationRepository, Serializable {

private static final long serialVersionUID = 1L;

@PersistenceContext private EntityManager entityManager;

@Override public Location find(UnLocode unLocode) { return entityManager .createNamedQuery(""Location.findByUnLocode"", Location.class) .setParameter(""unLocode"", unLocode) .getSingleResult(); }

@Override

public List<Location> findAll() {

return entityManager.createNamedQuery(""Location.findAll"", Location.class).getResultList();

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/persistence/jpa/JpaVoyageRepository.java

package org.eclipse.cargotracker.infrastructure.persistence.jpa;

import java.io.Serializable;

import java.util.List;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.persistence.EntityManager;"|data_input/cargotracker/cargotracker.txt|f70b73f1981047f994300c1e3a5a0155
"import java.util.List;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.persistence.EntityManager;

import jakarta.persistence.PersistenceContext;

import org.eclipse.cargotracker.domain.model.voyage.Voyage;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

import org.eclipse.cargotracker.domain.model.voyage.VoyageRepository;

@ApplicationScoped public class JpaVoyageRepository implements VoyageRepository, Serializable {

private static final long serialVersionUID = 1L;

@PersistenceContext private EntityManager entityManager;

@Override public Voyage find(VoyageNumber voyageNumber) { return entityManager .createNamedQuery(""Voyage.findByVoyageNumber"", Voyage.class) .setParameter(""voyageNumber"", voyageNumber) .getSingleResult(); }

@Override

public List<Voyage> findAll() {

return entityManager.createNamedQuery(""Voyage.findAll"", Voyage.class).getResultList();

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/infrastructure/routing/ExternalRoutingService.java

package org.eclipse.cargotracker.infrastructure.routing;

import java.util.ArrayList;

import java.util.List;

import java.util.logging.Level;

import java.util.logging.Logger;

import java.util.stream.Collectors;

import jakarta.annotation.PostConstruct;

import jakarta.annotation.Resource;

import jakarta.ejb.Stateless;

import jakarta.inject.Inject;

import jakarta.ws.rs.client.ClientBuilder;

import jakarta.ws.rs.client.WebTarget;"|data_input/cargotracker/cargotracker.txt|4e02dcd3ebee4c12bac56caa7f7033e9
"import jakarta.ejb.Stateless;

import jakarta.inject.Inject;

import jakarta.ws.rs.client.ClientBuilder;

import jakarta.ws.rs.client.WebTarget;

import jakarta.ws.rs.core.GenericType;

import jakarta.ws.rs.core.MediaType;

import org.eclipse.cargotracker.domain.model.cargo.Itinerary;

import org.eclipse.cargotracker.domain.model.cargo.Leg;

import org.eclipse.cargotracker.domain.model.cargo.RouteSpecification;

import org.eclipse.cargotracker.domain.model.location.LocationRepository;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

import org.eclipse.cargotracker.domain.model.voyage.VoyageRepository;

import org.eclipse.cargotracker.domain.service.RoutingService;

import org.eclipse.pathfinder.api.TransitEdge;

import org.eclipse.pathfinder.api.TransitPath;

/** * Our end of the routing service. This is basically a data model translation layer between our * domain model and the API put forward by the routing team, which operates in a different context * from us. */ @Stateless public class ExternalRoutingService implements RoutingService {

@Inject private Logger logger;

@Resource(lookup = ""java:app/configuration/GraphTraversalUrl"")

private String graphTraversalUrl;

private WebTarget graphTraversalResource;

@Inject private LocationRepository locationRepository;

@Inject private VoyageRepository voyageRepository;"|data_input/cargotracker/cargotracker.txt|da5c5844f7c24b2db1b8a1b38530a981
"@Inject private LocationRepository locationRepository;

@Inject private VoyageRepository voyageRepository;

@PostConstruct public void init() { graphTraversalResource = ClientBuilder.newClient().target(graphTraversalUrl); logger.log( Level.INFO, ""Graph traversal URL to be used for the REST client: {0}"", graphTraversalUrl); }

@Override public List<Itinerary> fetchRoutesForSpecification(RouteSpecification routeSpecification) { // The RouteSpecification is picked apart and adapted to the external API. String origin = routeSpecification.getOrigin().getUnLocode().getIdString(); String destination = routeSpecification.getDestination().getUnLocode().getIdString();

List<TransitPath> transitPaths =

graphTraversalResource

.queryParam(""origin"", origin)

.queryParam(""destination"", destination)

.request(MediaType.APPLICATION_JSON_TYPE)

.get(new GenericType<List<TransitPath>>() {});

// The returned result is then translated back into our domain model. List<Itinerary> itineraries = new ArrayList<>();

// Use the specification to safe-guard against invalid itineraries transitPaths .stream() .map(this::toItinerary) .forEach( itinerary -> { if (routeSpecification.isSatisfiedBy(itinerary)) { itineraries.add(itinerary); } else { logger.log( Level.FINE, ""Received itinerary that did not satisfy the route specification""); } });

return itineraries;

}"|data_input/cargotracker/cargotracker.txt|ebc9156acc15442ea6a4cf6ac57532ae
"return itineraries;

}

private Itinerary toItinerary(TransitPath transitPath) { List<Leg> legs = transitPath.getTransitEdges().stream().map(this::toLeg).collect(Collectors.toList()); return new Itinerary(legs); }

private Leg toLeg(TransitEdge edge) { return new Leg( voyageRepository.find(new VoyageNumber(edge.getVoyageNumber())), locationRepository.find(new UnLocode(edge.getFromUnLocode())), locationRepository.find(new UnLocode(edge.getToUnLocode())), edge.getFromDate(), edge.getToDate()); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/Coordinates.java

package org.eclipse.cargotracker.interfaces;

/** * At the moment, coordinates are effectively a shared DTO in the interface layer. It may be * converted to a domain level concern at some point. * */ public class Coordinates {

private final double latitude;

private final double longitude;

public Coordinates(double latitude, double longitude) { this.latitude = latitude; this.longitude = longitude; }

public double getLatitude() {

return latitude;

}

public double getLongitude() {

return longitude;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/CoordinatesFactory.java

package org.eclipse.cargotracker.interfaces;

import static org.eclipse.cargotracker.domain.model.location.Location.UNKNOWN;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.CHICAGO;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.DALLAS;"|data_input/cargotracker/cargotracker.txt|5b3cd9b094ae48f89b748dc62cea616a
"import static org.eclipse.cargotracker.domain.model.location.SampleLocations.DALLAS;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.GOTHENBURG;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.HAMBURG;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.HANGZOU;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.HELSINKI;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.HONGKONG;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.MELBOURNE;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.NEWYORK;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.ROTTERDAM;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.SHANGHAI;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.STOCKHOLM;

import static org.eclipse.cargotracker.domain.model.location.SampleLocations.TOKYO;

import java.util.Collections;

import java.util.HashMap;

import java.util.Map;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

/** * At the moment, coordinates are produced by a simple factory. It may be converted to a repository * if coordinates become a domain layer concern. */ public class CoordinatesFactory {"|data_input/cargotracker/cargotracker.txt|2cb0fb6798cd4f5190a3597699a74c8a
"private static final Map<String, Coordinates> COORDINATES_MAP;

private CoordinatesFactory() {

/

Prevent instantiation.

/

}

public static Coordinates find(Location location) { return find(location.getUnLocode()); }

public static Coordinates find(UnLocode unLocode) { return find(unLocode.getIdString()); }

public static Coordinates find(String unLocode) { return COORDINATES_MAP.get(unLocode); }

static { Map<String, Coordinates> map = new HashMap<>();"|data_input/cargotracker/cargotracker.txt|cc9675860e3b47fba43955c581caa604
text|source|chunk_id
"public static Coordinates find(String unLocode) { return COORDINATES_MAP.get(unLocode); }

static { Map<String, Coordinates> map = new HashMap<>();

// TODO [Clean Code] See if there is a service to get the latitude/longitude data from. map.put(HONGKONG.getUnLocode().getIdString(), new Coordinates(22, 114)); map.put(MELBOURNE.getUnLocode().getIdString(), new Coordinates(-38, 145)); map.put(STOCKHOLM.getUnLocode().getIdString(), new Coordinates(59, 18)); map.put(HELSINKI.getUnLocode().getIdString(), new Coordinates(60, 25)); map.put(CHICAGO.getUnLocode().getIdString(), new Coordinates(42, -88)); map.put(TOKYO.getUnLocode().getIdString(), new Coordinates(36, 140)); map.put(HAMBURG.getUnLocode().getIdString(), new Coordinates(54, 10)); map.put(SHANGHAI.getUnLocode().getIdString(), new Coordinates(31, 121)); map.put(ROTTERDAM.getUnLocode().getIdString(), new Coordinates(52, 5)); map.put(GOTHENBURG.getUnLocode().getIdString(), new Coordinates(58, 12)); map.put(HANGZOU.getUnLocode().getIdString(), new Coordinates(30, 120)); map.put(NEWYORK.getUnLocode().getIdString(), new Coordinates(41, -74)); map.put(DALLAS.getUnLocode().getIdString(), new Coordinates(33, -97)); map.put(UNKNOWN.getUnLocode().getIdString(), new Coordinates(-90, 0)); // The South Pole.

COORDINATES_MAP = Collections.unmodifiableMap(map);

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/FacesConfiguration.java

package org.eclipse.cargotracker.interfaces;"|data_input/cargotracker/cargotracker.txt|0f3d227cb6b74a6a93e4b37a49da50c8
"}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/FacesConfiguration.java

package org.eclipse.cargotracker.interfaces;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.faces.annotation.FacesConfig;

/*

Jakarta Faces configuration.

/

@FacesConfig()

@ApplicationScoped

public class FacesConfiguration {}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/BookingServiceFacade.java

package org.eclipse.cargotracker.interfaces.booking.facade;

import java.time.LocalDate;

import java.util.List;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoRoute;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoStatus;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.Location;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.RouteCandidate;

/** * This facade shields the domain layer - model, services, repositories - from concerns about such * things as the user interface and remote communication. */ public interface BookingServiceFacade {

String bookNewCargo(String origin, String destination, LocalDate arrivalDeadline);

CargoRoute loadCargoForRouting(String trackingId);

CargoStatus loadCargoForTracking(String trackingId);

void assignCargoToRoute(String trackingId, RouteCandidate route);

void changeDestination(String trackingId, String destinationUnLocode);

void changeDeadline(String trackingId, LocalDate arrivalDeadline);"|data_input/cargotracker/cargotracker.txt|751e04e9787643f986827b4f675b1939
"void changeDestination(String trackingId, String destinationUnLocode);

void changeDeadline(String trackingId, LocalDate arrivalDeadline);

List<RouteCandidate> requestPossibleRoutesForCargo(String trackingId);

List<Location> listShippingLocations();

// TODO [DDD] Is this the right DTO here? List<CargoRoute> listAllCargos();

List<String> listAllTrackingIds();

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/dto/CargoRoute.java

package org.eclipse.cargotracker.interfaces.booking.facade.dto;

import java.io.Serializable;

import java.time.LocalDate;

import java.util.Collections;

import java.util.List;

import org.eclipse.cargotracker.application.util.DateConverter;

/** DTO for registering and routing a cargo. */ public class CargoRoute implements Serializable {

private static final long serialVersionUID = 1L;

private final String trackingId;

private final Location origin;

private final Location finalDestination;

private final String arrivalDeadline;

private final boolean misrouted;

private final List<Leg> legs;

private final boolean claimed;

private final Location lastKnownLocation;

private final String transportStatus;

private String nextLocation;

public CargoRoute(

String trackingId,

Location origin,

Location finalDestination,

LocalDate arrivalDeadline,

boolean misrouted,

boolean claimed,

Location lastKnownLocation,

String transportStatus,

List<Leg> legs) {

this.trackingId = trackingId;

this.origin = origin;"|data_input/cargotracker/cargotracker.txt|7608462d8ac24511b31c802f517b0a8e
"boolean claimed,

Location lastKnownLocation,

String transportStatus,

List<Leg> legs) {

this.trackingId = trackingId;

this.origin = origin;

this.finalDestination = finalDestination;

this.arrivalDeadline = DateConverter.toString(arrivalDeadline);

this.misrouted = misrouted;

this.claimed = claimed;

this.lastKnownLocation = lastKnownLocation;

this.transportStatus = transportStatus;

this.legs = Collections.unmodifiableList(legs);

}

public String getTrackingId() {

return trackingId;

}

public String getOrigin() {

return origin.toString();

}

public String getOriginName() {

return origin.getName();

}

public String getOriginCode() {

return origin.getUnLocode();

}

public String getFinalDestination() {

return finalDestination.toString();

}

public String getFinalDestinationName() {

return finalDestination.getName();

}

public String getFinalDestinationCode() {

return finalDestination.getUnLocode();

}

public List<Leg> getLegs() {

return legs;

}

public boolean isMisrouted() {

return misrouted;

}

public boolean isRouted() {

return !legs.isEmpty();

}

public String getArrivalDeadline() {

return arrivalDeadline;

}

public boolean isClaimed() {

return claimed;

}

public String getLastKnownLocation() {

return lastKnownLocation.toString();

}

public String getLastKnownLocationName() {

return lastKnownLocation.getName();

}

public String getLastKnownLocationCode() {

return lastKnownLocation.getUnLocode();

}"|data_input/cargotracker/cargotracker.txt|bd6029dc35c24892a659ee8aa522878d
"return lastKnownLocation.getName();

}

public String getLastKnownLocationCode() {

return lastKnownLocation.getUnLocode();

}

public String getTransportStatus() { // TODO [Clean Code] This needs to be a richer status, with a more readable description. return this.transportStatus; }

public String getNextLocation() {

return this.nextLocation;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/dto/CargoStatus.java

package org.eclipse.cargotracker.interfaces.booking.facade.dto;

import java.util.ArrayList;

import java.util.Collections;

import java.util.List;

public class CargoStatus {

private final String trackingId;

private final String destination;

private final String statusText;

private final boolean misdirected;

private final String eta;

private final String nextExpectedActivity;

private final List<TrackingEvents> events;

public CargoStatus(

String trackigId,

String destination,

String statusText,

boolean misdirected,

String eta,

String nextExpectedActivity,

List<TrackingEvents> handlingEvents) {

this.trackingId = trackigId;

this.destination = destination;

this.statusText = statusText;

this.misdirected = misdirected;

this.eta = eta;

this.nextExpectedActivity = nextExpectedActivity;

this.events = new ArrayList<>(handlingEvents.size());

events.addAll(handlingEvents);

}

public String getTrackingId() {

return trackingId;

}

public String getDestination() {

return destination;

}"|data_input/cargotracker/cargotracker.txt|bd3e82dc11104490b3aa1a2abacfa503
"events.addAll(handlingEvents);

}

public String getTrackingId() {

return trackingId;

}

public String getDestination() {

return destination;

}

/** @return A readable string describing the cargo status. */ public String getStatusText() { return statusText; }

public boolean isMisdirected() {

return misdirected;

}

public String getEta() {

return eta;

}

public String getNextExpectedActivity() {

return nextExpectedActivity;

}

public List<TrackingEvents> getEvents() {

return Collections.unmodifiableList(events);

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/dto/Leg.java

package org.eclipse.cargotracker.interfaces.booking.facade.dto;

import java.io.Serializable;

import java.time.LocalDateTime;

import org.eclipse.cargotracker.application.util.DateConverter;

/** DTO for a leg in an itinerary. */ public class Leg implements Serializable {

private static final long serialVersionUID = 1L; private final String voyageNumber; private final Location from; private final Location to; private final String loadTime; private final String unloadTime;

public Leg(

String voyageNumber,

Location from,

Location to,

LocalDateTime loadTime,

LocalDateTime unloadTime) {

this.voyageNumber = voyageNumber;

this.from = from;

this.to = to;

this.loadTime = DateConverter.toString(loadTime);

this.unloadTime = DateConverter.toString(unloadTime);

}

public String getVoyageNumber() {

return voyageNumber;

}

public String getFrom() {"|data_input/cargotracker/cargotracker.txt|44b9b9700217458ca4d1d999c3fcb038
"this.unloadTime = DateConverter.toString(unloadTime);

}

public String getVoyageNumber() {

return voyageNumber;

}

public String getFrom() {

return from.toString();

}

public String getFromUnLocode() {

return from.getUnLocode();

}

public String getFromName() {

return from.getName();

}

public String getTo() {

return to.toString();

}

public String getToName() {

return to.getName();

}

public String getToUnLocode() {

return to.getUnLocode();

}

public String getLoadTime() {

return loadTime;

}

public String getUnloadTime() {

return unloadTime;

}

@Override

public String toString() {

return ""Leg{""

+ ""voyageNumber=""

+ voyageNumber

+ "", from=""

+ from.getUnLocode()

+ "", to=""

+ to.getUnLocode()

+ "", loadTime=""

+ loadTime

+ "", unloadTime=""

+ unloadTime

+ '}';

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/dto/Location.java

package org.eclipse.cargotracker.interfaces.booking.facade.dto;

import java.io.Serializable;

/** Location DTO. */ public class Location implements Serializable {

private static final long serialVersionUID = 1L;

private String unLocode;

private String name;

public Location(String unLocode, String name) { this.unLocode = unLocode; this.name = name; }

public String getUnLocode() {

return unLocode;

}

public String getName() {

return name;

}

@Override public String toString() { return name + "" ("" + unLocode + "")""; } }"|data_input/cargotracker/cargotracker.txt|7a60795157fc40e3b10f613c599d3c36
"return unLocode;

}

public String getName() {

return name;

}

@Override public String toString() { return name + "" ("" + unLocode + "")""; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/dto/RouteCandidate.java

package org.eclipse.cargotracker.interfaces.booking.facade.dto;

import java.io.Serializable;

import java.util.Collections;

import java.util.List;

/** DTO for presenting and selecting an itinerary from a collection of candidates. */ public class RouteCandidate implements Serializable {

private static final long serialVersionUID = 1L;

private List<Leg> legs;

public RouteCandidate(List<Leg> legs) {

this.legs = legs;

}

public List<Leg> getLegs() {

return Collections.unmodifiableList(legs);

}

@Override public String toString() { return ""RouteCandidate{"" + ""legs="" + legs + '}'; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/dto/TrackingEvents.java

package org.eclipse.cargotracker.interfaces.booking.facade.dto;

public class TrackingEvents {

private final boolean expected;

private final String description;

private final String time;

public TrackingEvents(boolean expected, String description, String time) { this.expected = expected; this.description = description; this.time = time; }

public boolean isExpected() {

return expected;

}

public String getDescription() {

return description;

}

public String getTime() {

return time;

}

}"|data_input/cargotracker/cargotracker.txt|8173343fb0cb44fe8479ac4f14090642
"return expected;

}

public String getDescription() {

return description;

}

public String getTime() {

return time;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/internal/DefaultBookingServiceFacade.java

package org.eclipse.cargotracker.interfaces.booking.facade.internal;

import java.io.Serializable;

import java.time.LocalDate;

import java.util.ArrayList;

import java.util.List;

import java.util.stream.Collectors;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.inject.Inject;

import org.eclipse.cargotracker.application.BookingService;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.CargoRepository;

import org.eclipse.cargotracker.domain.model.cargo.Itinerary;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.handling.HandlingEventRepository;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.location.LocationRepository;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.VoyageRepository;

import org.eclipse.cargotracker.interfaces.booking.facade.BookingServiceFacade;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoRoute;"|data_input/cargotracker/cargotracker.txt|dde9fa5b414e48a993f25b666b736389
"import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoRoute;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoStatus;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.RouteCandidate;

import org.eclipse.cargotracker.interfaces.booking.facade.internal.assembler.CargoRouteDtoAssembler;

import org.eclipse.cargotracker.interfaces.booking.facade.internal.assembler.CargoStatusDtoAssembler;

import org.eclipse.cargotracker.interfaces.booking.facade.internal.assembler.ItineraryCandidateDtoAssembler;

import org.eclipse.cargotracker.interfaces.booking.facade.internal.assembler.LocationDtoAssembler;

@ApplicationScoped public class DefaultBookingServiceFacade implements BookingServiceFacade, Serializable {

private static final long serialVersionUID = 1L;

@Inject private BookingService bookingService;

@Inject private LocationRepository locationRepository;

@Inject private CargoRepository cargoRepository;

@Inject private VoyageRepository voyageRepository;

@Inject private HandlingEventRepository handlingEventRepository;

@Inject private CargoRouteDtoAssembler cargoRouteDtoAssembler;

@Inject private CargoStatusDtoAssembler cargoStatusDtoAssembler;

@Inject private ItineraryCandidateDtoAssembler itineraryCandidateDtoAssembler;

@Inject private LocationDtoAssembler locationDtoAssembler;

@Override

public List<org.eclipse.cargotracker.interfaces.booking.facade.dto.Location>

listShippingLocations() {"|data_input/cargotracker/cargotracker.txt|b95dd0f3469f4745a995564cb004ae0e
"@Override

public List<org.eclipse.cargotracker.interfaces.booking.facade.dto.Location>

listShippingLocations() {

List<Location> allLocations = locationRepository.findAll();

return locationDtoAssembler.toDtoList(allLocations);

}

@Override public String bookNewCargo(String origin, String destination, LocalDate arrivalDeadline) { TrackingId trackingId = bookingService.bookNewCargo( new UnLocode(origin), new UnLocode(destination), arrivalDeadline); return trackingId.getIdString(); }

@Override public CargoRoute loadCargoForRouting(String trackingId) { Cargo cargo = cargoRepository.find(new TrackingId(trackingId)); return cargoRouteDtoAssembler.toDto(cargo); }

@Override public void assignCargoToRoute(String trackingIdStr, RouteCandidate routeCandidateDTO) { Itinerary itinerary = itineraryCandidateDtoAssembler.fromDTO( routeCandidateDTO, voyageRepository, locationRepository); TrackingId trackingId = new TrackingId(trackingIdStr);

bookingService.assignCargoToRoute(itinerary, trackingId);

}

@Override public void changeDestination(String trackingId, String destinationUnLocode) { bookingService.changeDestination(new TrackingId(trackingId), new UnLocode(destinationUnLocode)); }

@Override public void changeDeadline(String trackingId, LocalDate arrivalDeadline) { bookingService.changeDeadline(new TrackingId(trackingId), arrivalDeadline); }"|data_input/cargotracker/cargotracker.txt|5b34bdbe9ca74ba6b2dc9f16070cc26e
"@Override // TODO [DDD] Is this the correct DTO here? public List<CargoRoute> listAllCargos() { List<Cargo> cargos = cargoRepository.findAll(); List<CargoRoute> routes;

routes = cargos.stream().map(cargoRouteDtoAssembler::toDto).collect(Collectors.toList());

return routes;

}

@Override public List<String> listAllTrackingIds() { List<String> trackingIds = new ArrayList<>(); cargoRepository .findAll() .forEach(cargo -> trackingIds.add(cargo.getTrackingId().getIdString()));

return trackingIds;

}

@Override public CargoStatus loadCargoForTracking(String trackingIdValue) { TrackingId trackingId = new TrackingId(trackingIdValue); Cargo cargo = cargoRepository.find(trackingId);

if (cargo == null) { return null; }

List<HandlingEvent> handlingEvents =

handlingEventRepository

.lookupHandlingHistoryOfCargo(trackingId)

.getDistinctEventsByCompletionTime();

return cargoStatusDtoAssembler.toDto(cargo, handlingEvents);

}

@Override public List<RouteCandidate> requestPossibleRoutesForCargo(String trackingId) { List<Itinerary> itineraries = bookingService.requestPossibleRoutesForCargo(new TrackingId(trackingId));

List<RouteCandidate> routeCandidates =

itineraries

.stream()

.map(itineraryCandidateDtoAssembler::toDto)

.collect(Collectors.toList());

return routeCandidates;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/internal/assembler/CargoRouteDtoAssembler.java"|data_input/cargotracker/cargotracker.txt|def9d6713d1440c7bcab3784ab258bde
"}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/internal/assembler/CargoRouteDtoAssembler.java

package org.eclipse.cargotracker.interfaces.booking.facade.internal.assembler;

import static java.util.stream.Collectors.toList;

import java.util.List;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.inject.Inject;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.RoutingStatus;

import org.eclipse.cargotracker.domain.model.cargo.TransportStatus;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoRoute;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.Leg;

@ApplicationScoped

public class CargoRouteDtoAssembler {

@Inject private LocationDtoAssembler locationDtoAssembler;

public CargoRoute toDto(Cargo cargo) { List<Leg> legs = cargo .getItinerary() .getLegs() .stream() .map( leg -> new Leg( leg.getVoyage().getVoyageNumber().getIdString(), locationDtoAssembler.toDto(leg.getLoadLocation()), locationDtoAssembler.toDto(leg.getUnloadLocation()), leg.getLoadTime(), leg.getUnloadTime())) .collect(toList());

return new CargoRoute(

cargo.getTrackingId().getIdString(),

locationDtoAssembler.toDto(cargo.getOrigin()),

locationDtoAssembler.toDto(cargo.getRouteSpecification().getDestination()),

cargo.getRouteSpecification().getArrivalDeadline(),

cargo.getDelivery().getRoutingStatus().sameValueAs(RoutingStatus.MISROUTED),"|data_input/cargotracker/cargotracker.txt|f37262263ede46c58f8467bc44e15342
"cargo.getRouteSpecification().getArrivalDeadline(),

cargo.getDelivery().getRoutingStatus().sameValueAs(RoutingStatus.MISROUTED),

cargo.getDelivery().getTransportStatus().sameValueAs(TransportStatus.CLAIMED),

locationDtoAssembler.toDto(cargo.getDelivery().getLastKnownLocation()),

cargo.getDelivery().getTransportStatus().name(),

legs);

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/internal/assembler/CargoStatusDtoAssembler.java

package org.eclipse.cargotracker.interfaces.booking.facade.internal.assembler;

import java.time.LocalDateTime;

import java.util.List;

import java.util.stream.Collectors;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.inject.Inject;

import org.eclipse.cargotracker.application.util.DateConverter;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.Delivery;

import org.eclipse.cargotracker.domain.model.cargo.HandlingActivity;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoStatus;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.TrackingEvents;

@ApplicationScoped

public class CargoStatusDtoAssembler {

@Inject private TrackingEventsDtoAssembler assembler;

public CargoStatus toDto(Cargo cargo, List<HandlingEvent> handlingEvents) { List<TrackingEvents> trackingEvents;

trackingEvents =

handlingEvents

.stream()"|data_input/cargotracker/cargotracker.txt|e5d52a97f408438d8baea6d0b402a716
"trackingEvents =

handlingEvents

.stream()

.map(handlingEvent

> assembler.toDto(cargo, handlingEvent))

.collect(Collectors.toList());

return new CargoStatus(

cargo.getTrackingId().getIdString(),

cargo.getRouteSpecification().getDestination().getName(),

getCargoStatusText(cargo),

cargo.getDelivery().isMisdirected(),

getEta(cargo),

getNextExpectedActivity(cargo),

trackingEvents);

}

private String getCargoStatusText(Cargo cargo) { Delivery delivery = cargo.getDelivery();

switch (delivery.getTransportStatus()) { case IN_PORT: return ""In port "" + delivery.getLastKnownLocation().getName(); case ONBOARD_CARRIER: return ""Onboard voyage "" + delivery.getCurrentVoyage().getVoyageNumber().getIdString(); case CLAIMED: return ""Claimed""; case NOT_RECEIVED: return ""Not received""; case UNKNOWN: return ""Unknown""; default: return ""[Unknown status]""; // Should never happen. } }

private String getEta(Cargo cargo) { LocalDateTime eta = cargo.getDelivery().getEstimatedTimeOfArrival();

if (eta == null) { return ""? ""; } else { return DateConverter.toString(eta); } }

private String getNextExpectedActivity(Cargo cargo) { HandlingActivity activity = cargo.getDelivery().getNextExpectedActivity();

if ((activity == null) || (activity.isEmpty())) { return """"; }

String text = ""Next expected activity is to ""; HandlingEvent.Type type = activity.getType();"|data_input/cargotracker/cargotracker.txt|ecdbc89d60a5493da5d5d4179a22fff1
"String text = ""Next expected activity is to ""; HandlingEvent.Type type = activity.getType();

if (type.sameValueAs(HandlingEvent.Type.LOAD)) { return text + type.name().toLowerCase() + "" cargo onto voyage "" + activity.getVoyage().getVoyageNumber() + "" in "" + activity.getLocation().getName(); } else if (type.sameValueAs(HandlingEvent.Type.UNLOAD)) { return text + type.name().toLowerCase() + "" cargo off of "" + activity.getVoyage().getVoyageNumber() + "" in "" + activity.getLocation().getName(); } else { return text + type.name().toLowerCase() + "" cargo in "" + activity.getLocation().getName(); } } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/internal/assembler/ItineraryCandidateDtoAssembler.java

package org.eclipse.cargotracker.interfaces.booking.facade.internal.assembler;

import java.util.ArrayList;

import java.util.List;

import java.util.stream.Collectors;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.inject.Inject;

import org.eclipse.cargotracker.application.util.DateConverter;

import org.eclipse.cargotracker.domain.model.cargo.Itinerary;

import org.eclipse.cargotracker.domain.model.cargo.Leg;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.location.LocationRepository;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.Voyage;"|data_input/cargotracker/cargotracker.txt|16ea41900a374d2b848c286be9222865
"import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.Voyage;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

import org.eclipse.cargotracker.domain.model.voyage.VoyageRepository;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.RouteCandidate;

@ApplicationScoped

public class ItineraryCandidateDtoAssembler {

@Inject private LocationDtoAssembler locationDtoAssembler;

public RouteCandidate toDto(Itinerary itinerary) { List<org.eclipse.cargotracker.interfaces.booking.facade.dto.Leg> legDTOs = itinerary.getLegs().stream().map(this::toLegDTO).collect(Collectors.toList()); return new RouteCandidate(legDTOs); }

protected org.eclipse.cargotracker.interfaces.booking.facade.dto.Leg toLegDTO(Leg leg) { VoyageNumber voyageNumber = leg.getVoyage().getVoyageNumber(); return new org.eclipse.cargotracker.interfaces.booking.facade.dto.Leg( voyageNumber.getIdString(), locationDtoAssembler.toDto(leg.getLoadLocation()), locationDtoAssembler.toDto(leg.getUnloadLocation()), leg.getLoadTime(), leg.getUnloadTime()); }

public Itinerary fromDTO( RouteCandidate routeCandidateDTO, VoyageRepository voyageRepository, LocationRepository locationRepository) { List<Leg> legs = new ArrayList<>(routeCandidateDTO.getLegs().size());"|data_input/cargotracker/cargotracker.txt|624a73c38aa64a2492584b441dbbef8f
"for (org.eclipse.cargotracker.interfaces.booking.facade.dto.Leg legDTO : routeCandidateDTO.getLegs()) { VoyageNumber voyageNumber = new VoyageNumber(legDTO.getVoyageNumber()); Voyage voyage = voyageRepository.find(voyageNumber); Location from = locationRepository.find(new UnLocode(legDTO.getFromUnLocode())); Location to = locationRepository.find(new UnLocode(legDTO.getToUnLocode()));

legs.add(

new Leg(

voyage,

from,

to,

DateConverter.toDateTime(legDTO.getLoadTime()),

DateConverter.toDateTime(legDTO.getUnloadTime())));

}

return new Itinerary(legs);

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/internal/assembler/LocationDtoAssembler.java

package org.eclipse.cargotracker.interfaces.booking.facade.internal.assembler;

import java.util.Comparator;

import java.util.List;

import java.util.stream.Collectors;

import jakarta.enterprise.context.ApplicationScoped;

import org.eclipse.cargotracker.domain.model.location.Location;

@ApplicationScoped

public class LocationDtoAssembler {

public org.eclipse.cargotracker.interfaces.booking.facade.dto.Location toDto(Location location) { return new org.eclipse.cargotracker.interfaces.booking.facade.dto.Location( location.getUnLocode().getIdString(), location.getName()); }

public List<org.eclipse.cargotracker.interfaces.booking.facade.dto.Location> toDtoList(

List<Location> allLocations) {

List<org.eclipse.cargotracker.interfaces.booking.facade.dto.Location> dtoList =

allLocations"|data_input/cargotracker/cargotracker.txt|1bd42180170543c593eba42c50c8fd84
"List<Location> allLocations) {

List<org.eclipse.cargotracker.interfaces.booking.facade.dto.Location> dtoList =

allLocations

.stream()

.map(this::toDto)

.sorted(

Comparator.comparing(

org.eclipse.cargotracker.interfaces.booking.facade.dto.Location::getUnLocode))

.collect(Collectors.toList());

return dtoList;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/facade/internal/assembler/TrackingEventsDtoAssembler.java

package org.eclipse.cargotracker.interfaces.booking.facade.internal.assembler;

import jakarta.enterprise.context.ApplicationScoped;

import org.eclipse.cargotracker.application.util.DateConverter;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.voyage.Voyage;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.TrackingEvents;

@ApplicationScoped

public class TrackingEventsDtoAssembler {

public TrackingEvents toDto(Cargo cargo, HandlingEvent handlingEvent) { String location = locationFrom(handlingEvent); HandlingEvent.Type type = handlingEvent.getType(); String voyageNumber = voyageNumberFrom(handlingEvent); return new TrackingEvents( cargo.getItinerary().isExpected(handlingEvent), descriptionFrom(type, location, voyageNumber), timeFrom(handlingEvent)); }

private String timeFrom(HandlingEvent event) { return DateConverter.toString(event.getCompletionTime()); }"|data_input/cargotracker/cargotracker.txt|f5578e2b51b44ecd99e8278a18adc5ff
"private String timeFrom(HandlingEvent event) { return DateConverter.toString(event.getCompletionTime()); }

private String descriptionFrom(HandlingEvent.Type type, String location, String voyageNumber) { switch (type) { case LOAD: return ""Loaded onto voyage "" + voyageNumber + "" in "" + location; case UNLOAD: return ""Unloaded off voyage "" + voyageNumber + "" in "" + location; case RECEIVE: return ""Received in "" + location; case CLAIM: return ""Claimed in "" + location; case CUSTOMS: return ""Cleared customs in "" + location; default: return ""[Unknown]""; } }

private String voyageNumberFrom(HandlingEvent handlingEvent) { Voyage voyage = handlingEvent.getVoyage(); return voyage.getVoyageNumber().getIdString(); }

private String locationFrom(HandlingEvent handlingEvent) { return handlingEvent.getLocation().getName(); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/sse/LocationViewAdapter.java

package org.eclipse.cargotracker.interfaces.booking.sse;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.interfaces.Coordinates;

import org.eclipse.cargotracker.interfaces.CoordinatesFactory;

/** View adapter for displaying a location in a real-time tracking context. */ public class LocationViewAdapter {

private final Location location;

public LocationViewAdapter(Location location) {

this.location = location;

}

public String getUnLocode() {

return location.getUnLocode().getIdString();

}"|data_input/cargotracker/cargotracker.txt|d22ac4a231c146048932f85346d4e9d0
"this.location = location;

}

public String getUnLocode() {

return location.getUnLocode().getIdString();

}

public String getName() {

return location.getName();

}

public Coordinates getCoordinates() {

return CoordinatesFactory.find(location);

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/sse/RealtimeCargoTrackingService.java

package org.eclipse.cargotracker.interfaces.booking.sse;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.annotation.PostConstruct;

import jakarta.annotation.PreDestroy;

import jakarta.ejb.Singleton;

import jakarta.enterprise.event.ObservesAsync;

import jakarta.inject.Inject;

import jakarta.ws.rs.GET;

import jakarta.ws.rs.Path;

import jakarta.ws.rs.Produces;

import jakarta.ws.rs.core.Context;

import jakarta.ws.rs.core.MediaType;

import jakarta.ws.rs.sse.OutboundSseEvent;

import jakarta.ws.rs.sse.Sse;

import jakarta.ws.rs.sse.SseBroadcaster;

import jakarta.ws.rs.sse.SseEventSink;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.CargoRepository;

import org.eclipse.cargotracker.infrastructure.events.cdi.CargoUpdated;

/** Sever-sent events service for tracking all cargo in real time. */ @Singleton @Path(""/cargo"") public class RealtimeCargoTrackingService { @Inject private Logger logger;

@Inject private CargoRepository cargoRepository;

@Context private Sse sse;

private SseBroadcaster broadcaster;"|data_input/cargotracker/cargotracker.txt|02162fd1d0df4fed81035f4d68920bab
"@Inject private CargoRepository cargoRepository;

@Context private Sse sse;

private SseBroadcaster broadcaster;

@PostConstruct

public void init() {

broadcaster = sse.newBroadcaster();

logger.log(Level.FINEST, ""SSE broadcaster created. "");

}

@GET @Produces(MediaType.SERVER_SENT_EVENTS) public void tracking(@Context SseEventSink eventSink) { cargoRepository.findAll().stream().map(this::cargoToSseEvent).forEach(eventSink::send);

broadcaster.register(eventSink); logger.log(Level.FINEST, ""SSE event sink registered. ""); }

@PreDestroy

public void close() {

broadcaster.close();

logger.log(Level.FINEST, ""SSE broadcaster closed. "");

}

public void onCargoUpdated(@ObservesAsync @CargoUpdated Cargo cargo) { logger.log(Level.FINEST, ""SSE event broadcast for cargo: {0}"", cargo); broadcaster.broadcast(cargoToSseEvent(cargo)); }

private OutboundSseEvent cargoToSseEvent(Cargo cargo) { return sse.newEventBuilder() .mediaType(MediaType.APPLICATION_JSON_TYPE) .data(new RealtimeCargoTrackingViewAdapter(cargo)) .build(); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/sse/RealtimeCargoTrackingViewAdapter.java

package org.eclipse.cargotracker.interfaces.booking.sse;

import java.util.EnumMap;

import java.util.Map;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.RoutingStatus;

import org.eclipse.cargotracker.domain.model.cargo.TransportStatus;"|data_input/cargotracker/cargotracker.txt|a520ddcd082b441583a30944d0121c64
"import org.eclipse.cargotracker.domain.model.cargo.RoutingStatus;

import org.eclipse.cargotracker.domain.model.cargo.TransportStatus;

/** View adapter for displaying a cargo in a realtime tracking context. */ public class RealtimeCargoTrackingViewAdapter {

private static final Map<RoutingStatus, String> routingStatusLabels = new EnumMap<>(RoutingStatus.class); private static final Map<TransportStatus, String> transportStatusLabels = new EnumMap<>(TransportStatus.class);

private final Cargo cargo;

public RealtimeCargoTrackingViewAdapter(Cargo cargo) {

this.cargo = cargo;

}

public String getTrackingId() {

return cargo.getTrackingId().getIdString();

}

public String getRoutingStatus() {

return routingStatusLabels.get(cargo.getDelivery().getRoutingStatus());

}

public boolean isMisdirected() {

return cargo.getDelivery().isMisdirected();

}

public String getTransportStatus() {

return transportStatusLabels.get(cargo.getDelivery().getTransportStatus());

}

public boolean isAtDestination() {

return cargo.getDelivery().isUnloadedAtDestination();

}

public LocationViewAdapter getOrigin() {

return new LocationViewAdapter(cargo.getOrigin());

}

public LocationViewAdapter getLastKnownLocation() {

return new LocationViewAdapter(cargo.getDelivery().getLastKnownLocation());

}

public LocationViewAdapter getLocation() {

return cargo.getDelivery().getTransportStatus() == TransportStatus.NOT_RECEIVED

? getOrigin()

: getLastKnownLocation();

}"|data_input/cargotracker/cargotracker.txt|6543dab57dcb4c0fba073d34c512d35e
"return cargo.getDelivery().getTransportStatus() == TransportStatus.NOT_RECEIVED

? getOrigin()

: getLastKnownLocation();

}

public String getStatusCode() {

RoutingStatus routingStatus = cargo.getDelivery().getRoutingStatus();

if (routingStatus == RoutingStatus.NOT_ROUTED || routingStatus == RoutingStatus.MISROUTED) { return routingStatus.toString(); }

if (cargo.getDelivery().isMisdirected()) {

return ""MISDIRECTED"";

}

if (cargo.getDelivery().isUnloadedAtDestination()) {

return ""AT_DESTINATION"";

}

return cargo.getDelivery().getTransportStatus().toString();

}

static {

routingStatusLabels.put(RoutingStatus.NOT_ROUTED, ""Not routed"");

routingStatusLabels.put(RoutingStatus.ROUTED, ""Routed"");

routingStatusLabels.put(RoutingStatus.MISROUTED, ""Misrouted"");

transportStatusLabels.put(TransportStatus.NOT_RECEIVED, ""Not received"");

transportStatusLabels.put(TransportStatus.IN_PORT, ""In port"");

transportStatusLabels.put(TransportStatus.ONBOARD_CARRIER, ""Onboard carrier"");

transportStatusLabels.put(TransportStatus.CLAIMED, ""Claimed"");

transportStatusLabels.put(TransportStatus.UNKNOWN, ""Unknown"");

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/web/Booking.java

package org.eclipse.cargotracker.interfaces.booking.web;

import java.io.Serializable;

import java.time.LocalDate;

import java.time.temporal.ChronoUnit;

import java.util.ArrayList;

import java.util.List;

import jakarta.annotation.PostConstruct;"|data_input/cargotracker/cargotracker.txt|c7a88cc9d9a54f7389ddece9b0076515
"import java.time.temporal.ChronoUnit;

import java.util.ArrayList;

import java.util.List;

import jakarta.annotation.PostConstruct;

import jakarta.faces.application.FacesMessage;

import jakarta.faces.context.FacesContext;

import jakarta.faces.flow.FlowScoped;

import jakarta.inject.Inject;

import jakarta.inject.Named;

import org.eclipse.cargotracker.interfaces.booking.facade.BookingServiceFacade;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.Location;

import org.primefaces.PrimeFaces;

/** * Handles booking cargo. Operates against a dedicated service facade, and could easily be rewritten * as a thick client. Completely separated from the domain layer, unlike the tracking user * interface. * * <p>In order to successfully keep the domain model shielded from user interface considerations, * this approach is generally preferred to the one taken in the tracking controller. However, there * is never any one perfect solution for all situations, so we've chosen to demonstrate two * polarized ways to build user interfaces. */ @Named @FlowScoped(""booking"") public class Booking implements Serializable {

private static final long serialVersionUID = 1L;

private static final long MIN_JOURNEY_DURATION = 1; // Journey should be 1 day minimum.

@Inject private BookingServiceFacade bookingServiceFacade;

@Inject private FacesContext context;

private LocalDate today = null; private List<Location> locations;

private String originUnlocode;

private String originName;"|data_input/cargotracker/cargotracker.txt|8a1ee861b3714335acea2ad277901a69
"private LocalDate today = null; private List<Location> locations;

private String originUnlocode;

private String originName;

private String destinationName;

private String destinationUnlocode;

private LocalDate arrivalDeadline;

private boolean bookable = false; private long duration = -1;

@PostConstruct

public void init() {

today = LocalDate.now();

locations = bookingServiceFacade.listShippingLocations();

}

public List<Location> getLocations() { List<Location> filteredLocations = new ArrayList<>(); String locationToRemove = null;

if (context.getViewRoot().getViewId().endsWith(""destination.xhtml"")) { // In the destination menu, origin can't be selected. locationToRemove = originUnlocode; } else { // Vice-versa. if (destinationUnlocode != null) { locationToRemove = destinationUnlocode; } }

for (Location location : locations) { if (!location.getUnLocode().equalsIgnoreCase(locationToRemove)) { filteredLocations.add(location); } }

return filteredLocations;

}

public String getOriginUnlocode() {

return originUnlocode;

}

public void setOriginUnlocode(String originUnlocode) { this.originUnlocode = originUnlocode; this.originName = locations .stream() .filter(location -> location.getUnLocode().equalsIgnoreCase(originUnlocode)) .findAny() .get() .getName(); }

public String getOriginName() {

return originName;

}

public String getDestinationUnlocode() {

return destinationUnlocode;

}"|data_input/cargotracker/cargotracker.txt|c1abc913bb004b0592fe363517202e16
"public String getOriginName() {

return originName;

}

public String getDestinationUnlocode() {

return destinationUnlocode;

}

public void setDestinationUnlocode(String destinationUnlocode) { this.destinationUnlocode = destinationUnlocode; this.destinationName = locations .stream() .filter(location -> location.getUnLocode().equalsIgnoreCase(destinationUnlocode)) .findAny() .get() .getName(); }

public String getDestinationName() {

return destinationName;

}

public LocalDate getToday() {

return today;

}

public LocalDate getArrivalDeadline() {

return arrivalDeadline;

}

public void setArrivalDeadline(LocalDate arrivalDeadline) { this.arrivalDeadline = arrivalDeadline; }

public long getDuration() {

return duration;

}

public boolean isBookable() {

return bookable;

}

public void deadlineUpdated() {

duration = ChronoUnit.DAYS.between(today, arrivalDeadline);

if (duration >= MIN_JOURNEY_DURATION) { bookable = true; } else { bookable = false; }

PrimeFaces.current().ajax().update(""dateForm:durationPanel"");

PrimeFaces.current().ajax().update(""dateForm:bookBtn"");

}"|data_input/cargotracker/cargotracker.txt|c24e971a53594063b12a472a2ef58f45
"PrimeFaces.current().ajax().update(""dateForm:durationPanel"");

PrimeFaces.current().ajax().update(""dateForm:bookBtn"");

}

public String register() { if (!originUnlocode.equals(destinationUnlocode)) { bookingServiceFacade.bookNewCargo(originUnlocode, destinationUnlocode, arrivalDeadline); } else { // UI now prevents from selecting same origin/destination FacesMessage message = new FacesMessage(""Origin and destination cannot be the same. ""); message.setSeverity(FacesMessage.SEVERITY_ERROR); context.addMessage(null, message); return null; }

return ""/admin/dashboard.xhtml"";

}

public String getReturnValue() {

return ""/admin/dashboard.xhtml"";

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/web/CargoDetails.java

package org.eclipse.cargotracker.interfaces.booking.web;

import jakarta.enterprise.context.RequestScoped;

import jakarta.inject.Inject;

import jakarta.inject.Named;

import org.eclipse.cargotracker.interfaces.booking.facade.BookingServiceFacade;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoRoute;"|data_input/cargotracker/cargotracker.txt|c237fc5eb0924fe2b1af92da5b46080c
"import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoRoute;

/** * Handles viewing cargo details. Operates against a dedicated service facade, and could easily be * rewritten as a thick Swing client. Completely separated from the domain layer, unlike the * tracking user interface. * * <p>In order to successfully keep the domain model shielded from user interface considerations, * this approach is generally preferred to the one taken in the tracking controller. However, there * is never any one perfect solution for all situations, so we've chosen to demonstrate two * polarized ways to build user interfaces. */ @Named @RequestScoped public class CargoDetails {

@Inject private BookingServiceFacade bookingServiceFacade;

private String trackingId;

private CargoRoute cargo;

public String getTrackingId() {

return trackingId;

}

public void setTrackingId(String trackingId) { this.trackingId = trackingId; }

public CargoRoute getCargo() {

return cargo;

}

public void load() {

cargo = bookingServiceFacade.loadCargoForRouting(trackingId);

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/web/ChangeArrivalDeadline.java

package org.eclipse.cargotracker.interfaces.booking.web;

import java.io.Serializable;

import java.time.LocalDate;

import jakarta.faces.view.ViewScoped;

import jakarta.inject.Inject;

import jakarta.inject.Named;

import org.eclipse.cargotracker.application.util.DateConverter;"|data_input/cargotracker/cargotracker.txt|155ae6c5ba28496a97fd95207b7ac990
"import jakarta.inject.Inject;

import jakarta.inject.Named;

import org.eclipse.cargotracker.application.util.DateConverter;

import org.eclipse.cargotracker.interfaces.booking.facade.BookingServiceFacade;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoRoute;

import org.primefaces.PrimeFaces;

/** * Handles changing the cargo destination. Operates against a dedicated service facade, and could * easily be rewritten as a thick Swing client. Completely separated from the domain layer, unlike * the tracking user interface. * * <p>In order to successfully keep the domain model shielded from user interface considerations, * this approach is generally preferred to the one taken in the tracking controller. However, there * is never any one perfect solution for all situations, so we've chosen to demonstrate two * polarized ways to build user interfaces. */ @Named @ViewScoped public class ChangeArrivalDeadline implements Serializable {

private static final long serialVersionUID = 1L;

@Inject private BookingServiceFacade bookingServiceFacade;

private String trackingId;

private CargoRoute cargo;

private LocalDate arrivalDeadline;

public String getTrackingId() {

return trackingId;

}

public void setTrackingId(String trackingId) { this.trackingId = trackingId; }

public CargoRoute getCargo() {

return cargo;

}

public LocalDate getArrivalDeadline() {

return arrivalDeadline;

}"|data_input/cargotracker/cargotracker.txt|ae40e996b0424e2a92c3d6cbc355efb5
"public CargoRoute getCargo() {

return cargo;

}

public LocalDate getArrivalDeadline() {

return arrivalDeadline;

}

public void setArrivalDeadline(LocalDate arrivalDeadline) { this.arrivalDeadline = arrivalDeadline; }

public void load() {

cargo = bookingServiceFacade.loadCargoForRouting(trackingId);

arrivalDeadline = DateConverter.toDate(cargo.getArrivalDeadline());

}

public void changeArrivalDeadline() {

bookingServiceFacade.changeDeadline(trackingId, arrivalDeadline);

PrimeFaces.current().dialog().closeDynamic(""DONE"");

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/web/ChangeArrivalDeadlineDialog.java

package org.eclipse.cargotracker.interfaces.booking.web;

import java.io.Serializable;

import java.util.ArrayList;

import java.util.HashMap;

import java.util.List;

import java.util.Map;

import jakarta.enterprise.context.SessionScoped;

import jakarta.inject.Named;

import org.primefaces.PrimeFaces;

import org.primefaces.event.SelectEvent;

@Named @SessionScoped public class ChangeArrivalDeadlineDialog implements Serializable {

private static final long serialVersionUID = 1L;

public void showDialog(String trackingId) { Map<String, Object> options = new HashMap<>(); options.put(""modal"", true); options.put(""draggable"", true); options.put(""resizable"", false); options.put(""contentWidth"", 460); options.put(""contentHeight"", 440);"|data_input/cargotracker/cargotracker.txt|c26aae02e96146f4887b9bdae5da5acf
"Map<String, List<String>> params = new HashMap<>(); List<String> values = new ArrayList<>(); values.add(trackingId); params.put(""trackingId"", values);

PrimeFaces.current()

.dialog()

.openDynamic(""/admin/dialogs/change_arrival_deadline.xhtml"", options, params);

}

public void handleReturn(@SuppressWarnings(""rawtypes"") SelectEvent event) {}

public void cancel() { // just kill the dialog PrimeFaces.current().dialog().closeDynamic(""""); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/web/ChangeDestination.java

package org.eclipse.cargotracker.interfaces.booking.web;

import java.io.Serializable;

import java.util.List;

import java.util.stream.Collectors;

import jakarta.faces.view.ViewScoped;

import jakarta.inject.Inject;

import jakarta.inject.Named;

import org.eclipse.cargotracker.interfaces.booking.facade.BookingServiceFacade;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoRoute;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.Location;

import org.primefaces.PrimeFaces;"|data_input/cargotracker/cargotracker.txt|4beed355e31048b5b6ed2b94ffb5cd12
text|source|chunk_id
"import org.eclipse.cargotracker.interfaces.booking.facade.dto.Location;

import org.primefaces.PrimeFaces;

/** * Handles changing the cargo destination. Operates against a dedicated service facade, and could * easily be rewritten as a thick Swing client. Completely separated from the domain layer, unlike * the tracking user interface. * * <p>In order to successfully keep the domain model shielded from user interface considerations, * this approach is generally preferred to the one taken in the tracking controller. However, there * is never any one perfect solution for all situations, so we've chosen to demonstrate two * polarized ways to build user interfaces. */ @Named @ViewScoped public class ChangeDestination implements Serializable {

private static final long serialVersionUID = 1L;

@Inject private BookingServiceFacade bookingServiceFacade;

private String trackingId;

private CargoRoute cargo;

private List<Location> locations;

private String destinationUnlocode;

public String getTrackingId() {

return trackingId;

}

public void setTrackingId(String trackingId) { this.trackingId = trackingId; }

public CargoRoute getCargo() {

return cargo;

}

public List<Location> getLocations() {

return locations;

}"|data_input/cargotracker/cargotracker.txt|c9aedafd50b6428fb247584a37123e40
"public CargoRoute getCargo() {

return cargo;

}

public List<Location> getLocations() {

return locations;

}

public List<Location> getPotentialDestinations() { // Potential destination = All Locations - Origin - Current Destination List<Location> destinationsToRemove = locations .stream() .filter( location -> location.getUnLocode().equalsIgnoreCase(cargo.getOriginCode()) || location.getUnLocode().equalsIgnoreCase(cargo.getFinalDestinationCode())) .collect(Collectors.toList());

locations.removeAll(destinationsToRemove);

return locations;

}

public String getDestinationUnlocode() {

return destinationUnlocode;

}

public void setDestinationUnlocode(String destinationUnlocode) { this.destinationUnlocode = destinationUnlocode; }

public void load() {

locations = bookingServiceFacade.listShippingLocations();

cargo = bookingServiceFacade.loadCargoForRouting(trackingId);

}

public void changeDestination() {

bookingServiceFacade.changeDestination(trackingId, destinationUnlocode);

// PF.current().dialog().closeDynamic(""DONE"");

PrimeFaces.current().dialog().closeDynamic(""DONE"");

// RequestContext.getCurrentInstance().closeDialog(""DONE"");

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/web/ChangeDestinationDialog.java

package org.eclipse.cargotracker.interfaces.booking.web;

import java.io.Serializable;

import java.util.ArrayList;

import java.util.HashMap;

import java.util.List;

import java.util.Map;"|data_input/cargotracker/cargotracker.txt|e5db5dd4d47b4cbda84d6f1bcd36b469
"import java.io.Serializable;

import java.util.ArrayList;

import java.util.HashMap;

import java.util.List;

import java.util.Map;

import jakarta.enterprise.context.SessionScoped;

import jakarta.inject.Named;

import org.primefaces.PrimeFaces;

import org.primefaces.event.SelectEvent;

@Named @SessionScoped public class ChangeDestinationDialog implements Serializable {

private static final long serialVersionUID = 1L;

public void showDialog(String trackingId) { Map<String, Object> options = new HashMap<>(); options.put(""modal"", true); options.put(""draggable"", true); options.put(""resizable"", false); options.put(""contentWidth"", 410); options.put(""contentHeight"", 280);

Map<String, List<String>> params = new HashMap<>(); List<String> values = new ArrayList<>(); values.add(trackingId); params.put(""trackingId"", values);

PrimeFaces.current()

.dialog()

.openDynamic(""/admin/dialogs/change_destination.xhtml"", options, params);

}

public void handleReturn(@SuppressWarnings(""rawtypes"") SelectEvent event) {}

public void cancel() { // just kill the dialog PrimeFaces.current().dialog().closeDynamic(""""); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/web/ItinerarySelection.java

package org.eclipse.cargotracker.interfaces.booking.web;

import java.io.Serializable;

import java.util.List;

import jakarta.faces.view.ViewScoped;

import jakarta.inject.Inject;

import jakarta.inject.Named;"|data_input/cargotracker/cargotracker.txt|80234bada13b428cb726d6d2647f1701
"import java.util.List;

import jakarta.faces.view.ViewScoped;

import jakarta.inject.Inject;

import jakarta.inject.Named;

import org.eclipse.cargotracker.interfaces.booking.facade.BookingServiceFacade;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoRoute;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.RouteCandidate;

/** * Handles itinerary selection. Operates against a dedicated service facade, and could easily be * rewritten as a thick Swing client. Completely separated from the domain layer, unlike the * tracking user interface. * * <p>In order to successfully keep the domain model shielded from user interface considerations, * this approach is generally preferred to the one taken in the tracking controller. However, there * is never any one perfect solution for all situations, so we've chosen to demonstrate two * polarized ways to build user interfaces. */ @Named @ViewScoped public class ItinerarySelection implements Serializable {

private static final long serialVersionUID = 1L;

@Inject private BookingServiceFacade bookingServiceFacade;

List<RouteCandidate> routeCandidates;

private String trackingId;

private CargoRoute cargo;

public List<RouteCandidate> getRouteCandidates() {

return routeCandidates;

}

public String getTrackingId() {

return trackingId;

}

public void setTrackingId(String trackingId) { this.trackingId = trackingId; }

public CargoRoute getCargo() {

return cargo;

}"|data_input/cargotracker/cargotracker.txt|2ef7dd816f8040a0a9ff30dc322b8ee4
"}

public void setTrackingId(String trackingId) { this.trackingId = trackingId; }

public CargoRoute getCargo() {

return cargo;

}

public List<RouteCandidate> getRouteCanditates() {

return routeCandidates;

}

public void load() {

cargo = bookingServiceFacade.loadCargoForRouting(trackingId);

routeCandidates = bookingServiceFacade.requestPossibleRoutesForCargo(trackingId);

}

public String assignItinerary(int routeIndex) { RouteCandidate route = routeCandidates.get(routeIndex); bookingServiceFacade.assignCargoToRoute(trackingId, route);

return ""show.html?faces

redirect=true&trackingId="" + trackingId;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/web/ListCargo.java

package org.eclipse.cargotracker.interfaces.booking.web;

import static java.util.stream.Collectors.toList;

import java.util.List;

import jakarta.annotation.PostConstruct;

import jakarta.enterprise.context.RequestScoped;

import jakarta.inject.Inject;

import jakarta.inject.Named;

import org.eclipse.cargotracker.interfaces.booking.facade.BookingServiceFacade;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoRoute;"|data_input/cargotracker/cargotracker.txt|84453c391dcf4dc2810c7a9a60a7d2a6
"import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoRoute;

/** * Handles listing cargo. Operates against a dedicated service facade, and could easily be rewritten * as a thick client. Completely separated from the domain layer, unlike the tracking user * interface. * * <p>In order to successfully keep the domain model shielded from user interface considerations, * this approach is generally preferred to the one taken in the tracking controller. However, there * is never any one perfect solution for all situations, so we've chosen to demonstrate two * polarized ways to build user interfaces. */ @Named @RequestScoped public class ListCargo {

@Inject private BookingServiceFacade bookingServiceFacade;

private List<CargoRoute> notRoutedCargos;

private List<CargoRoute> routedUnclaimedCargos;

private List<CargoRoute> claimedCargos;

@PostConstruct

public void init() {

List<CargoRoute> cargos = bookingServiceFacade.listAllCargos();

notRoutedCargos = cargos.stream().filter(route

> !route.isRouted()).collect(toList());

routedUnclaimedCargos =

cargos.stream().filter(route

> route.isRouted() && !route.isClaimed()).collect(toList());

claimedCargos = cargos.stream().filter(CargoRoute::isClaimed).collect(toList());

}

public List<CargoRoute> getNotRoutedCargos() {

return notRoutedCargos;

}

public List<CargoRoute> getRoutedUnclaimedCargos() {

return routedUnclaimedCargos;

}

public List<CargoRoute> getClaimedCargos() {

return claimedCargos;

}

}"|data_input/cargotracker/cargotracker.txt|d6ddaed961b84011a9e1a7c898718d34
"return routedUnclaimedCargos;

}

public List<CargoRoute> getClaimedCargos() {

return claimedCargos;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/booking/web/Track.java

package org.eclipse.cargotracker.interfaces.booking.web;

import java.io.Serializable;

import java.util.List;

import jakarta.annotation.PostConstruct;

import jakarta.faces.view.ViewScoped;

import jakarta.inject.Inject;

import jakarta.inject.Named;

import org.eclipse.cargotracker.interfaces.booking.facade.BookingServiceFacade;

import org.eclipse.cargotracker.interfaces.booking.facade.dto.CargoStatus;

/** * Handles tracking cargo. Operates against a dedicated service facade, and could easily be * rewritten as a thick Swing client. Completely separated from the domain layer, unlike the public * tracking user interface. * * <p>In order to successfully keep the domain model shielded from user interface considerations, * this approach is generally preferred to the one taken in the public tracking controller. However, * there is never any one perfect solution for all situations, so we've chosen to demonstrate two * polarized ways to build user interfaces. */ @Named(""admin.track"") @ViewScoped public class Track implements Serializable {

private static final long serialVersionUID = 1L;

@Inject private BookingServiceFacade bookingServiceFacade;

private List<String> trackingIds;

private String trackingId;

private CargoStatus cargo;"|data_input/cargotracker/cargotracker.txt|d046f001e9e34d2a9e14fb5f149fe062
"private List<String> trackingIds;

private String trackingId;

private CargoStatus cargo;

public List<String> getTrackingIds(String query) { return trackingIds; }

public String getTrackingId() {

return trackingId;

}

public void setTrackingId(String trackingId) { this.trackingId = trackingId; }

public CargoStatus getCargo() {

return this.cargo;

}

@PostConstruct

public void init() {

trackingIds = bookingServiceFacade.listAllTrackingIds();

}

public void onTrackById() {

cargo = bookingServiceFacade.loadCargoForTracking(this.trackingId);

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/HandlingEventRegistrationAttempt.java

package org.eclipse.cargotracker.interfaces.handling;

import java.io.Serializable;

import java.time.LocalDateTime;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

/** * This is a simple transfer object for passing incoming handling event registration attempts to the * proper registration procedure. * * <p>It is used as a message queue element. */ public class HandlingEventRegistrationAttempt implements Serializable {

private static final long serialVersionUID = 1L;

private final LocalDateTime registrationTime;

private final LocalDateTime completionTime;

private final TrackingId trackingId;"|data_input/cargotracker/cargotracker.txt|a0f5a29ade9541a49bc0afcc214ed458
"private final LocalDateTime registrationTime;

private final LocalDateTime completionTime;

private final TrackingId trackingId;

private final VoyageNumber voyageNumber;

private final HandlingEvent.Type type;

private final UnLocode unLocode;

public HandlingEventRegistrationAttempt(

LocalDateTime registrationDate,

LocalDateTime completionDate,

TrackingId trackingId,

VoyageNumber voyageNumber,

HandlingEvent.Type type,

UnLocode unLocode) {

this.registrationTime = registrationDate;

this.completionTime = completionDate;

this.trackingId = trackingId;

this.voyageNumber = voyageNumber;

this.type = type;

this.unLocode = unLocode;

}

public TrackingId getTrackingId() {

return trackingId;

}

public VoyageNumber getVoyageNumber() {

return voyageNumber;

}

public HandlingEvent.Type getType() {

return type;

}

public UnLocode getUnLocode() {

return unLocode;

}

public LocalDateTime getRegistrationTime() {

return registrationTime;

}

public LocalDateTime getCompletionTime() {

return completionTime;

}

@Override

public String toString() {

return ""HandlingEventRegistrationAttempt{""

+ ""registrationTime=""

+ registrationTime

+ "", completionTime=""

+ completionTime

+ "", trackingId=""

+ trackingId

+ "", voyageNumber=""

+ voyageNumber

+ "", type=""

+ type

+ "", unLocode=""

+ unLocode

+ '}';

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/file/EventFilesCheckpoint.java

package org.eclipse.cargotracker.interfaces.handling.file;"|data_input/cargotracker/cargotracker.txt|b21bfd07486d499c91c89ab3a563c563
"package org.eclipse.cargotracker.interfaces.handling.file;

import java.io.File;

import java.io.Serializable;

import java.util.LinkedList;

import java.util.List;

public class EventFilesCheckpoint implements Serializable {

private static final long serialVersionUID = 1L;

private List<File> files = new LinkedList<>(); private int fileIndex = 0; private long filePointer = 0;

public void setFiles(List<File> files) { this.files = files; }

public long getFilePointer() {

return filePointer;

}

public void setFilePointer(long filePointer) { this.filePointer = filePointer; }

public File currentFile() { if (files.size() > fileIndex) { return files.get(fileIndex); } else { return null; } }

public File nextFile() {

filePointer = 0;

if (files.size() > ++fileIndex) { return files.get(fileIndex); } else { return null; } } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/file/EventItemReader.java

package org.eclipse.cargotracker.interfaces.handling.file;

import java.io.File;

import java.io.RandomAccessFile;

import java.io.Serializable;

import java.time.LocalDateTime;

import java.time.format.DateTimeParseException;

import java.util.Arrays;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.batch.api.chunk.AbstractItemReader;

import jakarta.batch.runtime.context.JobContext;

import jakarta.enterprise.context.Dependent;

import jakarta.inject.Inject;

import jakarta.inject.Named;"|data_input/cargotracker/cargotracker.txt|fc5e9a5f27734c47b15e81efe0185993
"import jakarta.enterprise.context.Dependent;

import jakarta.inject.Inject;

import jakarta.inject.Named;

import org.eclipse.cargotracker.application.util.DateConverter;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

import org.eclipse.cargotracker.interfaces.handling.HandlingEventRegistrationAttempt;

@Dependent @Named(""EventItemReader"") public class EventItemReader extends AbstractItemReader {

private static final String UPLOAD_DIRECTORY = ""upload_directory"";

@Inject private Logger logger;

@Inject private JobContext jobContext;

private EventFilesCheckpoint checkpoint;

private RandomAccessFile currentFile;

@Override public void open(Serializable checkpoint) throws Exception { File uploadDirectory = new File(jobContext.getProperties().getProperty(UPLOAD_DIRECTORY));

if (checkpoint == null) { this.checkpoint = new EventFilesCheckpoint(); logger.log(Level.INFO, ""Scanning upload directory: {0}"", uploadDirectory);

if (!uploadDirectory.exists()) { logger.log(Level.INFO, ""Upload directory does not exist, creating it""); uploadDirectory.mkdirs(); } else { this.checkpoint.setFiles(Arrays.asList(uploadDirectory.listFiles())); } } else { logger.log(Level.INFO, ""Starting from previous checkpoint""); this.checkpoint = (EventFilesCheckpoint) checkpoint; }"|data_input/cargotracker/cargotracker.txt|62d3d8f750ed49d4acd5e2b7fbd03ce6
"File file = this.checkpoint.currentFile();

if (file == null) { logger.log(Level.INFO, ""No files to process""); currentFile = null; } else { currentFile = new RandomAccessFile(file, ""r""); logger.log(Level.INFO, ""Processing file: {0}"", file); currentFile.seek(this.checkpoint.getFilePointer()); } }

@Override public Object readItem() throws Exception { if (currentFile != null) { String line = currentFile.readLine();

if (line != null) { this.checkpoint.setFilePointer(currentFile.getFilePointer()); return parseLine(line); } else { logger.log( Level.INFO, ""Finished processing file, deleting: {0}"", this.checkpoint.currentFile()); currentFile.close(); this.checkpoint.currentFile().delete(); File nextFile = this.checkpoint.nextFile();

if (nextFile == null) { logger.log(Level.INFO, ""No more files to process""); return null; } else { currentFile = new RandomAccessFile(nextFile, ""r""); logger.log(Level.INFO, ""Processing file: {0}"", nextFile); return readItem(); } } } else { return null; } }

private Object parseLine(String line) throws EventLineParseException { String[] result = line.split("","");

if (result.length != 5) { throw new EventLineParseException(""Wrong number of data elements"", line); }

LocalDateTime completionTime = null;

try { completionTime = DateConverter.toDateTime(result[0]); } catch (DateTimeParseException e) { throw new EventLineParseException(""Cannot parse completion time"", e, line); }

TrackingId trackingId = null;"|data_input/cargotracker/cargotracker.txt|52e64cb2c66b4176a331e39acfc059f8
"TrackingId trackingId = null;

try { trackingId = new TrackingId(result[1]); } catch (NullPointerException e) { throw new EventLineParseException(""Cannot parse tracking ID"", e, line); }

VoyageNumber voyageNumber = null;

try { if (!result[2].isEmpty()) { voyageNumber = new VoyageNumber(result[2]); } } catch (NullPointerException e) { throw new EventLineParseException(""Cannot parse voyage number"", e, line); }

UnLocode unLocode = null;

try { unLocode = new UnLocode(result[3]); } catch (IllegalArgumentException | NullPointerException e) { throw new EventLineParseException(""Cannot parse UN location code"", e, line); }

HandlingEvent.Type eventType = null;

try { eventType = HandlingEvent.Type.valueOf(result[4]); } catch (IllegalArgumentException | NullPointerException e) { throw new EventLineParseException(""Cannot parse event type"", e, line); }

HandlingEventRegistrationAttempt attempt = new HandlingEventRegistrationAttempt( LocalDateTime.now(), completionTime, trackingId, voyageNumber, eventType, unLocode);

return attempt;

}

@Override public Serializable checkpointInfo() throws Exception { return this.checkpoint; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/file/EventItemWriter.java

package org.eclipse.cargotracker.interfaces.handling.file;

import java.io.BufferedWriter;

import java.io.File;

import java.io.FileWriter;

import java.io.PrintWriter;

import java.io.Serializable;

import java.util.List;"|data_input/cargotracker/cargotracker.txt|8d8223ac3729498daf2af8a2b1a8dd98
"import java.io.File;

import java.io.FileWriter;

import java.io.PrintWriter;

import java.io.Serializable;

import java.util.List;

import jakarta.batch.api.chunk.AbstractItemWriter;

import jakarta.batch.runtime.context.JobContext;

import jakarta.enterprise.context.Dependent;

import jakarta.inject.Inject;

import jakarta.inject.Named;

import jakarta.transaction.Transactional;

import org.eclipse.cargotracker.application.ApplicationEvents;

import org.eclipse.cargotracker.application.util.DateConverter;

import org.eclipse.cargotracker.interfaces.handling.HandlingEventRegistrationAttempt;

@Dependent @Named(""EventItemWriter"") public class EventItemWriter extends AbstractItemWriter {

private static final String ARCHIVE_DIRECTORY = ""archive_directory"";

@Inject private JobContext jobContext;

@Inject private ApplicationEvents applicationEvents;

@Override public void open(Serializable checkpoint) throws Exception { File archiveDirectory = new File(jobContext.getProperties().getProperty(ARCHIVE_DIRECTORY));

if (!archiveDirectory.exists()) {

archiveDirectory.mkdirs();

}

}

@Override @Transactional public void writeItems(List<Object> items) throws Exception { try (PrintWriter archive = new PrintWriter( new BufferedWriter( new FileWriter( jobContext.getProperties().getProperty(ARCHIVE_DIRECTORY) + ""/archive_"" + jobContext.getJobName() + ""_"" + jobContext.getInstanceId() + "".csv"", true)))) {

items

.stream()

.map(item

> (HandlingEventRegistrationAttempt) item)"|data_input/cargotracker/cargotracker.txt|c530738aa4f544048ab319b77d2f7713
"items

.stream()

.map(item

> (HandlingEventRegistrationAttempt) item)

.forEach(

attempt

> {

applicationEvents.receivedHandlingEventRegistrationAttempt(attempt);

archive.println(

DateConverter.toString(attempt.getRegistrationTime())

+ "",""

+ DateConverter.toString(attempt.getCompletionTime())

+ "",""

+ attempt.getTrackingId()

+ "",""

+ attempt.getVoyageNumber()

+ "",""

+ attempt.getUnLocode()

+ "",""

+ attempt.getType());

});

}

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/file/EventLineParseException.java

package org.eclipse.cargotracker.interfaces.handling.file;

public class EventLineParseException extends RuntimeException {

private static final long serialVersionUID = 1L;

private final String line;

public EventLineParseException(String message, Throwable cause, String line) { super(message, cause); this.line = line; }

public EventLineParseException(String message, String line) { super(message); this.line = line; }

public String getLine() {

return line;

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/file/FileProcessorJobListener.java

package org.eclipse.cargotracker.interfaces.handling.file;

import java.util.Date;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.batch.api.listener.JobListener;

import jakarta.enterprise.context.Dependent;

import jakarta.inject.Inject;

import jakarta.inject.Named;"|data_input/cargotracker/cargotracker.txt|809dbcd637eb4efda3174cb0a98674db
"import jakarta.enterprise.context.Dependent;

import jakarta.inject.Inject;

import jakarta.inject.Named;

@Dependent @Named(""FileProcessorJobListener"") public class FileProcessorJobListener implements JobListener {

@Inject private Logger logger;

@Override public void beforeJob() throws Exception { logger.log(Level.INFO, ""Handling event file processor batch job starting at {0}"", new Date()); }

@Override public void afterJob() throws Exception { logger.log(Level.INFO, ""Handling event file processor batch job completed at {0}"", new Date()); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/file/LineParseExceptionListener.java

package org.eclipse.cargotracker.interfaces.handling.file;

import java.io.BufferedWriter;

import java.io.File;

import java.io.FileWriter;

import java.io.PrintWriter;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.batch.api.chunk.listener.SkipReadListener;

import jakarta.batch.runtime.context.JobContext;

import jakarta.enterprise.context.Dependent;

import jakarta.inject.Inject;

import jakarta.inject.Named;

@Dependent @Named(""LineParseExceptionListener"") public class LineParseExceptionListener implements SkipReadListener {

private static final String FAILED_DIRECTORY = ""failed_directory"";

@Inject private Logger logger;

@Inject private JobContext jobContext;"|data_input/cargotracker/cargotracker.txt|b98ebb8e77b944a997876471d362d913
"private static final String FAILED_DIRECTORY = ""failed_directory"";

@Inject private Logger logger;

@Inject private JobContext jobContext;

@Override public void onSkipReadItem(Exception e) throws Exception { File failedDirectory = new File(jobContext.getProperties().getProperty(FAILED_DIRECTORY));

if (!failedDirectory.exists()) {

failedDirectory.mkdirs();

}

EventLineParseException parseException = (EventLineParseException) e;

logger.log(Level.WARNING, ""Problem parsing event file line"", parseException);

try (PrintWriter failed =

new PrintWriter(

new BufferedWriter(

new FileWriter(

new File(

failedDirectory,

""failed_""

+ jobContext.getJobName()

+ ""_""

+ jobContext.getInstanceId()

+ "".csv""),

true)))) {

failed.println(parseException.getLine());

}

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/file/UploadDirectoryScanner.java

package org.eclipse.cargotracker.interfaces.handling.file;

import jakarta.annotation.security.PermitAll;

import jakarta.batch.operations.JobOperator;

import jakarta.batch.runtime.BatchRuntime;

import jakarta.ejb.Schedule;

import jakarta.ejb.Stateless;

import jakarta.ejb.TransactionManagement;

import jakarta.ejb.TransactionManagementType;"|data_input/cargotracker/cargotracker.txt|29755584fb9348e8b5a9a9ba440f7f0e
"import jakarta.ejb.Stateless;

import jakarta.ejb.TransactionManagement;

import jakarta.ejb.TransactionManagementType;

/** * Periodically scans a certain directory for files and attempts to parse handling event * registrations from the contents by calling a batch job. * * <p>Files that fail to parse are moved into a separate directory, successful files are deleted. */ @Stateless @PermitAll @TransactionManagement(TransactionManagementType.BEAN) // Batch steps manage their own transactions. public class UploadDirectoryScanner {

@Schedule(minute = ""*/2"", hour = ""*"") // In production, run every fifteen minutes public void processFiles() { JobOperator jobOperator = BatchRuntime.getJobOperator(); jobOperator.start(""EventFilesProcessorJob"", null); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/mobile/EventLogger.java

package org.eclipse.cargotracker.interfaces.handling.mobile;

import static java.util.stream.Collectors.toMap;

import java.io.Serializable;

import java.time.LocalDateTime;

import java.util.ArrayList;

import java.util.Arrays;

import java.util.Collections;

import java.util.List;

import java.util.Map;

import java.util.function.Function;

import jakarta.annotation.PostConstruct;

import jakarta.faces.application.FacesMessage;

import jakarta.faces.context.FacesContext;

import jakarta.faces.model.SelectItem;

import jakarta.faces.view.ViewScoped;

import jakarta.inject.Inject;

import jakarta.inject.Named;"|data_input/cargotracker/cargotracker.txt|33ef7adc3ec542f786067fb96fdeeb05
"import jakarta.faces.model.SelectItem;

import jakarta.faces.view.ViewScoped;

import jakarta.inject.Inject;

import jakarta.inject.Named;

import org.eclipse.cargotracker.application.ApplicationEvents;

import org.eclipse.cargotracker.application.util.DateConverter;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.CargoRepository;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.cargo.TransportStatus;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.location.Location;

import org.eclipse.cargotracker.domain.model.location.LocationRepository;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.Voyage;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

import org.eclipse.cargotracker.domain.model.voyage.VoyageRepository;

import org.eclipse.cargotracker.interfaces.handling.HandlingEventRegistrationAttempt;

import org.primefaces.event.FlowEvent;

@Named @ViewScoped public class EventLogger implements Serializable {

private static final long serialVersionUID = 1L;

@Inject private CargoRepository cargoRepository;

@Inject private LocationRepository locationRepository;

@Inject private VoyageRepository voyageRepository;

@Inject private ApplicationEvents applicationEvents;"|data_input/cargotracker/cargotracker.txt|2113768eb3d146058c93092ffe9ff9f5
"@Inject private VoyageRepository voyageRepository;

@Inject private ApplicationEvents applicationEvents;

@Inject private FacesContext context;

private List<SelectItem> trackingIds;

private List<SelectItem> locations;

private List<SelectItem> voyages;

private String trackingId;

private String location;

private HandlingEvent.Type eventType;

private String voyageNumber;

private LocalDateTime completionTime;

public String getTrackingId() {

return trackingId;

}

public void setTrackingId(String trackingId) { this.trackingId = trackingId; }

public List<SelectItem> getTrackingIds() {

return trackingIds;

}

public String getLocation() {

return location;

}

public void setLocation(String location) { this.location = location; }

public List<SelectItem> getLocations() {

return locations;

}

// Move this to a separate utility if it is used in other parts of the UI. public Map<HandlingEvent.Type, HandlingEvent.Type> getEventTypes() { return Collections.unmodifiableMap( Arrays.asList(HandlingEvent.Type.values()) .stream() .collect(toMap(Function.identity(), Function.identity()))); }

public HandlingEvent.Type getEventType() {

return eventType;

}

public void setEventType(HandlingEvent.Type eventType) { this.eventType = eventType; }

public String getVoyageNumber() {

return voyageNumber;

}

public void setVoyageNumber(String voyageNumber) { this.voyageNumber = voyageNumber; }

public List<SelectItem> getVoyages() {

return voyages;

}"|data_input/cargotracker/cargotracker.txt|628d6f97a71143f7aae19501b7b6e37f
"public void setVoyageNumber(String voyageNumber) { this.voyageNumber = voyageNumber; }

public List<SelectItem> getVoyages() {

return voyages;

}

public LocalDateTime getCompletionTime() {

return completionTime;

}

public void setCompletionTime(LocalDateTime completionTime) { this.completionTime = completionTime; }

public String getCompletionTimeValue() {

return DateConverter.toString(completionTime);

}

public String getCompletionTimePattern() {

return DateConverter.DATE_TIME_FORMAT;

}

@PostConstruct

public void init() {

List<Cargo> cargos = cargoRepository.findAll();

trackingIds = new ArrayList<>(cargos.size());

// List only routed cargo that is not claimed yet. cargos .stream() .filter( cargo -> !cargo.getItinerary().getLegs().isEmpty() && ! (cargo .getDelivery() .getTransportStatus() .sameValueAs(TransportStatus.CLAIMED))) .map(cargo -> cargo.getTrackingId().getIdString()) .forEachOrdered(trackingId -> trackingIds.add(new SelectItem(trackingId, trackingId)));

List<Location> locations = locationRepository.findAll();

this.locations = new ArrayList<>(locations.size());

locations.forEach( location -> { String locationCode = location.getUnLocode().getIdString(); this.locations.add( new SelectItem(locationCode, location.getName() + "" ("" + locationCode + "")"")); });

List<Voyage> voyages = voyageRepository.findAll();

this.voyages = new ArrayList<>(voyages.size());

voyages.forEach(

voyage

>

this.voyages.add(

new SelectItem("|data_input/cargotracker/cargotracker.txt|793e2f4bdcca4291bd9689e97272d6bf
"this.voyages = new ArrayList<>(voyages.size());

voyages.forEach(

voyage

>

this.voyages.add(

new SelectItem(

voyage.getVoyageNumber().getIdString(),

voyage.getVoyageNumber().getIdString())));

}

public String onFlowProcess(FlowEvent event) { if (!validate(event.getOldStep())) { return event.getOldStep(); }

if (""dateTab"".equals(event.getNewStep())) {

completionTime = LocalDateTime.now();

}

return event.getNewStep();

}

private boolean validate(final String step) { if (""voyageTab"".equals(step) && eventType.requiresVoyage() && voyageNumber == null) { FacesMessage message = new FacesMessage( FacesMessage.SEVERITY_ERROR, ""When a cargo is LOADed or UNLOADed a Voyage should be selected, please fix errors to continue. "", """"); context.addMessage(null, message); return false; }

return true;

}

public void submit() {

VoyageNumber voyage;

TrackingId trackingId = new TrackingId(this.trackingId); UnLocode location = new UnLocode(this.location);

if (eventType.requiresVoyage()) {

voyage = new VoyageNumber(voyageNumber);

} else {

voyage = null;

}

HandlingEventRegistrationAttempt attempt = new HandlingEventRegistrationAttempt( LocalDateTime.now(), completionTime, trackingId, voyage, eventType, location);

applicationEvents.receivedHandlingEventRegistrationAttempt(attempt);

FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(""Event submitted"", """")); } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/rest/HandlingReport.java"|data_input/cargotracker/cargotracker.txt|30df682feefd4a9ca4971c1a16a733aa
"../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/rest/HandlingReport.java

package org.eclipse.cargotracker.interfaces.handling.rest;

import jakarta.validation.constraints.NotBlank;

import jakarta.validation.constraints.Size;

import jakarta.xml.bind.annotation.XmlRootElement;

/** Transfer object for handling reports. */ @XmlRootElement public class HandlingReport {

@NotBlank(message = ""Missing completion time."") @Size( min = 15, max = 19, message = ""Completion time value must be between fifteen and nineteen characters long."") // TODO [DDD] Apply regular expression validation. private String completionTime;

@NotBlank(message = ""Missing tracking ID."") @Size(min = 4, message = ""Tracking ID must be at least four characters."") private String trackingId;

@NotBlank(message = ""Missing event type."") @Size( min = 4, max = 7, message = ""Event type value must be one of: RECEIVE, LOAD, UNLOAD, CUSTOMS, CLAIM"") // TODO [DDD] Apply regular expression validation. private String eventType;

@NotBlank(message = ""UN location code missing."") @Size(min = 5, max = 5, message = ""UN location code must be five characters long."") private String unLocode;

@Size( min = 4, max = 5, message = ""Voyage number value must be between four and five characters long."") private String voyageNumber;

public String getCompletionTime() {

return completionTime;

}

public void setCompletionTime(String value) { this.completionTime = value; }

public String getTrackingId() {"|data_input/cargotracker/cargotracker.txt|874719956df74d049775b347247c9f2f
"return completionTime;

}

public void setCompletionTime(String value) { this.completionTime = value; }

public String getTrackingId() {

return trackingId;

}

public void setTrackingId(String trackingId) { this.trackingId = trackingId; }

public String getEventType() {

return eventType;

}

public void setEventType(String value) { this.eventType = value; }

public String getUnLocode() {

return unLocode;

}

public void setUnLocode(String value) { this.unLocode = value; }

public String getVoyageNumber() {

return voyageNumber;

}

public void setVoyageNumber(String value) { this.voyageNumber = value; } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/handling/rest/HandlingReportService.java

package org.eclipse.cargotracker.interfaces.handling.rest;

import java.time.LocalDateTime;

import jakarta.ejb.Stateless;

import jakarta.inject.Inject;

import jakarta.validation.Valid;

import jakarta.validation.constraints.NotNull;

import jakarta.ws.rs.Consumes;

import jakarta.ws.rs.POST;

import jakarta.ws.rs.Path;

import org.eclipse.cargotracker.application.ApplicationEvents;

import org.eclipse.cargotracker.application.util.DateConverter;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;"|data_input/cargotracker/cargotracker.txt|22c76f5374cd4f2cb514d1739f71bd9d
"import org.eclipse.cargotracker.domain.model.location.UnLocode;

import org.eclipse.cargotracker.domain.model.voyage.VoyageNumber;

import org.eclipse.cargotracker.interfaces.handling.HandlingEventRegistrationAttempt;

/** * This REST end-point implementation performs basic validation and parsing of incoming data, and in * case of a valid registration attempt, sends an asynchronous message with the information to the * handling event registration system for proper registration. */ @Stateless @Path(""/handling"") public class HandlingReportService {

@Inject private ApplicationEvents applicationEvents;

@POST @Path(""/reports"") @Consumes({""application/json"", ""application/xml""}) public void submitReport( @NotNull(message = ""Missing handling report."") @Valid HandlingReport handlingReport) { LocalDateTime completionTime = DateConverter.toDateTime(handlingReport.getCompletionTime()); VoyageNumber voyageNumber = null;

if (handlingReport.getVoyageNumber() != null) { voyageNumber = new VoyageNumber(handlingReport.getVoyageNumber()); }

HandlingEvent.Type type = HandlingEvent.Type.valueOf(handlingReport.getEventType()); UnLocode unLocode = new UnLocode(handlingReport.getUnLocode());

TrackingId trackingId = new TrackingId(handlingReport.getTrackingId());

HandlingEventRegistrationAttempt attempt = new HandlingEventRegistrationAttempt( LocalDateTime.now(), completionTime, trackingId, voyageNumber, type, unLocode);

applicationEvents.receivedHandlingEventRegistrationAttempt(attempt);

}"|data_input/cargotracker/cargotracker.txt|eb3708a9577f4446abcb03ddec9546c8
"applicationEvents.receivedHandlingEventRegistrationAttempt(attempt);

}

}

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/tracking/web/CargoTrackingViewAdapter.java

package org.eclipse.cargotracker.interfaces.tracking.web;

import java.time.LocalDateTime;

import java.util.ArrayList;

import java.util.Collections;

import java.util.List;

import org.eclipse.cargotracker.application.util.DateConverter;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.Delivery;

import org.eclipse.cargotracker.domain.model.cargo.HandlingActivity;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.interfaces.Coordinates;

import org.eclipse.cargotracker.interfaces.CoordinatesFactory;

/** View adapter for displaying a cargo in a tracking context. */ public class CargoTrackingViewAdapter {

private final Cargo cargo;

private final List<HandlingEventViewAdapter> events;

public CargoTrackingViewAdapter(Cargo cargo, List<HandlingEvent> handlingEvents) { this.cargo = cargo; this.events = new ArrayList<>(handlingEvents.size());

handlingEvents.stream().map(HandlingEventViewAdapter::new).forEach(events::add);

}

public String getTrackingId() {

return cargo.getTrackingId().getIdString();

}

public String getOriginName() {

return cargo.getRouteSpecification().getOrigin().getName();

}

public String getOriginCode() {"|data_input/cargotracker/cargotracker.txt|e4308ecbfea34120bbb8cca569a20cdf
"}

public String getOriginName() {

return cargo.getRouteSpecification().getOrigin().getName();

}

public String getOriginCode() {

return cargo.getRouteSpecification().getOrigin().getUnLocode().getIdString();

}

public Coordinates getOriginCoordinates() {

return CoordinatesFactory.find(cargo.getRouteSpecification().getOrigin());

}

public String getDestinationName() {

return cargo.getRouteSpecification().getDestination().getName();

}

public String getDestinationCode() {

return cargo.getRouteSpecification().getDestination().getUnLocode().getIdString();

}

public Coordinates getDestinationCoordinates() {

return CoordinatesFactory.find(cargo.getRouteSpecification().getDestination());

}

public String getLastKnownLocationName() {

return cargo.getDelivery().getLastKnownLocation().getUnLocode().getIdString().equals(""XXXXX"")

? ""Unknown""

: cargo.getDelivery().getLastKnownLocation().getName();

}

public String getLastKnownLocationCode() {

return cargo.getDelivery().getLastKnownLocation().getUnLocode().getIdString();

}

public Coordinates getLastKnownLocationCoordinates() {

return CoordinatesFactory.find(cargo.getDelivery().getLastKnownLocation());

}

public String getStatusCode() {

if (cargo.getItinerary().getLegs().isEmpty()) {

return ""NOT_ROUTED"";

}

if (cargo.getDelivery().isUnloadedAtDestination()) {

return ""AT_DESTINATION"";

}

if (cargo.getDelivery().isMisdirected()) {

return ""MISDIRECTED"";

}

return cargo.getDelivery().getTransportStatus().name();

}"|data_input/cargotracker/cargotracker.txt|8895affb67c14b97872a6d0904dd4541
"}

if (cargo.getDelivery().isMisdirected()) {

return ""MISDIRECTED"";

}

return cargo.getDelivery().getTransportStatus().name();

}

/** @return A readable string describing the cargo status. */ public String getStatusText() { Delivery delivery = cargo.getDelivery();

switch (delivery.getTransportStatus()) { case IN_PORT: return ""In port "" + cargo.getRouteSpecification().getDestination().getName(); case ONBOARD_CARRIER: return ""Onboard voyage "" + delivery.getCurrentVoyage().getVoyageNumber().getIdString(); case CLAIMED: return ""Claimed""; case NOT_RECEIVED: return ""Not received""; case UNKNOWN: return ""Unknown""; default: return ""[Unknown status]""; // Should never happen. } }

public boolean isMisdirected() {

return cargo.getDelivery().isMisdirected();

}

public String getEta() {

LocalDateTime eta = cargo.getDelivery().getEstimatedTimeOfArrival();

if (eta == null) { return ""? ""; } else { return DateConverter.toString(eta); } }

public String getNextExpectedActivity() {

HandlingActivity activity = cargo.getDelivery().getNextExpectedActivity();

if ((activity == null) || (activity.isEmpty())) { return """"; }

String text = ""Next expected activity is to ""; HandlingEvent.Type type = activity.getType();"|data_input/cargotracker/cargotracker.txt|b451c32dc43741d7826573a7c49c5665
"String text = ""Next expected activity is to ""; HandlingEvent.Type type = activity.getType();

if (type.sameValueAs(HandlingEvent.Type.LOAD)) { return text + type.name().toLowerCase() + "" cargo onto voyage "" + activity.getVoyage().getVoyageNumber() + "" in "" + activity.getLocation().getName(); } else if (type.sameValueAs(HandlingEvent.Type.UNLOAD)) { return text + type.name().toLowerCase() + "" cargo off of "" + activity.getVoyage().getVoyageNumber() + "" in "" + activity.getLocation().getName(); } else { return text + type.name().toLowerCase() + "" cargo in "" + activity.getLocation().getName(); } }

/** @return An unmodifiable list of handling event view adapters. */ public List<HandlingEventViewAdapter> getEvents() { return Collections.unmodifiableList(events); }

/** Handling event view adapter component. */ public class HandlingEventViewAdapter {

private final HandlingEvent handlingEvent;

public HandlingEventViewAdapter(HandlingEvent handlingEvent) {

this.handlingEvent = handlingEvent;

}

public String getTime() {

return DateConverter.toString(handlingEvent.getCompletionTime());

}

public boolean isExpected() {

return cargo.getItinerary().isExpected(handlingEvent);

}"|data_input/cargotracker/cargotracker.txt|a9225a1917f545fa891b30fce861a187
"}

public boolean isExpected() {

return cargo.getItinerary().isExpected(handlingEvent);

}

public String getDescription() { switch (handlingEvent.getType()) { case LOAD: return ""Loaded onto voyage "" + handlingEvent.getVoyage().getVoyageNumber().getIdString() + "" in "" + handlingEvent.getLocation().getName(); case UNLOAD: return ""Unloaded off voyage "" + handlingEvent.getVoyage().getVoyageNumber().getIdString() + "" in "" + handlingEvent.getLocation().getName(); case RECEIVE: return ""Received in "" + handlingEvent.getLocation().getName(); case CLAIM: return ""Claimed in "" + handlingEvent.getLocation().getName(); case CUSTOMS: return ""Cleared customs in "" + handlingEvent.getLocation().getName(); default: return ""[Unknown]""; } } } }

../cargotracker/src/main/java/org/eclipse/cargotracker/interfaces/tracking/web/Track.java

package org.eclipse.cargotracker.interfaces.tracking.web;

import static java.nio.charset.StandardCharsets.UTF_8;

import java.io.Serializable;

import java.io.UnsupportedEncodingException;

import java.net.URLEncoder;

import java.util.List;

import java.util.logging.Level;

import java.util.logging.Logger;

import jakarta.faces.view.ViewScoped;

import jakarta.inject.Inject;

import jakarta.inject.Named;

import jakarta.json.bind.JsonbBuilder;

import org.eclipse.cargotracker.domain.model.cargo.Cargo;

import org.eclipse.cargotracker.domain.model.cargo.CargoRepository;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;"|data_input/cargotracker/cargotracker.txt|2ab01e553502485a888a6d2a904ec376
"import org.eclipse.cargotracker.domain.model.cargo.CargoRepository;

import org.eclipse.cargotracker.domain.model.cargo.TrackingId;

import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;

import org.eclipse.cargotracker.domain.model.handling.HandlingEventRepository;

/** * Backing bean for tracking cargo. This interface sits immediately on top of the domain layer, * unlike the booking interface which has a facade and supporting DTOs in between. * * <p>An adapter class, designed for the tracking use case, is used to wrap the domain model to make * it easier to work with in a web page rendering context. We do not want to apply view rendering * constraints to the design of our domain model and the adapter helps us shield the domain model * classes where needed. * * <p>In some very simplistic cases, it is fine to not use even an adapter. */ @Named(""public.track"") @ViewScoped public class Track implements Serializable {

private static final long serialVersionUID = 1L;

@Inject private transient Logger logger;

@Inject private CargoRepository cargoRepository;

@Inject private HandlingEventRepository handlingEventRepository;

private String trackingId;

private CargoTrackingViewAdapter cargo;

public String getTrackingId() {

return trackingId;

}

public void setTrackingId(String trackingId) { if (trackingId != null) { trackingId = trackingId.trim(); }

this.trackingId = trackingId;

}

public CargoTrackingViewAdapter getCargo() {

return cargo;

}"|data_input/cargotracker/cargotracker.txt|b5393c37725d49a69e5d1a4f22ba8a7a
"this.trackingId = trackingId;

}

public CargoTrackingViewAdapter getCargo() {

return cargo;

}

public String getCargoAsJson() { try { return URLEncoder.encode(JsonbBuilder.create().toJson(cargo), UTF_8.name()); } catch (UnsupportedEncodingException ex) { logger.log(Level.WARNING, ""URL encoding error. "", ex); return """"; // Should never happen. } }

public void onTrackById() { Cargo cargo = cargoRepository.find(new TrackingId(trackingId));

if (cargo != null) { List<HandlingEvent> handlingEvents = handlingEventRepository .lookupHandlingHistoryOfCargo(new TrackingId(trackingId)) .getDistinctEventsByCompletionTime(); this.cargo = new CargoTrackingViewAdapter(cargo, handlingEvents); } else { this.cargo = null; } } }

../cargotracker/src/main/java/org/eclipse/pathfinder/api/GraphTraversalService.java

package org.eclipse.pathfinder.api;

import java.time.LocalDateTime;

import java.time.temporal.ChronoUnit;

import java.util.ArrayList;

import java.util.Collections;

import java.util.List;

import java.util.Random;

import jakarta.ejb.Stateless;

import jakarta.inject.Inject;

import jakarta.validation.constraints.NotNull;

import jakarta.validation.constraints.Pattern;

import jakarta.validation.constraints.Size;

import jakarta.ws.rs.GET;

import jakarta.ws.rs.Path;

import jakarta.ws.rs.Produces;

import jakarta.ws.rs.QueryParam;

import org.eclipse.pathfinder.internal.GraphDao;

@Stateless

@Path(""/graph

traversal"")

public class GraphTraversalService {"|data_input/cargotracker/cargotracker.txt|fe8377d214f84e3d91b1bddec3249cbb
text|source|chunk_id
"import org.eclipse.pathfinder.internal.GraphDao;

@Stateless

@Path(""/graph

traversal"")

public class GraphTraversalService {

private static final long ONE_MIN_MS = 1000 * 60; private static final long ONE_DAY_MS = ONE_MIN_MS * 60 * 24; private static final String UNLOCODE_PATTERN_VIOLATION_MESSAGE = ""UN location code value must be five characters long, "" + ""the first two must be alphabetic and "" + ""the last three must be alphanumeric (excluding 0 and 1). ""; private final Random random = new Random(); @Inject private GraphDao dao;

@GET @Path(""/shortest-path"") @Produces({""application/json"", ""application/xml; qs=.75""}) public List<TransitPath> findShortestPath( @NotNull(message = ""Missing origin UN location code."") @Pattern( regexp = ""[a-zA-Z]{2}[a-zA-Z2-9]{3}"", message = ""Origin "" + UNLOCODE_PATTERN_VIOLATION_MESSAGE) @QueryParam(""origin"") String originUnLocode, @NotNull(message = ""Missing destination UN location code."") @Pattern( regexp = ""[a-zA-Z]{2}[a-zA-Z2-9]{3}"", message = ""Destination "" + UNLOCODE_PATTERN_VIOLATION_MESSAGE) @QueryParam(""destination"") String destinationUnLocode, // TODO [DDD] Apply regular expression validation. @Size(min = 8, max = 8, message = ""Deadline value must be eight characters long."") @QueryParam(""deadline"") String deadline) {

List<String> allVertices = dao.listLocations();

allVertices.remove(originUnLocode);

allVertices.remove(destinationUnLocode);"|data_input/cargotracker/cargotracker.txt|2f1256eac1c443a6af51fa69af6d8bf8
"List<String> allVertices = dao.listLocations();

allVertices.remove(originUnLocode);

allVertices.remove(destinationUnLocode);

int candidateCount = getRandomNumberOfCandidates(); List<TransitPath> candidates = new ArrayList<>(candidateCount);

for (int i = 0; i < candidateCount; i++) { allVertices = getRandomChunkOfLocations(allVertices); List<TransitEdge> transitEdges = new ArrayList<>(allVertices.size() - 1); String fromUnLocode = originUnLocode; LocalDateTime date = LocalDateTime.now();

for (int j = 0; j <= allVertices.size(); ++j) { LocalDateTime fromDate = nextDate(date); LocalDateTime toDate = nextDate(fromDate); String toUnLocode = (j >= allVertices.size() ? destinationUnLocode : allVertices.get(j)); transitEdges.add( new TransitEdge( dao.getVoyageNumber(fromUnLocode, toUnLocode), fromUnLocode, toUnLocode, fromDate, toDate)); fromUnLocode = toUnLocode; date = nextDate(toDate); } candidates.add(new TransitPath(transitEdges)); } return candidates; }

private LocalDateTime nextDate(LocalDateTime date) { return date.plus(ONE_DAY_MS + (random.nextInt(1000) - 500) * ONE_MIN_MS, ChronoUnit.MILLIS); }

private int getRandomNumberOfCandidates() {

return 3 + random.nextInt(3);

}

private List<String> getRandomChunkOfLocations(List<String> allLocations) { Collections.shuffle(allLocations); int total = allLocations.size(); int chunk = total > 4 ? 1 + random.nextInt(5) : total; return allLocations.subList(0, chunk); } }"|data_input/cargotracker/cargotracker.txt|ea3153da8b864c3e8533d112fbed2ae0
"../cargotracker/src/main/java/org/eclipse/pathfinder/api/TransitEdge.java

package org.eclipse.pathfinder.api;

import java.io.Serializable;

import java.time.LocalDateTime;

/** Represents an edge in a path through a graph, describing the route of a cargo. */ public class TransitEdge implements Serializable {

private static final long serialVersionUID = 1L;

private String voyageNumber;

private String fromUnLocode;

private String toUnLocode;

private LocalDateTime fromDate;

private LocalDateTime toDate;

public TransitEdge() {

// Nothing to do.

}

public TransitEdge(

String voyageNumber,

String fromUnLocode,

String toUnLocode,

LocalDateTime fromDate,

LocalDateTime toDate) {

this.voyageNumber = voyageNumber;

this.fromUnLocode = fromUnLocode;

this.toUnLocode = toUnLocode;

this.fromDate = fromDate;

this.toDate = toDate;

}

public String getVoyageNumber() {

return voyageNumber;

}

public void setVoyageNumber(String voyageNumber) { this.voyageNumber = voyageNumber; }

public String getFromUnLocode() {

return fromUnLocode;

}

public void setFromUnLocode(String fromUnLocode) { this.fromUnLocode = fromUnLocode; }

public String getToUnLocode() {

return toUnLocode;

}

public void setToUnLocode(String toUnLocode) { this.toUnLocode = toUnLocode; }

public LocalDateTime getFromDate() {

return fromDate;

}

public void setFromDate(LocalDateTime fromDate) { this.fromDate = fromDate; }

public LocalDateTime getToDate() {

return toDate;

}"|data_input/cargotracker/cargotracker.txt|89975f75b4d24583aa1d3af5025aefcc
"}

public void setFromDate(LocalDateTime fromDate) { this.fromDate = fromDate; }

public LocalDateTime getToDate() {

return toDate;

}

public void setToDate(LocalDateTime toDate) { this.toDate = toDate; }

@Override

public String toString() {

return ""TransitEdge{""

+ ""voyageNumber=""

+ voyageNumber

+ "", fromUnLocode=""

+ fromUnLocode

+ "", toUnLocode=""

+ toUnLocode

+ "", fromDate=""

+ fromDate

+ "", toDate=""

+ toDate

+ '}';

}

}

../cargotracker/src/main/java/org/eclipse/pathfinder/api/TransitPath.java

package org.eclipse.pathfinder.api;

import java.io.Serializable;

import java.util.ArrayList;

import java.util.List;

import jakarta.xml.bind.annotation.XmlRootElement;

@XmlRootElement public class TransitPath implements Serializable {

private static final long serialVersionUID = 1L;

private List<TransitEdge> transitEdges;

public TransitPath() {

this.transitEdges = new ArrayList<>();

}

public TransitPath(List<TransitEdge> transitEdges) {

this.transitEdges = transitEdges;

}

public List<TransitEdge> getTransitEdges() {

return transitEdges;

}

public void setTransitEdges(List<TransitEdge> transitEdges) { this.transitEdges = transitEdges; }

@Override public String toString() { return ""TransitPath{"" + ""transitEdges="" + transitEdges + '}'; } }

../cargotracker/src/main/java/org/eclipse/pathfinder/internal/GraphDao.java

package org.eclipse.pathfinder.internal;

import java.io.Serializable;

import java.util.ArrayList;

import java.util.Arrays;"|data_input/cargotracker/cargotracker.txt|dd1098e7bd6a4f39a082c27dbb04cf82
"package org.eclipse.pathfinder.internal;

import java.io.Serializable;

import java.util.ArrayList;

import java.util.Arrays;

import java.util.List;

import java.util.Random;

import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped public class GraphDao implements Serializable {

private static final long serialVersionUID = 1L;

private final Random random = new Random();

public List<String> listLocations() { return new ArrayList<>( Arrays.asList( ""CNHKG"", ""AUMEL"", ""SESTO"", ""FIHEL"", ""USCHI"", ""JNTKO"", ""DEHAM"", ""CNSHA"", ""NLRTM"", ""SEGOT"", ""CNHGH"", ""USNYC"", ""USDAL"")); }

public String getVoyageNumber(String from, String to) { int i = random.nextInt(5);

switch (i) {

case 0:

return ""0100S"";

case 1:

return ""0200T"";

case 2:

return ""0300A"";

case 3:

return ""0301S"";

default:

return ""0400S"";

}

}

}"|data_input/cargotracker/cargotracker.txt|660bfb821c1542718c3f75f289264479
"return ""0300A"";

case 3:

return ""0301S"";

default:

return ""0400S"";

}

}

}

../cargotracker/src/main/webapp/resources/js/jquery.min.js /*! jQuery v3.5.1 | (c) JS Foundation and other contributors | jquery.org/license */ !function (e, t) { ""use strict""; ""object"" == typeof module && ""object"" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) { if (!e.document) throw new Error(""jQuery requires a window with a document""); return t(e) } : t(e) }(""undefined"" != typeof window ? window : this, function (C, e) { ""use strict""; var t = [], r = Object.getPrototypeOf, s = t.slice, g = t.flat ? function (e) { return t.flat.call(e) } : function (e) { return t.concat.apply([], e) }, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call(Object), y = {}, m = function (e) { return ""function"" == typeof e && ""number"" != typeof e.nodeType }, x = function (e) { return null != e && e === e.window }, E = C.document, c = { type: !0, src: !0, nonce: !0, noModule: !0 }; function b(e, t, n) { var r, i, o = (n = n || E).createElement(""script""); if (o.text = e, t) for (r in c) (i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i); n.head.appendChild(o).parentNode.removeChild(o) } function w(e) { return null == e ? e + """" : ""object"" == typeof e || ""function"" == typeof e ? n[o.call(e)] || ""object"" : typeof e } var f = ""3.5.1"", S = function (e, t) { return new S.fn.init(e, t) }; function p(e) { var t = !"|data_input/cargotracker/cargotracker.txt|d2e761d972e84a92a95540de5c290448
"!e && ""length"" in e && e.length, n = w(e); return !m(e) && !x(e) && (""array"" === n || 0 === t || ""number"" == typeof t && 0 < t && t - 1 in e) } S.fn = S.prototype = { jquery: f, constructor: S, length: 0, toArray: function () { return s.call(this) }, get: function (e) { return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function (e) { var t = S.merge(this.constructor(), e); return t.prevObject = this, t }, each: function (e) { return S.each(this, e) }, map: function (n) { return this.pushStack(S.map(this, function (e, t) { return n.call(e, t, e) })) }, slice: function () { return this.pushStack(s.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, even: function () { return this.pushStack(S.grep(this, function (e, t) { return (t + 1) % 2 })) }, odd: function () { return this.pushStack(S.grep(this, function (e, t) { return t % 2 })) }, eq: function (e) { var t = this.length, n = +e + (e < 0 ? t : 0); return this.pushStack(0 <= n && n < t ?"|data_input/cargotracker/cargotracker.txt|64dd01da6cdb4b908dc71a2ba7593b48
"[this[n]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: u, sort: t.sort, splice: t.splice }, S.extend = S.fn.extend = function () { var e, t, n, r, i, o, a = arguments[0] || {}, s = 1, u = arguments.length, l = !1; for (""boolean"" == typeof a && (l = a, a = arguments[s] || {}, s++), ""object"" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++)if (null != (e = arguments[s])) for (t in e) r = e[t], ""__proto__"" !== t && a !== r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r)); return a }, S.extend({ expando: ""jQuery"" + (f + Math.random()).replace(/\D/g, """"), isReady: !0, error: function (e) { throw new Error(e) }, noop: function () { }, isPlainObject: function (e) { var t, n; return ! (!e || ""[object Object]"" !== o.call(e)) && (! (t = r(e)) || ""function"" == typeof (n = v.call(t, ""constructor"") && t.constructor) && a.call(n) === l) }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0 }, globalEval: function (e, t, n) { b(e, { nonce: t && t.nonce }, n) }, each: function (e, t) { var n, r = 0; if (p(e)) { for (n = e.length; r < n; r++)if (!1 === t.call(e[r], r, e[r])) break } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e }, makeArray: function (e, t) { var n = t || []; return null != e && (p(Object(e)) ?"|data_input/cargotracker/cargotracker.txt|3a456e0e8e3a4cf3993aa69e569df09d
"S.merge(n, ""string"" == typeof e ? [e] : e) : u.call(n, e)), n }, inArray: function (e, t, n) { return null == t ? -1 : i.call(t, e, n) }, merge: function (e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++)e[i++] = t[r]; return e.length = i, e }, grep: function (e, t, n) { for (var r = [], i = 0, o = e.length, a = !n; i < o; i++)!t(e[i], i) !== a && r.push(e[i]); return r }, map: function (e, t, n) { var r, i, o = 0, a = []; if (p(e)) for (r = e.length; o < r; o++)null != (i = t(e[o], o, n)) && a.push(i); else for (o in e) null != (i = t(e[o], o, n)) && a.push(i); return g(a) }, guid: 1, support: y }), ""function"" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each(""Boolean Number String Function Array Date RegExp Object Error Symbol"".split("" ""), function (e, t) { n[""[object "" + t + ""]""] = t.toLowerCase() }); var d = function (n) { var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, S = ""sizzle"" + 1 * new Date, p = n.document, k = 0, r = 0, m = ue(), x = ue(), A = ue(), N = ue(), D = function (e, t) { return e === t && (l = !0), 0 }, j = {}.hasOwnProperty, t = [], q = t.pop, L = t.push, H = t.push, O = t.slice, P = function (e, t) { for (var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n; return -1 }, R = ""checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped"", M = ""[\\x20\\t\\r\\n\\f]"", I = ""(?"|data_input/cargotracker/cargotracker.txt|375121a1fb9a41069f4bb301895092c6
":\\\\[\\da-fA-F]{1,6}"" + M + ""?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+"", W = ""\\["" + M + ""*("" + I + "")(? :"" + M + ""*([*^$|!~]?=)"" + M + ""*(?:'((?:\\\\.|[^\\\\'])*)'|\""((? :\\\\.|[^\\\\\""])*)\""|("" + I + ""))|)"" + M + ""*\\]"", F = "":("" + I + "")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\""((?:\\\\.|[^\\\\\""])*)\"")|((? :\\\\.|[^\\\\()[\\]]|"" + W + "")*)|. *)\\)|)"", B = new RegExp(M + ""+"", ""g""), $ = new RegExp(""^"" + M + ""+|((?:^|[^\\\\])(?:\\\\. )*)"" + M + ""+$"", ""g""), _ = new RegExp(""^"" + M + ""*,"" + M + ""*""), z = new RegExp(""^"" + M + ""*([>+~]|"" + M + "")"" + M + ""*""), U = new RegExp(M + ""|>""), X = new RegExp(F), V = new RegExp(""^"" + I + ""$""), G = { ID: new RegExp(""^#("" + I + "")""), CLASS: new RegExp(""^\\. ("" + I + "")""), TAG: new RegExp(""^("" + I + ""|[*])""), ATTR: new RegExp(""^"" + W), PSEUDO: new RegExp(""^"" + F), CHILD: new RegExp(""^:(only|first|last|nth|nth-last)-(child|of-type)(? :\\("" + M + ""*(even|odd|(([+-]|)(\\d*)n|)"" + M + ""*(? :([+-]|)"" + M + ""*(\\d+)|))"" + M + ""*\\)|)"", ""i""), bool: new RegExp(""^(? :"" + R + "")$"", ""i""), needsContext: new RegExp(""^"" + M + ""*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(? :\\("" + M + ""*((? :-\\d)?\\d*)"" + M + ""*\\)|)(?=[^-]|$)"", ""i"") }, Y = /HTML$/i, Q = /^(? :input|select|textarea|button)$/i, J = /^h\d$/i, K = /^[^{]+\{\s*\[native \w/, Z = /^(?:#([\w-]+)|(\w+)|\. ([\w-]+))$/, ee = /[+~]/, te = new RegExp(""\\\\[\\da-fA-F]{1,6}"" + M + ""?|\\\\([^\\r\\n\\f])"", ""g""), ne = function (e, t) { var n = ""0x"" + e.slice(1) - 65536; return t || (n < 0 ?"|data_input/cargotracker/cargotracker.txt|1c25b8b029364498bf36292090736459
"String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)) }, re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ie = function (e, t) { return t ? ""\0"" === e ? ""\ufffd"" : e.slice(0, -1) + ""\\"" + e.charCodeAt(e.length - 1).toString(16) + "" "" : ""\\"" + e }, oe = function () { T() }, ae = be(function (e) { return !0 === e.disabled && ""fieldset"" === e.nodeName.toLowerCase() }, { dir: ""parentNode"", next: ""legend"" }); try { H.apply(t = O.call(p.childNodes), p.childNodes), t[p.childNodes.length].nodeType } catch (e) { H = { apply: t.length ? function (e, t) { L.apply(e, O.call(t)) } : function (e, t) { var n = e.length, r = 0; while (e[n++] = t[r++]); e.length = n - 1 } } } function se(t, e, n, r) { var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e ? e.nodeType : 9; if (n = n || [], ""string"" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n; if (!r && (T(e), e = e || C, E)) { if (11 !== p && (u = Z.exec(t))) if (i = u[1]) { if (9 === p) { if (!"|data_input/cargotracker/cargotracker.txt|a5e8dc25073f4b1dbb768d6f9bcb87eb
"(a = e.getElementById(i))) return n; if (a.id === i) return n.push(a), n } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n } else { if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n; if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n } if (d.qsa && !N[t + "" ""] && (!v || !v.test(t)) && (1 !== p || ""object"" !== e.nodeName.toLowerCase())) { if (c = t, f = e, 1 === p && (U.test(t) || z.test(t))) { (f = ee.test(t) && ye(e.parentNode) || e) === e && d.scope || ((s = e.getAttribute(""id"")) ? s = s.replace(re, ie) : e.setAttribute(""id"", s = S)), o = (l = h(t)).length; while (o--) l[o] = (s ? ""#"" + s : "":scope"") + "" "" + xe(l[o]); c = l.join("","") } try { return H.apply(n, f.querySelectorAll(c)), n } catch (e) { N(t, !0) } finally { s === S && e.removeAttribute(""id"") } } } return g(t.replace($, ""$1""), e, n, r) } function ue() { var r = []; return function e(t, n) { return r.push(t + "" "") > b.cacheLength && delete e[r.shift()], e[t + "" ""] = n } } function le(e) { return e[S] = !0, e } function ce(e) { var t = C.createElement(""fieldset""); try { return !"|data_input/cargotracker/cargotracker.txt|708331fb00ed485690fdbb5820eea3be
"!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } } function fe(e, t) { var n = e.split(""|""), r = n.length; while (r--) b.attrHandle[n[r]] = t } function pe(e, t) { var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return -1; return e ? 1 : -1 } function de(t) { return function (e) { return ""input"" === e.nodeName.toLowerCase() && e.type === t } } function he(n) { return function (e) { var t = e.nodeName.toLowerCase(); return (""input"" === t || ""button"" === t) && e.type === n } } function ge(t) { return function (e) { return ""form"" in e ? e.parentNode && !1 === e.disabled ? ""label"" in e ? ""label"" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : ""label"" in e && e.disabled === t } } function ve(a) { return le(function (o) { return o = +o, le(function (e, t) { var n, r = a([], e.length, o), i = r.length; while (i--) e[n = r[i]] && (e[n] = ! (t[n] = e[n])) }) }) } function ye(e) { return e && ""undefined"" != typeof e.getElementsByTagName && e } for (e in d = se.support = {}, i = se.isXML = function (e) { var t = e.namespaceURI, n = (e.ownerDocument || e).documentElement; return !Y.test(t || n && n.nodeName || ""HTML"") }, T = se.setDocument = function (e) { var t, n, r = e ?"|data_input/cargotracker/cargotracker.txt|91bfeb5c9d5e48d0a0a12dcd6a9e4a9f
"e.ownerDocument || e : p; return r != C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), p != C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener(""unload"", oe, !1) : n.attachEvent && n.attachEvent(""onunload"", oe)), d.scope = ce(function (e) { return a.appendChild(e).appendChild(C.createElement(""div"")), ""undefined"" != typeof e.querySelectorAll && !e.querySelectorAll("":scope fieldset div"").length }), d.attributes = ce(function (e) { return e.className = ""i"", !e.getAttribute(""className"") }), d.getElementsByTagName = ce(function (e) { return e.appendChild(C.createComment("""")), !e.getElementsByTagName(""*"").length }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function (e) { return a.appendChild(e).id = S, !C.getElementsByName || !C.getElementsByName(S).length }), d.getById ? (b.filter.ID = function (e) { var t = e.replace(te, ne); return function (e) { return e.getAttribute(""id"") === t } }, b.find.ID = function (e, t) { if (""undefined"" != typeof t.getElementById && E) { var n = t.getElementById(e); return n ?"|data_input/cargotracker/cargotracker.txt|be1cdb4758474c92ad498e98f38a7fe0
"[n] : [] } }) : (b.filter.ID = function (e) { var n = e.replace(te, ne); return function (e) { var t = ""undefined"" != typeof e.getAttributeNode && e.getAttributeNode(""id""); return t && t.value === n } }, b.find.ID = function (e, t) { if (""undefined"" != typeof t.getElementById && E) { var n, r, i, o = t.getElementById(e); if (o) { if ((n = o.getAttributeNode(""id"")) && n.value === e) return [o]; i = t.getElementsByName(e), r = 0; while (o = i[r++]) if ((n = o.getAttributeNode(""id"")) && n.value === e) return [o] } return [] } }), b.find.TAG = d.getElementsByTagName ? function (e, t) { return ""undefined"" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0 } : function (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName(e); if (""*"" === e) { while (n = o[i++]) 1 === n.nodeType && r.push(n); return r } return o }, b.find.CLASS = d.getElementsByClassName && function (e, t) { if (""undefined"" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e) }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function (e) { var t; a.appendChild(e).innerHTML = ""<a id='"" + S + ""'></a><select id='"" + S + ""-\r\\' msallowcapture=''><option selected=''></option></select>"", e.querySelectorAll(""[msallowcapture^='']"").length && v.push(""[*^$]="" + M + ""*(? :''|\""\"")""), e.querySelectorAll(""[selected]"").length || v.push(""\\["" + M + ""*(?"|data_input/cargotracker/cargotracker.txt|3c326474d0674b31b9a2042a87ec2286
":value|"" + R + "")""), e.querySelectorAll(""[id~="" + S + ""-]"").length || v.push(""~=""), (t = C.createElement(""input"")).setAttribute(""name"", """"), e.appendChild(t), e.querySelectorAll(""[name='']"").length || v.push(""\\["" + M + ""*name"" + M + ""*="" + M + ""*(? :''|\""\"")""), e.querySelectorAll("":checked"").length || v.push("":checked""), e.querySelectorAll(""a#"" + S + ""+*"").length || v.push("".#.+[+~]""), e.querySelectorAll(""\\\f""), v.push(""[\\r\\n\\f]"") }), ce(function (e) { e.innerHTML = ""<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>""; var t = C.createElement(""input""); t.setAttribute(""type"", ""hidden""), e.appendChild(t).setAttribute(""name"", ""D""), e.querySelectorAll(""[name=d]"").length && v.push(""name"" + M + ""*[*^$|!~]?=""), 2 !== e.querySelectorAll("":enabled"").length && v.push("":enabled"", "":disabled""), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll("":disabled"").length && v.push("":enabled"", "":disabled""), e.querySelectorAll(""*,:x""), v.push("",. *:"") })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function (e) { d.disconnectedMatch = c.call(e, ""*""), c.call(e, ""[s!='']:x""), s.push(""!="", F) }), v = v.length && new RegExp(v.join(""|"")), s = s.length && new RegExp(s.join(""|"")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function (e, t) { var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode; return e === r || !"|data_input/cargotracker/cargotracker.txt|0dc443a9a4dc4958900a2e8687fd4b88
"(!r || 1 !== r.nodeType || ! (n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))) } : function (e, t) { if (t) while (t = t.parentNode) if (t === e) return !0; return !1 }, D = t ? function (e, t) { if (e === t) return l = !0, 0; var n = !e.compareDocumentPosition - !t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e == C || e.ownerDocument == p && y(p, e) ? -1 : t == C || t.ownerDocument == p && y(p, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1) } : function (e, t) { if (e === t) return l = !0, 0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (!i || !o) return e == C ? -1 : t == C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0; if (i === o) return pe(e, t); n = e; while (n = n.parentNode) a.unshift(n); n = t; while (n = n.parentNode) s.unshift(n); while (a[r] === s[r]) r++; return r ? pe(a[r], s[r]) : a[r] == p ? -1 : s[r] == p ?"|data_input/cargotracker/cargotracker.txt|985c1b34170c4056acde1d30d5a679c2
"1 : 0 }), C }, se.matches = function (e, t) { return se(e, null, null, t) }, se.matchesSelector = function (e, t) { if (T(e), d.matchesSelector && E && !N[t + "" ""] && (!s || !s.test(t)) && (!v || !v.test(t))) try { var n = c.call(e, t); if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n } catch (e) { N(t, !0) } return 0 < se(t, C, null, [e]).length }, se.contains = function (e, t) { return (e.ownerDocument || e) != C && T(e), y(e, t) }, se.attr = function (e, t) { (e.ownerDocument || e) != C && T(e); var n = b.attrHandle[t.toLowerCase()], r = n && j.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0; return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ?"|data_input/cargotracker/cargotracker.txt|b27f6555bc024e6face5a6383a5d8113
"r.value : null }, se.escape = function (e) { return (e + """").replace(re, ie) }, se.error = function (e) { throw new Error(""Syntax error, unrecognized expression: "" + e) }, se.uniqueSort = function (e) { var t, n = [], r = 0, i = 0; if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(D), l) { while (t = e[i++]) t === e[i] && (r = n.push(i)); while (r--) e.splice(n[r], 1) } return u = null, e }, o = se.getText = function (e) { var t, n = """", r = 0, i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) { if (""string"" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += o(e) } else if (3 === i || 4 === i) return e.nodeValue } else while (t = e[r++]) n += o(t); return n }, (b = se.selectors = { cacheLength: 50, createPseudo: le, match: G, attrHandle: {}, find: {}, relative: { "">"": { dir: ""parentNode"", first: !0 }, "" "": { dir: ""parentNode"" }, ""+"": { dir: ""previousSibling"", first: !0 }, ""~"": { dir: ""previousSibling"" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || """").replace(te, ne), ""~="" === e[2] && (e[3] = "" "" + e[3] + "" ""), e.slice(0, 4) }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), ""nth"" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ?"|data_input/cargotracker/cargotracker.txt|6159e9bf293f4fc7bbf0ab51f2baf806
"e[5] + (e[6] || 1) : 2 * (""even"" === e[3] || ""odd"" === e[3])), e[5] = +(e[7] + e[8] || ""odd"" === e[3])) : e[3] && se.error(e[0]), e }, PSEUDO: function (e) { var t, n = !e[6] && e[2]; return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || """" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf("")"", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function (e) { var t = e.replace(te, ne).toLowerCase(); return ""*"" === e ? function () { return !0 } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t } }, CLASS: function (e) { var t = m[e + "" ""]; return t || (t = new RegExp(""(^|"" + M + "")"" + e + ""("" + M + ""|$)"")) && m(e, function (e) { return t.test(""string"" == typeof e.className && e.className || ""undefined"" != typeof e.getAttribute && e.getAttribute(""class"") || """") }) }, ATTR: function (n, r, i) { return function (e) { var t = se.attr(e, n); return null == t ? ""!="" === r : !r || (t += """", ""="" === r ? t === i : ""!="" === r ? t !== i : ""^="" === r ? i && 0 === t.indexOf(i) : ""*="" === r ? i && -1 < t.indexOf(i) : ""$="" === r ? i && t.slice(-i.length) === i : ""~="" === r ? -1 < ("" "" + t.replace(B, "" "") + "" "").indexOf(i) : ""|="" === r && (t === i || t.slice(0, i.length + 1) === i + ""-"")) } }, CHILD: function (h, e, t, g, v) { var y = ""nth"" !== h.slice(0, 3), m = ""last"" !== h.slice(-4), x = ""of-type"" === e; return 1 === g && 0 === v ? function (e) { return !"|data_input/cargotracker/cargotracker.txt|fec7f3dede794b65978be01314d987c7
"!e.parentNode } : function (e, t, n) { var r, i, o, a, s, u, l = y !== m ? ""nextSibling"" : ""previousSibling"", c = e.parentNode, f = x && e.nodeName.toLowerCase(), p = !n && !x, d = !1; if (c) { if (y) { while (l) { a = e; while (a = a[l]) if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1; u = l = ""only"" === h && !u && ""nextSibling"" } return !0 } if (u = [m ? c.firstChild : c.lastChild], m && p) { d = (s = (r = (i = (o = (a = c)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]) && r[2], a = s && c.childNodes[s]; while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if (1 === a.nodeType && ++d && a === e) { i[h] = [k, s, d]; break } } else if (p && (d = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]), !1 === d) while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [k, d]), a === e)) break; return (d -= v) === g || d % g == 0 && 0 <= d / g } } }, PSEUDO: function (e, o) { var t, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error(""unsupported pseudo: "" + e); return a[S] ? a(o) : 1 < a.length ? (t = [e, e, """", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function (e, t) { var n, r = a(e, o), i = r.length; while (i--) e[n = P(e, r[i])] = !"|data_input/cargotracker/cargotracker.txt|0f296f7446ce491cbffa261e3ffc1e5a
"(t[n] = r[i]) }) : function (e) { return a(e, 0, t) }) : a } }, pseudos: { not: le(function (e) { var r = [], i = [], s = f(e.replace($, ""$1"")); return s[S] ? le(function (e, t, n, r) { var i, o = s(e, null, r, []), a = e.length; while (a--) (i = o[a]) && (e[a] = ! (t[a] = i)) }) : function (e, t, n) { return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop() } }), has: le(function (t) { return function (e) { return 0 < se(t, e).length } }), contains: le(function (t) { return t = t.replace(te, ne), function (e) { return -1 < (e.textContent || o(e)).indexOf(t) } }), lang: le(function (n) { return V.test(n || """") || se.error(""unsupported lang: "" + n), n = n.replace(te, ne).toLowerCase(), function (e) { var t; do { if (t = E ? e.lang : e.getAttribute(""xml:lang"") || e.getAttribute(""lang"")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + ""-"") } while ((e = e.parentNode) && 1 === e.nodeType); return !1 } }), target: function (e) { var t = n.location && n.location.hash; return t && t.slice(1) === e.id }, root: function (e) { return e === a }, focus: function (e) { return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && ! ! (e.type || e.href || ~e.tabIndex) }, enabled: ge(!1), disabled: ge(!0), checked: function (e) { var t = e.nodeName.toLowerCase(); return ""input"" === t && ! !e.checked || ""option"" === t && !"|data_input/cargotracker/cargotracker.txt|5db40c4d2a1c493397f429fe41bd924c
"!e.selected }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1; return !0 }, parent: function (e) { return !b.pseudos.empty(e) }, header: function (e) { return J.test(e.nodeName) }, input: function (e) { return Q.test(e.nodeName) }, button: function (e) { var t = e.nodeName.toLowerCase(); return ""input"" === t && ""button"" === e.type || ""button"" === t }, text: function (e) { var t; return ""input"" === e.nodeName.toLowerCase() && ""text"" === e.type && (null == (t = e.getAttribute(""type"")) || ""text"" === t.toLowerCase()) }, first: ve(function () { return [0] }), last: ve(function (e, t) { return [t - 1] }), eq: ve(function (e, t, n) { return [n < 0 ? n + t : n] }), even: ve(function (e, t) { for (var n = 0; n < t; n += 2)e.push(n); return e }), odd: ve(function (e, t) { for (var n = 1; n < t; n += 2)e.push(n); return e }), lt: ve(function (e, t, n) { for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;)e.push(r); return e }), gt: ve(function (e, t, n) { for (var r = n < 0 ?"|data_input/cargotracker/cargotracker.txt|9e22b78fc11d4cb0b7d8b0c5da99b258
"n + t : n; ++r < t;)e.push(r); return e }) } }).pseudos.nth = b.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) b.pseudos[e] = de(e); for (e in { submit: !0, reset: !0 }) b.pseudos[e] = he(e); function me() { } function xe(e) { for (var t = 0, n = e.length, r = """"; t < n; t++)r += e[t].value; return r } function be(s, e, t) { var u = e.dir, l = e.next, c = l || u, f = t && ""parentNode"" === c, p = r++; return e.first ? function (e, t, n) { while (e = e[u]) if (1 === e.nodeType || f) return s(e, t, n); return !1 } : function (e, t, n) { var r, i, o, a = [k, p]; if (n) { while (e = e[u]) if ((1 === e.nodeType || f) && s(e, t, n)) return !0 } else while (e = e[u]) if (1 === e.nodeType || f) if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e; else { if ((r = i[c]) && r[0] === k && r[1] === p) return a[2] = r[2]; if ((i[c] = a)[2] = s(e, t, n)) return !0 } return !1 } } function we(i) { return 1 < i.length ?"|data_input/cargotracker/cargotracker.txt|8e1cea449ac44902b9975ad954f4052a
"function (e, t, n) { var r = i.length; while (r--) if (!i[r](e, t, n)) return !1; return !0 } : i[0] } function Te(e, t, n, r, i) { for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s))); return a } function Ce(d, h, g, v, y, e) { return v && !v[S] && (v = Ce(v)), y && !y[S] && (y = Ce(y, e)), le(function (e, t, n, r) { var i, o, a, s = [], u = [], l = t.length, c = e || function (e, t, n) { for (var r = 0, i = t.length; r < i; r++)se(e, t[r], n); return n }(h || ""*"", n.nodeType ? [n] : n, []), f = !d || !e && h ? c : Te(c, s, d, n, r), p = g ? y || (e ? d : l || v) ? [] : t : f; if (g && g(f, p, n, r), v) { i = Te(p, u), v(i, [], n, r), o = i.length; while (o--) (a = i[o]) && (p[u[o]] = ! (f[u[o]] = a)) } if (e) { if (y || d) { if (y) { i = [], o = p.length; while (o--) (a = p[o]) && i.push(f[o] = a); y(null, p = [], i, r) } o = p.length; while (o--) (a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = ! (t[i] = a)) } } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p) }) } function Ee(e) { for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative["" ""], s = o ? 1 : 0, u = be(function (e) { return e === i }, a, !0), l = be(function (e) { return -1 < P(i, e) }, a, !0), c = [function (e, t, n) { var r = !o && (n || t !== w) || ((i = t).nodeType ?"|data_input/cargotracker/cargotracker.txt|ba4b621b62e54bb5b3d26917fc59b96c
"u(e, t, n) : l(e, t, n)); return i = null, r }]; s < r; s++)if (t = b.relative[e[s].type]) c = [be(we(c), t)]; else { if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) { for (n = ++s; n < r; n++)if (b.relative[e[n].type]) break; return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({ value: "" "" === e[s - 2].type ? ""*"" : """" })).replace($, ""$1""), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e)) } c.push(t) } return we(c) } return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function (e, t) { var n, r, i, o, a, s, u, l = x[e + "" ""]; if (l) return t ? 0 : l.slice(0); a = e, s = [], u = b.preFilter; while (a) { for (o in n && ! (r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({ value: n, type: r[0].replace($, "" "") }), a = a.slice(n.length)), b.filter) ! (r = G[o].exec(a)) || u[o] && ! (r = u[o](r)) || (n = r.shift(), i.push({ value: n, type: o, matches: r }), a = a.slice(n.length)); if (!n) break } return t ? a.length : a ? se.error(e) : x(e, s).slice(0) }, f = se.compile = function (e, t) { var n, v, y, m, x, r, i = [], o = [], a = A[e + "" ""]; if (!a) { t || (t = h(e)), n = t.length; while (n--) (a = Ee(t[n]))[S] ?"|data_input/cargotracker/cargotracker.txt|c4372f1dbd8943338ab4e068577f626d
"i.push(a) : o.push(a); (a = A(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function (e, t, n, r, i) { var o, a, s, u = 0, l = ""0"", c = e && [], f = [], p = w, d = e || x && b.find.TAG(""*"", i), h = k += null == p ? 1 : Math.random() || .1, g = d.length; for (i && (w = t == C || t || i); l !== g && null != (o = d[l]); l++) { if (x && o) { a = 0, t || o.ownerDocument == C || (T(o), n = !E); while (s = v[a++]) if (s(o, t || C, n)) { r.push(o); break } i && (k = h) } m && ((o = !s && o) && u--, e && c.push(o)) } if (u += l, m && l !== u) { a = 0; while (s = y[a++]) s(c, f, t, n); if (e) { if (0 < u) while (l--) c[l] || f[l] || (f[l] = q.call(r)); f = Te(f) } H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r) } return i && (k = h, w = p), c }, m ? le(r) : r))).selector = e } return a }, g = se.select = function (e, t, n, r) { var i, o, a, s, u, l = ""function"" == typeof e && e, c = !r && h(e = l.selector || e); if (n = n || [], 1 === c.length) { if (2 < (o = c[0] = c[0].slice(0)).length && ""ID"" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) { if (! (t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n; l && (t = t.parentNode), e = e.slice(o.shift().value.length) } i = G.needsContext.test(e) ? 0 : o.length; while (i--) { if (a = o[i], b.relative[s = a.type]) break; if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) { if (o.splice(i, 1), !"|data_input/cargotracker/cargotracker.txt|0561b9a340f547388deb4d56f77ae198
"(e = r.length && xe(o))) return H.apply(n, r), n; break } } } return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n }, d.sortStable = S.split("""").sort(D).join("""") === S, d.detectDuplicates = ! !l, T(), d.sortDetached = ce(function (e) { return 1 & e.compareDocumentPosition(C.createElement(""fieldset"")) }), ce(function (e) { return e.innerHTML = ""<a href='#'></a>"", ""#"" === e.firstChild.getAttribute(""href"") }) || fe(""type|href|height|width"", function (e, t, n) { if (!n) return e.getAttribute(t, ""type"" === t.toLowerCase() ? 1 : 2) }), d.attributes && ce(function (e) { return e.innerHTML = ""<input/>"", e.firstChild.setAttribute(""value"", """"), """" === e.firstChild.getAttribute(""value"") }) || fe(""value"", function (e, t, n) { if (!n && ""input"" === e.nodeName.toLowerCase()) return e.defaultValue }), ce(function (e) { return null == e.getAttribute(""disabled"") }) || fe(R, function (e, t, n) { var r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ?"|data_input/cargotracker/cargotracker.txt|aa84dfda58584432a98cde4f3bb14e89
"r.value : null }), se }(C); S.find = d, S.expr = d.selectors, S.expr["":""] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape; var h = function (e, t, n) { var r = [], i = void 0 !== n; while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) { if (i && S(e).is(n)) break; r.push(e) } return r }, T = function (e, t) { for (var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e); return n }, k = S.expr.match.needsContext; function A(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() } var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(? :<\/\1>|)$/i; function D(e, n, r) { return m(n) ? S.grep(e, function (e, t) { return ! !n.call(e, t, e) !== r }) : n.nodeType ? S.grep(e, function (e) { return e === n !== r }) : ""string"" != typeof n ? S.grep(e, function (e) { return -1 < i.call(n, e) !== r }) : S.filter(n, e, r) } S.filter = function (e, t, n) { var r = t[0]; return n && (e = "":not("" + e + "")""), 1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ?"|data_input/cargotracker/cargotracker.txt|cf38247e441e49bfa2c3159ca4a1729c
"[r] : [] : S.find.matches(e, S.grep(t, function (e) { return 1 === e.nodeType })) }, S.fn.extend({ find: function (e) { var t, n, r = this.length, i = this; if (""string"" != typeof e) return this.pushStack(S(e).filter(function () { for (t = 0; t < r; t++)if (S.contains(i[t], this)) return !0 })); for (n = this.pushStack([]), t = 0; t < r; t++)S.find(e, i[t], n); return 1 < r ? S.uniqueSort(n) : n }, filter: function (e) { return this.pushStack(D(this, e || [], !1)) }, not: function (e) { return this.pushStack(D(this, e || [], !0)) }, is: function (e) { return ! !D(this, ""string"" == typeof e && k.test(e) ? S(e) : e || [], !1).length } }); var j, q = /^(? :\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (S.fn.init = function (e, t, n) { var r, i; if (!e) return this; if (n = n || j, ""string"" == typeof e) { if (! (r = ""<"" === e[0] && "">"" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : q.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (r[1]) { if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), N.test(r[1]) && S.isPlainObject(t)) for (r in t) m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]); return this } return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this } return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this) }).prototype = S.fn, j = S(E); var L = /^(?:parents|prev(?"|data_input/cargotracker/cargotracker.txt|bfbc117bd1f745e2a4d50fec5d8e1610
":Until|All))/, H = { children: !0, contents: !0, next: !0, prev: !0 }; function O(e, t) { while ((e = e[t]) && 1 !== e.nodeType); return e } S.fn.extend({ has: function (e) { var t = S(e, this), n = t.length; return this.filter(function () { for (var e = 0; e < n; e++)if (S.contains(this, t[e])) return !0 }) }, closest: function (e, t) { var n, r = 0, i = this.length, o = [], a = ""string"" != typeof e && S(e); if (!k.test(e)) for (; r < i; r++)for (n = this[r]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) { o.push(n); break } return this.pushStack(1 < o.length ? S.uniqueSort(o) : o) }, index: function (e) { return e ? ""string"" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (e, t) { return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t)))) }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }), S.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ?"|data_input/cargotracker/cargotracker.txt|8c7c0f0dd01b45f48f54716698246dd8
"t : null }, parents: function (e) { return h(e, ""parentNode"") }, parentsUntil: function (e, t, n) { return h(e, ""parentNode"", n) }, next: function (e) { return O(e, ""nextSibling"") }, prev: function (e) { return O(e, ""previousSibling"") }, nextAll: function (e) { return h(e, ""nextSibling"") }, prevAll: function (e) { return h(e, ""previousSibling"") }, nextUntil: function (e, t, n) { return h(e, ""nextSibling"", n) }, prevUntil: function (e, t, n) { return h(e, ""previousSibling"", n) }, siblings: function (e) { return T((e.parentNode || {}).firstChild, e) }, children: function (e) { return T(e.firstChild) }, contents: function (e) { return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (A(e, ""template"") && (e = e.content || e), S.merge([], e.childNodes)) } }, function (r, i) { S.fn[r] = function (e, t) { var n = S.map(this, i, e); return ""Until"" !== r.slice(-5) && (t = e), t && ""string"" == typeof t && (n = S.filter(t, n)), 1 < this.length && (H[r] || S.uniqueSort(n), L.test(r) && n.reverse()), this.pushStack(n) } }); var P = /[^\x20\t\r\n\f]+/g; function R(e) { return e } function M(e) { throw e } function I(e, t, n, r) { var i; try { e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r)) } catch (e) { n.apply(void 0, [e]) } } S.Callbacks = function (r) { var e, n; r = ""string"" == typeof r ?"|data_input/cargotracker/cargotracker.txt|5f53119b581641b4963faf1ec761aad9
text|source|chunk_id
"(e = r, n = {}, S.each(e.match(P) || [], function (e, t) { n[t] = !0 }), n) : S.extend({}, r); var i, t, o, a, s = [], u = [], l = -1, c = function () { for (a = a || r.once, o = i = !0; u.length; l = -1) { t = u.shift(); while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1) } r.memory || (t = !1), i = !1, a && (s = t ? [] : """") }, f = { add: function () { return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) { S.each(e, function (e, t) { m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && ""string"" !== w(t) && n(t) }) }(arguments), t && !i && c()), this }, remove: function () { return S.each(arguments, function (e, t) { var n; while (-1 < (n = S.inArray(t, s, n))) s.splice(n, 1), n <= l && l-- }), this }, has: function (e) { return e ? -1 < S.inArray(e, s) : 0 < s.length }, empty: function () { return s && (s = []), this }, disable: function () { return a = u = [], s = t = """", this }, disabled: function () { return !s }, lock: function () { return a = u = [], t || i || (s = t = """"), this }, locked: function () { return ! !a }, fireWith: function (e, t) { return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this }, fire: function () { return f.fireWith(this, arguments), this }, fired: function () { return !"|data_input/cargotracker/cargotracker.txt|4481a1b929364735a288013ce3604c63
"!o } }; return f }, S.extend({ Deferred: function (e) { var o = [[""notify"", ""progress"", S.Callbacks(""memory""), S.Callbacks(""memory""), 2], [""resolve"", ""done"", S.Callbacks(""once memory""), S.Callbacks(""once memory""), 0, ""resolved""], [""reject"", ""fail"", S.Callbacks(""once memory""), S.Callbacks(""once memory""), 1, ""rejected""]], i = ""pending"", a = { state: function () { return i }, always: function () { return s.done(arguments).fail(arguments), this }, ""catch"": function (e) { return a.then(null, e) }, pipe: function () { var i = arguments; return S.Deferred(function (r) { S.each(o, function (e, t) { var n = m(i[t[4]]) && i[t[4]]; s[t[1]](function () { var e = n && n.apply(this, arguments); e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + ""With""](this, n ? [e] : arguments) }) }), i = null }).promise() }, then: function (t, n, r) { var u = 0; function l(i, o, a, s) { return function () { var n = this, r = arguments, e = function () { var e, t; if (! (i < u)) { if ((e = a.apply(n, r)) === o.promise()) throw new TypeError(""Thenable self-resolution""); t = e && (""object"" == typeof e || ""function"" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, R, s), l(u, o, M, s)) : (u++, t.call(e, l(u, o, R, s), l(u, o, M, s), l(u, o, R, o.notifyWith))) : (a !== R && (n = void 0, r = [e]), (s || o.resolveWith)(n, r)) } }, t = s ?"|data_input/cargotracker/cargotracker.txt|bf2dd46f5ef54c98b29603d60bf9cbd5
"e : function () { try { e() } catch (e) { S.Deferred.exceptionHook && S.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== M && (n = void 0, r = [e]), o.rejectWith(n, r)) } }; i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t)) } } return S.Deferred(function (e) { o[0][3].add(l(0, e, m(r) ? r : R, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : R)), o[2][3].add(l(0, e, m(n) ? n : M)) }).promise() }, promise: function (e) { return null != e ? S.extend(e, a) : a } }, s = {}; return S.each(o, function (e, t) { var n = t[2], r = t[5]; a[t[1]] = n.add, r && n.add(function () { i = r }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function () { return s[t[0] + ""With""](this === s ? void 0 : this, arguments), this }, s[t[0] + ""With""] = n.fireWith }), a.promise(s), e && e.call(s, s), s }, when: function (e) { var n = arguments.length, t = n, r = Array(t), i = s.call(arguments), o = S.Deferred(), a = function (t) { return function (e) { r[t] = this, i[t] = 1 < arguments.length ?"|data_input/cargotracker/cargotracker.txt|444af44daf5a40909d0f29d75401e91e
"s.call(arguments) : e, --n || o.resolveWith(r, i) } }; if (n <= 1 && (I(e, o.done(a(t)).resolve, o.reject, !n), ""pending"" === o.state() || m(i[t] && i[t].then))) return o.then(); while (t--) I(i[t], a(t), o.reject); return o.promise() } }); var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; S.Deferred.exceptionHook = function (e, t) { C.console && C.console.warn && e && W.test(e.name) && C.console.warn(""jQuery.Deferred exception: "" + e.message, e.stack, t) }, S.readyException = function (e) { C.setTimeout(function () { throw e }) }; var F = S.Deferred(); function B() { E.removeEventListener(""DOMContentLoaded"", B), C.removeEventListener(""load"", B), S.ready() } S.fn.ready = function (e) { return F.then(e)[""catch""](function (e) { S.readyException(e) }), this }, S.extend({ isReady: !1, readyWait: 1, ready: function (e) { (!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || F.resolveWith(E, [S]) } }), S.ready.then = F.then, ""complete"" === E.readyState || ""loading"" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener(""DOMContentLoaded"", B), C.addEventListener(""load"", B)); var $ = function (e, t, n, r, i, o, a) { var s = 0, u = e.length, l = null == n; if (""object"" === w(n)) for (s in i = !0, n) $(e, t, s, n[s], !0, o, a); else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ?"|data_input/cargotracker/cargotracker.txt|d0e933bf236a4671b145ee8844273f3d
"(t.call(e, r), t = null) : (l = t, t = function (e, t, n) { return l.call(S(e), n) })), t)) for (; s < u; s++)t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : l ? t.call(e) : u ? t(e[0], n) : o }, _ = /^-ms-/, z = /-([a-z])/g; function U(e, t) { return t.toUpperCase() } function X(e) { return e.replace(_, ""ms-"").replace(z, U) } var V = function (e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType }; function G() { this.expando = S.expando + G.uid++ } G.uid = 1, G.prototype = { cache: function (e) { var t = e[this.expando]; return t || (t = {}, V(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t }, set: function (e, t, n) { var r, i = this.cache(e); if (""string"" == typeof t) i[X(t)] = n; else for (r in t) i[X(r)] = t[r]; return i }, get: function (e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)] }, access: function (e, t, n) { return void 0 === t || t && ""string"" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t) }, remove: function (e, t) { var n, r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in r ? [t] : t.match(P) || []).length; while (n--) delete r[t[n]] } (void 0 === t || S.isEmptyObject(r)) && (e.nodeType ?"|data_input/cargotracker/cargotracker.txt|c44b54cc8ca14abea6fcf6b64aaccaf5
"e[this.expando] = void 0 : delete e[this.expando]) } }, hasData: function (e) { var t = e[this.expando]; return void 0 !== t && !S.isEmptyObject(t) } }; var Y = new G, Q = new G, J = /^(? :\{[\w\W]*\}|\[[\w\W]*\])$/, K = /[A-Z]/g; function Z(e, t, n) { var r, i; if (void 0 === n && 1 === e.nodeType) if (r = ""data-"" + t.replace(K, ""-$&"").toLowerCase(), ""string"" == typeof (n = e.getAttribute(r))) { try { n = ""true"" === (i = n) || ""false"" !== i && (""null"" === i ? null : i === +i + """" ? +i : J.test(i) ? JSON.parse(i) : i) } catch (e) { } Q.set(e, t, n) } else n = void 0; return n } S.extend({ hasData: function (e) { return Q.hasData(e) || Y.hasData(e) }, data: function (e, t, n) { return Q.access(e, t, n) }, removeData: function (e, t) { Q.remove(e, t) }, _data: function (e, t, n) { return Y.access(e, t, n) }, _removeData: function (e, t) { Y.remove(e, t) } }), S.fn.extend({ data: function (n, e) { var t, r, i, o = this[0], a = o && o.attributes; if (void 0 === n) { if (this.length && (i = Q.get(o), 1 === o.nodeType && !Y.get(o, ""hasDataAttrs""))) { t = a.length; while (t--) a[t] && 0 === (r = a[t].name).indexOf(""data-"") && (r = X(r.slice(5)), Z(o, r, i[r])); Y.set(o, ""hasDataAttrs"", !0) } return i } return ""object"" == typeof n ? this.each(function () { Q.set(this, n) }) : $(this, function (e) { var t; if (o && void 0 === e) return void 0 !== (t = Q.get(o, n)) ? t : void 0 !== (t = Z(o, n)) ?"|data_input/cargotracker/cargotracker.txt|f2739599e0dc4965a1808bc067b28ed0
"t : void 0; this.each(function () { Q.set(this, n, e) }) }, null, e, 1 < arguments.length, null, !0) }, removeData: function (e) { return this.each(function () { Q.remove(this, e) }) } }), S.extend({ queue: function (e, t, n) { var r; if (e) return t = (t || ""fx"") + ""queue"", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, S.makeArray(n)) : r.push(n)), r || [] }, dequeue: function (e, t) { t = t || ""fx""; var n = S.queue(e, t), r = n.length, i = n.shift(), o = S._queueHooks(e, t); ""inprogress"" === i && (i = n.shift(), r--), i && (""fx"" === t && n.unshift(""inprogress""), delete o.stop, i.call(e, function () { S.dequeue(e, t) }, o)), !r && o && o.empty.fire() }, _queueHooks: function (e, t) { var n = t + ""queueHooks""; return Y.get(e, n) || Y.access(e, n, { empty: S.Callbacks(""once memory"").add(function () { Y.remove(e, [t + ""queue"", n]) }) }) } }), S.fn.extend({ queue: function (t, n) { var e = 2; return ""string"" != typeof t && (n = t, t = ""fx"", e--), arguments.length < e ? S.queue(this[0], t) : void 0 === n ?"|data_input/cargotracker/cargotracker.txt|63289aff5c1d45f0b8d0cb736309c306
"this : this.each(function () { var e = S.queue(this, t, n); S._queueHooks(this, t), ""fx"" === t && ""inprogress"" !== e[0] && S.dequeue(this, t) }) }, dequeue: function (e) { return this.each(function () { S.dequeue(this, e) }) }, clearQueue: function (e) { return this.queue(e || ""fx"", []) }, promise: function (e, t) { var n, r = 1, i = S.Deferred(), o = this, a = this.length, s = function () { --r || i.resolveWith(o, [o]) }; ""string"" != typeof e && (t = e, e = void 0), e = e || ""fx""; while (a--) (n = Y.get(o[a], e + ""queueHooks"")) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t) } }); var ee = /[+-]?(?:\d*\.|)\d+(? :[eE][+-]?\d+|)/.source, te = new RegExp(""^(? :([+-])=|)("" + ee + "")([a-z%]*)$"", ""i""), ne = [""Top"", ""Right"", ""Bottom"", ""Left""], re = E.documentElement, ie = function (e) { return S.contains(e.ownerDocument, e) }, oe = { composed: !0 }; re.getRootNode && (ie = function (e) { return S.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument }); var ae = function (e, t) { return ""none"" === (e = t || e).style.display || """" === e.style.display && ie(e) && ""none"" === S.css(e, ""display"") }; function se(e, t, n, r) { var i, o, a = 20, s = r ? function () { return r.cur() } : function () { return S.css(e, t, """") }, u = s(), l = n && n[3] || (S.cssNumber[t] ? """""|data_input/cargotracker/cargotracker.txt|817801c7d108425fab2d2253d824d1b7
": ""px""), c = e.nodeType && (S.cssNumber[t] || ""px"" !== l && +u) && te.exec(S.css(e, t)); if (c && c[3] !== l) { u /= 2, l = l || c[3], c = +u || 1; while (a--) S.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o; c *= 2, S.style(e, t, c + l), n = n || [] } return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i } var ue = {}; function le(e, t) { for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)(r = e[c]).style && (n = r.style.display, t ? (""none"" === n && (l[c] = Y.get(r, ""display"") || null, l[c] || (r.style.display = """")), """" === r.style.display && ae(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ue[s]) || (o = a.body.appendChild(a.createElement(s)), u = S.css(o, ""display""), o.parentNode.removeChild(o), ""none"" === u && (u = ""block""), ue[s] = u)))) : ""none"" !== n && (l[c] = ""none"", Y.set(r, ""display"", n))); for (c = 0; c < f; c++)null != l[c] && (e[c].style.display = l[c]); return e } S.fn.extend({ show: function () { return le(this, !0) }, hide: function () { return le(this) }, toggle: function (e) { return ""boolean"" == typeof e ? e ? this.show() : this.hide() : this.each(function () { ae(this) ? S(this).show() : S(this).hide() }) } }); var ce, fe, pe = /^(? :checkbox|radio)$/i, de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, he = /^$|^module$|\/(?"|data_input/cargotracker/cargotracker.txt|2d821ffc8e0f4a7b81de47fc48a0fff6
":java|ecma)script/i; ce = E.createDocumentFragment().appendChild(E.createElement(""div"")), (fe = E.createElement(""input"")).setAttribute(""type"", ""radio""), fe.setAttribute(""checked"", ""checked""), fe.setAttribute(""name"", ""t""), ce.appendChild(fe), y.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked, ce.innerHTML = ""<textarea>x</textarea>"", y.noCloneChecked = ! !ce.cloneNode(!0).lastChild.defaultValue, ce.innerHTML = ""<option></option>"", y.option = ! !ce.lastChild; var ge = { thead: [1, ""<table>"", ""</table>""], col: [2, ""<table><colgroup>"", ""</colgroup></table>""], tr: [2, ""<table><tbody>"", ""</tbody></table>""], td: [3, ""<table><tbody><tr>"", ""</tr></tbody></table>""], _default: [0, """", """"] }; function ve(e, t) { var n; return n = ""undefined"" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || ""*"") : ""undefined"" != typeof e.querySelectorAll ? e.querySelectorAll(t || ""*"") : [], void 0 === t || t && A(e, t) ? S.merge([e], n) : n } function ye(e, t) { for (var n = 0, r = e.length; n < r; n++)Y.set(e[n], ""globalEval"", !t || Y.get(t[n], ""globalEval"")) } ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, ""<select multiple='multiple'>"", ""</select>""]); var me = /<|&#?\w+;/; function xe(e, t, n, r, i) { for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)if ((o = e[d]) || 0 === o) if (""object"" === w(o)) S.merge(p, o.nodeType ?"|data_input/cargotracker/cargotracker.txt|fe57c6ec97034e9a92a16df46ac2b381
"[o] : o); else if (me.test(o)) { a = a || f.appendChild(t.createElement(""div"")), s = (de.exec(o) || ["""", """"])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + S.htmlPrefilter(o) + u[2], c = u[0]; while (c--) a = a.lastChild; S.merge(p, a.childNodes), (a = f.firstChild).textContent = """" } else p.push(t.createTextNode(o)); f.textContent = """", d = 0; while (o = p[d++]) if (r && -1 < S.inArray(o, r)) i && i.push(o); else if (l = ie(o), a = ve(f.appendChild(o), ""script""), l && ye(a), n) { c = 0; while (o = a[c++]) he.test(o.type || """") && n.push(o) } return f } var be = /^key/, we = /^(? :mouse|pointer|contextmenu|drag|drop)|click/, Te = /^([^.]*)(?:\. (.+)|)/; function Ce() { return !0 } function Ee() { return !1 } function Se(e, t) { return e === function () { try { return E.activeElement } catch (e) { } }() == (""focus"" === t) } function ke(e, t, n, r, i, o) { var a, s; if (""object"" == typeof t) { for (s in ""string"" != typeof n && (r = r || n, n = void 0), t) ke(e, s, n, r, t[s], o); return e } if (null == r && null == i ? (i = n, r = n = void 0) : null == i && (""string"" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Ee; else if (!i) return e; return 1 === o && (a = i, (i = function (e) { return S().off(e), a.apply(this, arguments) }).guid = a.guid || (a.guid = S.guid++)), e.each(function () { S.event.add(this, t, i, r, n) }) } function Ae(e, i, o) { o ?"|data_input/cargotracker/cargotracker.txt|94c55b5da4c149caa7c8c423aff23b58
"(Y.set(e, i, !1), S.event.add(e, i, { namespace: !1, handler: function (e) { var t, n, r = Y.get(this, i); if (1 & e.isTrigger && this[i]) { if (r.length) (S.event.special[i] || {}).delegateType && e.stopPropagation(); else if (r = s.call(arguments), Y.set(this, i, r), t = o(this, i), this[i](), r !== (n = Y.get(this, i)) || t ? Y.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n.value } else r.length && (Y.set(this, i, { value: S.event.trigger(S.extend(r[0], S.Event.prototype), r.slice(1), this) }), e.stopImmediatePropagation()) } })) : void 0 === Y.get(e, i) && S.event.add(e, i, Ce) } S.event = { global: {}, add: function (t, e, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Y.get(t); if (V(t)) { n.handler && (n = (o = n).handler, i = o.selector), i && S.find.matchesSelector(re, i), n.guid || (n.guid = S.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function (e) { return ""undefined"" != typeof S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0 }), l = (e = (e || """").match(P) || [""""]).length; while (l--) d = g = (s = Te.exec(e[l]) || [])[1], h = (s[2] || """").split("". "").sort(), d && (f = S.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = S.event.special[d] || {}, c = S.extend({ type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && S.expr.match.needsContext.test(i), namespace:"|data_input/cargotracker/cargotracker.txt|18463cb4487541c1be884e6a2c0da39d
"c = S.extend({ type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && S.expr.match.needsContext.test(i), namespace: h.join(""."")"|data_input/cargotracker/cargotracker.txt|af76baa28d4240d19c7ea1678b73e152
"}, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), S.event.global[d] = !0) } }, remove: function (e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Y.hasData(e) && Y.get(e); if (v && (u = v.events)) { l = (t = (t || """").match(P) || [""""]).length; while (l--) if (d = g = (s = Te.exec(t[l]) || [])[1], h = (s[2] || """").split("". "").sort(), d) { f = S.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp(""(^|\\.)"" + h.join(""\\.(?:.

\\.|)"") + ""(\\.|$)""), a = o = p.length; while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && (""**"" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c)); a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || S.removeEvent(e, d, v.handle), delete u[d]) } else for (d in u) S.event.remove(e, d + t[l], n, r, !0); S.isEmptyObject(u) && Y.remove(e, ""handle events"") } }, dispatch: function (e) { var t, n, r, i, o, a, s = new Array(arguments.length), u = S.event.fix(e), l = (Y.get(this, ""events"") || Object.create(null))[u.type] || [], c = S.event.special[u.type] || {}; for (s[0] = u, t = 1; t < arguments.length;"|data_input/cargotracker/cargotracker.txt|bf797cb817664332b12b0b8a83ccd0d0
"t++)s[t] = arguments[t]; if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) { a = S.event.handlers.call(this, u, l), t = 0; while ((i = a[t++]) && !u.isPropagationStopped()) { u.currentTarget = i.elem, n = 0; while ((o = i.handlers[n++]) && !u.isImmediatePropagationStopped()) u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation())) } return c.postDispatch && c.postDispatch.call(this, u), u.result } }, handlers: function (e, t) { var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType && ! (""click"" === e.type && 1 <= e.button)) for (; l !== this; l = l.parentNode || this)if (1 === l.nodeType && (""click"" !== e.type || !0 !== l.disabled)) { for (o = [], a = {}, n = 0; n < u; n++)void 0 === a[i = (r = t[n]).selector + "" ""] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [l]).length), a[i] && o.push(r); o.length && s.push({ elem: l, handlers: o }) } return l = this, u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s }, addProp: function (t, e) { Object.defineProperty(S.Event.prototype, t, { enumerable: !0, configurable: !0, get: m(e) ?"|data_input/cargotracker/cargotracker.txt|ba1a4c58f98a4d7788ae784481452655
"function () { if (this.originalEvent) return e(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[t] }, set: function (e) { Object.defineProperty(this, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) } }) }, fix: function (e) { return e[S.expando] ? e : new S.Event(e) }, special: { load: { noBubble: !0 }, click: { setup: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, ""input"") && Ae(t, ""click"", Ce), !1 }, trigger: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, ""input"") && Ae(t, ""click""), !0 }, _default: function (e) { var t = e.target; return pe.test(t.type) && t.click && A(t, ""input"") && Y.get(t, ""click"") || A(t, ""a"") } }, beforeunload: { postDispatch: function (e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } } }, S.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n) }, S.Event = function (e, t) { if (! (this instanceof S.Event)) return new S.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Ce : Ee, this.target = e.target && 3 === e.target.nodeType ?"|data_input/cargotracker/cargotracker.txt|450af6c55c5f4f8a9b64b4461bbe3ea2
"e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && S.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[S.expando] = !0 }, S.Event.prototype = { constructor: S.Event, isDefaultPrevented: Ee, isPropagationStopped: Ee, isImmediatePropagationStopped: Ee, isSimulated: !1, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = Ce, e && !this.isSimulated && e.preventDefault() }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = Ce, e && !this.isSimulated && e.stopPropagation() }, stopImmediatePropagation: function () { var e = this.originalEvent; this.isImmediatePropagationStopped = Ce, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation() } }, S.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, ""char"": !0, code: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: function (e) { var t = e.button; return null == e.which && be.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && we.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ?"|data_input/cargotracker/cargotracker.txt|0627f4b8099e4af18560c845e5da7d89
"2 : 0 : e.which } }, S.event.addProp), S.each({ focus: ""focusin"", blur: ""focusout"" }, function (e, t) { S.event.special[e] = { setup: function () { return Ae(this, e, Se), !1 }, trigger: function () { return Ae(this, e), !0 }, delegateType: t } }), S.each({ mouseenter: ""mouseover"", mouseleave: ""mouseout"", pointerenter: ""pointerover"", pointerleave: ""pointerout"" }, function (e, i) { S.event.special[e] = { delegateType: i, bindType: i, handle: function (e) { var t, n = e.relatedTarget, r = e.handleObj; return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t } } }), S.fn.extend({ on: function (e, t, n, r) { return ke(this, e, t, n, r) }, one: function (e, t, n, r) { return ke(this, e, t, n, r, 1) }, off: function (e, t, n) { var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + ""."" + r.namespace : r.origType, r.selector, r.handler), this; if (""object"" == typeof e) { for (i in e) this.off(i, t, e[i]); return this } return !1 !== t && ""function"" != typeof t || (n = t, t = void 0), !1 === n && (n = Ee), this.each(function () { S.event.remove(this, e, n, t) }) } }); var Ne = /<script|<style|<link/i, De = /checked\s*(?:[^=]|=\s*.checked. )/i, je = /^\s*<!(?:\[CDATA\[|--)|(? :\]\]|--)>\s*$/g; function qe(e, t) { return A(e, ""table"") && A(11 !== t.nodeType ?"|data_input/cargotracker/cargotracker.txt|c301458dab4b4a5fa7a1f2f64bdc91a8
"t : t.firstChild, ""tr"") && S(e).children(""tbody"")[0] || e } function Le(e) { return e.type = (null !== e.getAttribute(""type"")) + ""/"" + e.type, e } function He(e) { return ""true/"" === (e.type || """").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute(""type""), e } function Oe(e, t) { var n, r, i, o, a, s; if (1 === t.nodeType) { if (Y.hasData(e) && (s = Y.get(e).events)) for (i in Y.remove(t, ""handle events""), s) for (n = 0, r = s[i].length; n < r; n++)S.event.add(t, i, s[i][n]); Q.hasData(e) && (o = Q.access(e), a = S.extend({}, o), Q.set(t, a)) } } function Pe(n, r, i, o) { r = g(r); var e, t, a, s, u, l, c = 0, f = n.length, p = f - 1, d = r[0], h = m(d); if (h || 1 < f && ""string"" == typeof d && !y.checkClone && De.test(d)) return n.each(function (e) { var t = n.eq(e); h && (r[0] = d.call(this, e, t.html())), Pe(t, r, i, o) }); if (f && (t = (e = xe(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) { for (s = (a = S.map(ve(e, ""script""), Le)).length; c < f; c++)u = e, c !== p && (u = S.clone(u, !0, !0), s && S.merge(a, ve(u, ""script""))), i.call(n[c], u, c); if (s) for (l = a[a.length - 1].ownerDocument, S.map(a, He), c = 0; c < s; c++)u = a[c], he.test(u.type || """") && !Y.access(u, ""globalEval"") && S.contains(l, u) && (u.src && ""module"" !== (u.type || """").toLowerCase() ?"|data_input/cargotracker/cargotracker.txt|3e489abb16ae4e3d9fc07957215ec24f
"S._evalUrl && !u.noModule && S._evalUrl(u.src, { nonce: u.nonce || u.getAttribute(""nonce"") }, l) : b(u.textContent.replace(je, """"), u, l)) } return n } function Re(e, t, n) { for (var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++)n || 1 !== r.nodeType || S.cleanData(ve(r)), r.parentNode && (n && ie(r) && ye(ve(r, ""script"")), r.parentNode.removeChild(r)); return e } S.extend({ htmlPrefilter: function (e) { return e }, clone: function (e, t, n) { var r, i, o, a, s, u, l, c = e.cloneNode(!0), f = ie(e); if (! (y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e))) for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++)s = o[r], u = a[r], void 0, ""input"" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : ""input"" !== l && ""textarea"" !== l || (u.defaultValue = s.defaultValue); if (t) if (n) for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++)Oe(o[r], a[r]); else Oe(e, c); return 0 < (a = ve(c, ""script"")).length && ye(a, !f && ve(e, ""script"")), c }, cleanData: function (e) { for (var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++)if (V(n)) { if (t = n[Y.expando]) { if (t.events) for (r in t.events) i[r] ?"|data_input/cargotracker/cargotracker.txt|6917cacda6aa4162ace1d9171206f5d5
"S.event.remove(n, r) : S.removeEvent(n, r, t.handle); n[Y.expando] = void 0 } n[Q.expando] && (n[Q.expando] = void 0) } } }), S.fn.extend({ detach: function (e) { return Re(this, e, !0) }, remove: function (e) { return Re(this, e) }, text: function (e) { return $(this, function (e) { return void 0 === e ? S.text(this) : this.empty().each(function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) }) }, null, e, arguments.length) }, append: function () { return Pe(this, arguments, function (e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || qe(this, e).appendChild(e) }) }, prepend: function () { return Pe(this, arguments, function (e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = qe(this, e); t.insertBefore(e, t.firstChild) } }) }, before: function () { return Pe(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this) }) }, after: function () { return Pe(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) }) }, empty: function () { for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (S.cleanData(ve(e, !1)), e.textContent = """"); return this }, clone: function (e, t) { return e = null != e && e, t = null == t ?"|data_input/cargotracker/cargotracker.txt|aeeb4c6236204c6180968e01b087700c
"e : t, this.map(function () { return S.clone(this, e, t) }) }, html: function (e) { return $(this, function (e) { var t = this[0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if (""string"" == typeof e && !Ne.test(e) && !ge[(de.exec(e) || ["""", """"])[1].toLowerCase()]) { e = S.htmlPrefilter(e); try { for (; n < r; n++)1 === (t = this[n] || {}).nodeType && (S.cleanData(ve(t, !1)), t.innerHTML = e); t = 0 } catch (e) { } } t && this.empty().append(e) }, null, e, arguments.length) }, replaceWith: function () { var n = []; return Pe(this, arguments, function (e) { var t = this.parentNode; S.inArray(this, n) < 0 && (S.cleanData(ve(this)), t && t.replaceChild(e, this)) }, n) } }), S.each({ appendTo: ""append"", prependTo: ""prepend"", insertBefore: ""before"", insertAfter: ""after"", replaceAll: ""replaceWith"" }, function (e, a) { S.fn[e] = function (e) { for (var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++)t = o === i ? this : this.clone(!0), S(r[o])[a](t), u.apply(n, t.get()); return this.pushStack(n) } }); var Me = new RegExp(""^("" + ee + "")(?"|data_input/cargotracker/cargotracker.txt|47c1ea561d4544b6966c41891e283b3a
"!px)[a-z%]+$"", ""i""), Ie = function (e) { var t = e.ownerDocument.defaultView; return t && t.opener || (t = C), t.getComputedStyle(e) }, We = function (e, t, n) { var r, i, o = {}; for (i in t) o[i] = e.style[i], e.style[i] = t[i]; for (i in r = n.call(e), t) e.style[i] = o[i]; return r }, Fe = new RegExp(ne.join(""|""), ""i""); function Be(e, t, n) { var r, i, o, a, s = e.style; return (n = n || Ie(e)) && ("""" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = S.style(e, t)), !y.pixelBoxStyles() && Me.test(a) && Fe.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ?"|data_input/cargotracker/cargotracker.txt|601ed65a7d974ec29c1b1b9ad97baf7f
"a + """" : a } function $e(e, t) { return { get: function () { if (!e()) return (this.get = t).apply(this, arguments); delete this.get } } } !function () { function e() { if (l) { u.style.cssText = ""position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0"", l.style.cssText = ""position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%"", re.appendChild(u).appendChild(l); var e = C.getComputedStyle(l); n = ""1%"" !== e.top, s = 12 === t(e.marginLeft), l.style.right = ""60%"", o = 36 === t(e.right), r = 36 === t(e.width), l.style.position = ""absolute"", i = 12 === t(l.offsetWidth / 3), re.removeChild(u), l = null } } function t(e) { return Math.round(parseFloat(e)) } var n, r, i, o, a, s, u = E.createElement(""div""), l = E.createElement(""div""); l.style && (l.style.backgroundClip = ""content-box"","|data_input/cargotracker/cargotracker.txt|007596f9a4494beaa7661ddc63a85713
"l.cloneNode(!0).style.backgroundClip = """", y.clearCloneStyle = ""content-box"" === l.style.backgroundClip, S.extend(y, { boxSizingReliable: function () { return e(), r }, pixelBoxStyles: function () { return e(), o }, pixelPosition: function () { return e(), n }, reliableMarginLeft: function () { return e(), s }, scrollboxSize: function () { return e(), i }, reliableTrDimensions: function () { var e, t, n, r; return null == a && (e = E.createElement(""table""), t = E.createElement(""tr""), n = E.createElement(""div""), e.style.cssText = ""position:absolute;left:-11111px"", t.style.height = ""1px"", n.style.height = ""9px"", re.appendChild(e).appendChild(t).appendChild(n), r = C.getComputedStyle(t), a = 3 < parseInt(r.height), re.removeChild(e)), a } })) }(); var _e = [""Webkit"", ""Moz"", ""ms""], ze = E.createElement(""div"").style, Ue = {}; function Xe(e) { var t = S.cssProps[e] || Ue[e]; return t || (e in ze ? e : Ue[e] = function (e) { var t = e[0].toUpperCase() + e.slice(1), n = _e.length; while (n--) if ((e = _e[n] + t) in ze) return e }(e) || e) } var Ve = /^(none|table(? !-c[ea]).+)/, Ge = /^--/, Ye = { position: ""absolute"", visibility: ""hidden"", display: ""block"" }, Qe = { letterSpacing: ""0"", fontWeight: ""400"" }; function Je(e, t, n) { var r = te.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || ""px"") : t } function Ke(e, t, n, r, i, o) { var a = ""width"" === t ? 1 : 0, s = 0, u = 0; if (n === (r ?"|data_input/cargotracker/cargotracker.txt|1e3cbffccdea422687f31bae3037ec9f
"""border"" : ""content"")) return 0; for (; a < 4; a += 2)""margin"" === n && (u += S.css(e, n + ne[a], !0, i)), r ? (""content"" === n && (u -= S.css(e, ""padding"" + ne[a], !0, i)), ""margin"" !== n && (u -= S.css(e, ""border"" + ne[a] + ""Width"", !0, i))) : (u += S.css(e, ""padding"" + ne[a], !0, i), ""padding"" !== n ? u += S.css(e, ""border"" + ne[a] + ""Width"", !0, i) : s += S.css(e, ""border"" + ne[a] + ""Width"", !0, i)); return !r && 0 <= o && (u += Math.max(0, Math.ceil(e[""offset"" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u } function Ze(e, t, n) { var r = Ie(e), i = (!y.boxSizingReliable() || n) && ""border-box"" === S.css(e, ""boxSizing"", !1, r), o = i, a = Be(e, t, r), s = ""offset"" + t[0].toUpperCase() + t.slice(1); if (Me.test(a)) { if (!n) return a; a = ""auto"" } return (!y.boxSizingReliable() && i || !y.reliableTrDimensions() && A(e, ""tr"") || ""auto"" === a || !parseFloat(a) && ""inline"" === S.css(e, ""display"", !1, r)) && e.getClientRects().length && (i = ""border-box"" === S.css(e, ""boxSizing"", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + Ke(e, t, n || (i ? ""border"" : ""content""), o, r, a) + ""px"" } function et(e, t, n, r, i) { return new et.prototype.init(e, t, n, r, i) } S.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = Be(e, ""opacity""); return """" === n ?"|data_input/cargotracker/cargotracker.txt|1211ee2da27f4f80b57d561f389ba6bf
"""1"" : n } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function (e, t, n, r) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var i, o, a, s = X(t), u = Ge.test(t), l = e.style; if (u || (t = Xe(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n) return a && ""get"" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t]; ""string"" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), o = ""number""), null != n && n == n && (""number"" !== o || u || (n += i && i[3] || (S.cssNumber[s] ? """" : ""px"")), y.clearCloneStyle || """" !== n || 0 !== t.indexOf(""background"") || (l[t] = ""inherit""), a && ""set"" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n)) } }, css: function (e, t, n, r) { var i, o, a, s = X(t); return Ge.test(t) || (t = Xe(s)), (a = S.cssHooks[t] || S.cssHooks[s]) && ""get"" in a && (i = a.get(e, !0, n)), void 0 === i && (i = Be(e, t, r)), ""normal"" === i && t in Qe && (i = Qe[t]), """" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ?"|data_input/cargotracker/cargotracker.txt|4f73fe930f2e4ecd8b5ffecf1335b86f
"o || 0 : i) : i } }), S.each([""height"", ""width""], function (e, u) { S.cssHooks[u] = { get: function (e, t, n) { if (t) return !Ve.test(S.css(e, ""display"")) || e.getClientRects().length && e.getBoundingClientRect().width ? Ze(e, u, n) : We(e, Ye, function () { return Ze(e, u, n) }) }, set: function (e, t, n) { var r, i = Ie(e), o = !y.scrollboxSize() && ""absolute"" === i.position, a = (o || n) && ""border-box"" === S.css(e, ""boxSizing"", !1, i), s = n ? Ke(e, u, n, a, i) : 0; return a && o && (s -= Math.ceil(e[""offset"" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - Ke(e, u, ""border"", !1, i) - .5)), s && (r = te.exec(t)) && ""px"" !== (r[3] || ""px"") && (e.style[u] = t, t = S.css(e, u)), Je(0, t, s) } } }), S.cssHooks.marginLeft = $e(y.reliableMarginLeft, function (e, t) { if (t) return (parseFloat(Be(e, ""marginLeft"")) || e.getBoundingClientRect().left - We(e, { marginLeft: 0 }, function () { return e.getBoundingClientRect().left })) + ""px"" }), S.each({ margin: """", padding: """", border: ""Width"" }, function (i, o) { S.cssHooks[i + o] = { expand: function (e) { for (var t = 0, n = {}, r = ""string"" == typeof e ? e.split("" "") : [e]; t < 4; t++)n[i + ne[t] + o] = r[t] || r[t - 2] || r[0]; return n } }, ""margin"" !== i && (S.cssHooks[i + o].set = Je) }), S.fn.extend({ css: function (e, t) { return $(this, function (e, t, n) { var r, i, o = {}, a = 0; if (Array.isArray(t)) { for (r = Ie(e), i = t.length; a < i; a++)o[t[a]] = S.css(e, t[a], !1, r); return o } return void 0 !== n ?"|data_input/cargotracker/cargotracker.txt|3fd9690c528c431e81376b8ebe7ffa00
"S.style(e, t, n) : S.css(e, t) }, e, t, 1 < arguments.length) } }), ((S.Tween = et).prototype = { constructor: et, init: function (e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (S.cssNumber[n] ? """" : ""px"") }, cur: function () { var e = et.propHooks[this.prop]; return e && e.get ? e.get(this) : et.propHooks._default.get(this) }, run: function (e) { var t, n = et.propHooks[this.prop]; return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : et.propHooks._default.set(this), this } }).init.prototype = et.prototype, (et.propHooks = { _default: { get: function (e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, """")) && ""auto"" !== t ? t : 0 }, set: function (e) { S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !S.cssHooks[e.prop] && null == e.elem.style[Xe(e.prop)] ?"|data_input/cargotracker/cargotracker.txt|ac0e6663bd7a4b0fb0b21296eccc16a4
"e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit) } } }).scrollTop = et.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, S.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: ""swing"" }, S.fx = et.prototype.init, S.fx.step = {}; var tt, nt, rt, it, ot = /^(? :toggle|show|hide)$/, at = /queueHooks$/; function st() { nt && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(st) : C.setTimeout(st, S.fx.interval), S.fx.tick()) } function ut() { return C.setTimeout(function () { tt = void 0 }), tt = Date.now() } function lt(e, t) { var n, r = 0, i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t)i[""margin"" + (n = ne[r])] = i[""padding"" + n] = e; return t && (i.opacity = i.width = e), i } function ct(e, t, n) { for (var r, i = (ft.tweeners[t] || []).concat(ft.tweeners[""*""]), o = 0, a = i.length; o < a; o++)if (r = i[o].call(n, t, e)) return r } function ft(o, e, t) { var n, a, r = 0, i = ft.prefilters.length, s = S.Deferred().always(function () { delete u.elem }), u = function () { if (a) return !1; for (var e = tt || ut(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++)l.tweens[r].run(n); return s.notifyWith(o, [l, n, t]), n < 1 && i ?"|data_input/cargotracker/cargotracker.txt|4081008315094fab9bd947726672f4db
"t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1) }, l = s.promise({ elem: o, props: S.extend({}, e), opts: S.extend(!0, { specialEasing: {}, easing: S.easing._default }, t), originalProperties: e, originalOptions: t, startTime: tt || ut(), duration: t.duration, tweens: [], createTween: function (e, t) { var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing); return l.tweens.push(n), n }, stop: function (e) { var t = 0, n = e ? l.tweens.length : 0; if (a) return this; for (a = !0; t < n; t++)l.tweens[t].run(1); return e ?"|data_input/cargotracker/cargotracker.txt|712714777fa2481685f5ebd7cd2ad9af
"(s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this } }), c = l.props; for (!function (e, t) { var n, r, i, o, a; for (n in e) if (i = t[r = X(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && ""expand"" in a) for (n in o = a.expand(o), delete e[r], o) n in e || (e[n] = o[n], t[n] = i); else t[r] = i }(c, l.opts.specialEasing); r < i; r++)if (n = ft.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n; return S.map(c, ct, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), S.fx.timer(S.extend(u, { elem: o, anim: l, queue: l.opts.queue })), l } S.Animation = S.extend(ft, { tweeners: { ""*"": [function (e, t) { var n = this.createTween(e, t); return se(n.elem, e, te.exec(t), n), n }] }, tweener: function (e, t) { m(e) ?"|data_input/cargotracker/cargotracker.txt|7be2b90c8b4a428782b82da3dfe2f537
text|source|chunk_id
"(t = e, e = [""*""]) : e = e.match(P); for (var n, r = 0, i = e.length; r < i; r++)n = e[r], ft.tweeners[n] = ft.tweeners[n] || [], ft.tweeners[n].unshift(t) }, prefilters: [function (e, t, n) { var r, i, o, a, s, u, l, c, f = ""width"" in t || ""height"" in t, p = this, d = {}, h = e.style, g = e.nodeType && ae(e), v = Y.get(e, ""fxshow""); for (r in n.queue || (null == (a = S._queueHooks(e, ""fx"")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () { a.unqueued || s() }), a.unqueued++, p.always(function () { p.always(function () { a.unqueued--, S.queue(e, ""fx"").length || a.empty.fire() }) })), t) if (i = t[r], ot.test(i)) { if (delete t[r], o = o || ""toggle"" === i, i === (g ? ""hide"" : ""show"")) { if (""show"" !== i || !v || void 0 === v[r]) continue; g = !0 } d[r] = v && v[r] || S.style(e, r) } if ((u = !S.isEmptyObject(t)) || !S.isEmptyObject(d)) for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y.get(e, ""display"")), ""none"" === (c = S.css(e, ""display"")) && (l ? c = l : (le([e], !0), l = e.style.display || l, c = S.css(e, ""display""), le([e]))), (""inline"" === c || ""inline-block"" === c && null != l) && ""none"" === S.css(e, ""float"") && (u || (p.done(function () { h.display = l }), null == l && (c = h.display, l = ""none"" === c ? """""|data_input/cargotracker/cargotracker.txt|eac50d940a1640e28f5bb66e0cc3469c
": c)), h.display = ""inline-block"")), n.overflow && (h.overflow = ""hidden"", p.always(function () { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2] })), u = !1, d) u || (v ? ""hidden"" in v && (g = v.hidden) : v = Y.access(e, ""fxshow"", { display: l }), o && (v.hidden = !g), g && le([e], !0), p.done(function () { for (r in g || le([e]), Y.remove(e, ""fxshow""), d) S.style(e, r, d[r]) })), u = ct(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0)) }], prefilter: function (e, t) { t ? ft.prefilters.unshift(e) : ft.prefilters.push(e) } }), S.speed = function (e, t, n) { var r = e && ""object"" == typeof e ? S.extend({}, e) : { complete: n || !n && t || m(e) && e, duration: e, easing: n && t || t && !m(t) && t }; return S.fx.off ? r.duration = 0 : ""number"" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = ""fx""), r.old = r.complete, r.complete = function () { m(r.old) && r.old.call(this), r.queue && S.dequeue(this, r.queue) }, r }, S.fn.extend({ fadeTo: function (e, t, n, r) { return this.filter(ae).css(""opacity"", 0).show().end().animate({ opacity: t }, e, n, r) }, animate: function (t, e, n, r) { var i = S.isEmptyObject(t), o = S.speed(e, n, r), a = function () { var e = ft(this, S.extend({}, t), o); (i || Y.get(this, ""finish"")) && e.stop(!0) }; return a.finish = a, i || !1 === o.queue ?"|data_input/cargotracker/cargotracker.txt|3ae26700d72142fe9514ff426737dc10
"this.each(a) : this.queue(o.queue, a) }, stop: function (i, e, o) { var a = function (e) { var t = e.stop; delete e.stop, t(o) }; return ""string"" != typeof i && (o = e, e = i, i = void 0), e && this.queue(i || ""fx"", []), this.each(function () { var e = !0, t = null != i && i + ""queueHooks"", n = S.timers, r = Y.get(this); if (t) r[t] && r[t].stop && a(r[t]); else for (t in r) r[t] && r[t].stop && at.test(t) && a(r[t]); for (t = n.length; t--;)n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1)); !e && o || S.dequeue(this, i) }) }, finish: function (a) { return !1 !== a && (a = a || ""fx""), this.each(function () { var e, t = Y.get(this), n = t[a + ""queue""], r = t[a + ""queueHooks""], i = S.timers, o = n ? n.length : 0; for (t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;)i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1)); for (e = 0; e < o; e++)n[e] && n[e].finish && n[e].finish.call(this); delete t.finish }) } }), S.each([""toggle"", ""show"", ""hide""], function (e, r) { var i = S.fn[r]; S.fn[r] = function (e, t, n) { return null == e || ""boolean"" == typeof e ?"|data_input/cargotracker/cargotracker.txt|b979fe4d631b4a6c938ea159ce0ce02e
"i.apply(this, arguments) : this.animate(lt(r, !0), e, t, n) } }), S.each({ slideDown: lt(""show""), slideUp: lt(""hide""), slideToggle: lt(""toggle""), fadeIn: { opacity: ""show"" }, fadeOut: { opacity: ""hide"" }, fadeToggle: { opacity: ""toggle"" } }, function (e, r) { S.fn[e] = function (e, t, n) { return this.animate(r, e, t, n) } }), S.timers = [], S.fx.tick = function () { var e, t = 0, n = S.timers; for (tt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || S.fx.stop(), tt = void 0 }, S.fx.timer = function (e) { S.timers.push(e), S.fx.start() }, S.fx.interval = 13, S.fx.start = function () { nt || (nt = !0, st()) }, S.fx.stop = function () { nt = null }, S.fx.speeds = { slow: 600, fast: 200, _default: 400 }, S.fn.delay = function (r, e) { return r"|data_input/cargotracker/cargotracker.txt|cab9fb0a42474b6f8fcd8acc047e01c8
"= S.fx && S.fx.speeds[r] || r, e = e || ""fx"", this.queue(e, function (e, t) { var n = C.setTimeout(e, r); t.stop = function () { C.clearTimeout(n) } }) }, rt = E.createElement(""input""), it = E.createElement(""select"").appendChild(E.createElement(""option"")), rt.type = ""checkbox"", y.checkOn = """" !== rt.value, y.optSelected = it.selected, (rt = E.createElement(""input"")).value = ""t"", rt.type = ""radio"", y.radioValue = ""t"" === rt.value; var pt, dt = S.expr.attrHandle; S.fn.extend({ attr: function (e, t) { return $(this, S.attr, e, t, 1 < arguments.length) }, removeAttr: function (e) { return this.each(function () { S.removeAttr(this, e) }) } }), S.extend({ attr: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return ""undefined"" == typeof e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? pt : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && ""set"" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + """"), n) : i && ""get"" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ?"|data_input/cargotracker/cargotracker.txt|0b77c42f09ad41be99946f3609a6edde
"void 0 : r) }, attrHooks: { type: { set: function (e, t) { if (!y.radioValue && ""radio"" === t && A(e, ""input"")) { var n = e.value; return e.setAttribute(""type"", t), n && (e.value = n), t } } } }, removeAttr: function (e, t) { var n, r = 0, i = t && t.match(P); if (i && 1 === e.nodeType) while (n = i[r++]) e.removeAttribute(n) } }), pt = { set: function (e, t, n) { return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n), n } }, S.each(S.expr.match.bool.source.match(/\w+/g), function (e, t) { var a = dt[t] || S.find.attr; dt[t] = function (e, t, n) { var r, i, o = t.toLowerCase(); return n || (i = dt[o], dt[o] = r, r = null != a(e, t, n) ? o : null, dt[o] = i), r } }); var ht = /^(? :input|select|textarea|button)$/i, gt = /^(? :a|area)$/i; function vt(e) { return (e.match(P) || []).join("" "") } function yt(e) { return e.getAttribute && e.getAttribute(""class"") || """" } function mt(e) { return Array.isArray(e) ? e : ""string"" == typeof e && e.match(P) || [] } S.fn.extend({ prop: function (e, t) { return $(this, S.prop, e, t, 1 < arguments.length) }, removeProp: function (e) { return this.each(function () { delete this[S.propFix[e] || e] }) } }), S.extend({ prop: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && ""set"" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && ""get"" in i && null !== (r = i.get(e, t)) ?"|data_input/cargotracker/cargotracker.txt|e4e2e5de540d481ba5a5c26327de54cf
"r : e[t] }, propHooks: { tabIndex: { get: function (e) { var t = S.find.attr(e, ""tabindex""); return t ? parseInt(t, 10) : ht.test(e.nodeName) || gt.test(e.nodeName) && e.href ?

0 : -1 } } }, propFix: { ""for"": ""htmlFor"", ""class"": ""className"" } }), y.optSelected || (S.propHooks.selected = { get: function (e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null }, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex) } }), S.each([""tabIndex"", ""readOnly"", ""maxLength"", ""cellSpacing"", ""cellPadding"", ""rowSpan"", ""colSpan"", ""useMap"", ""frameBorder"", ""contentEditable""], function () { S.propFix[this.toLowerCase()] = this }), S.fn.extend({ addClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { S(this).addClass(t.call(this, e, yt(this))) }); if ((e = mt(t)).length) while (n = this[u++]) if (i = yt(n), r = 1 === n.nodeType"|data_input/cargotracker/cargotracker.txt|41a65927d4c5451eb2b7d9089273bfec
"&& "" "" + vt(i) + "" "") { a = 0; while (o = e[a++]) r.indexOf("" "" + o + "" "") < 0 && (r += o + "" ""); i !== (s = vt(r)) && n.setAttribute(""class"", s) } return this }, removeClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { S(this).removeClass(t.call(this, e, yt(this))) }); if (!arguments.length) return this.attr(""class"", """"); if ((e = mt(t)).length) while (n = this[u++]) if (i = yt(n), r = 1 === n.nodeType && "" "" + vt(i) + "" "") { a = 0; while (o = e[a++]) while (-1 < r.indexOf("" "" + o + "" "")) r = r.replace("" "" + o + "" "", "" ""); i !== (s = vt(r)) && n.setAttribute(""class"", s) } return this }, toggleClass: function (i, t) { var o = typeof i, a = ""string"" === o || Array.isArray(i); return ""boolean"" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function (e) { S(this).toggleClass(i.call(this, e, yt(this), t), t) }) : this.each(function () { var e, t, n, r; if (a) { t = 0, n = S(this), r = mt(i); while (e = r[t++]) n.hasClass(e) ? n.removeClass(e) : n.addClass(e) } else void 0 !== i && ""boolean"" !== o || ((e = yt(this)) && Y.set(this, ""__className__"", e), this.setAttribute && this.setAttribute(""class"", e || !1 === i ? """""|data_input/cargotracker/cargotracker.txt|6477c47c78474b3997e8b89ca1c482b4
": Y.get(this, ""__className__"") || """")) }) }, hasClass: function (e) { var t, n, r = 0; t = "" "" + e + "" ""; while (n = this[r++]) if (1 === n.nodeType && -1 < ("" "" + vt(yt(n)) + "" "").indexOf(t)) return !0; return !1 } }); var xt = /\r/g; S.fn.extend({ val: function (n) { var r, e, i, t = this[0]; return arguments.length ? (i = m(n), this.each(function (e) { var t; 1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = """" : ""number"" == typeof t ? t += """" : Array.isArray(t) && (t = S.map(t, function (e) { return null == e ? """" : e + """" })), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && ""set"" in r && void 0 !== r.set(this, t, ""value"") || (this.value = t)) })) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && ""get"" in r && void 0 !== (e = r.get(t, ""value"")) ? e : ""string"" == typeof (e = t.value) ? e.replace(xt, """") : null == e ? """" : e : void 0 } }), S.extend({ valHooks: { option: { get: function (e) { var t = S.find.attr(e, ""value""); return null != t ? t : vt(S.text(e)) } }, select: { get: function (e) { var t, n, r, i = e.options, o = e.selectedIndex, a = ""select-one"" === e.type, s = a ? null : [], u = a ? o + 1 : i.length; for (r = o < 0 ? u : a ?"|data_input/cargotracker/cargotracker.txt|281cccb704e047d09cce2e4df6c31af2
"o : 0; r < u; r++)if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, ""optgroup""))) { if (t = S(n).val(), a) return t; s.push(t) } return s }, set: function (e, t) { var n, r, i = e.options, o = S.makeArray(t), a = i.length; while (a--) ((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0); return n || (e.selectedIndex = -1), o } } } }), S.each([""radio"", ""checkbox""], function () { S.valHooks[this] = { set: function (e, t) { if (Array.isArray(t)) return e.checked = -1 < S.inArray(S(e).val(), t) } }, y.checkOn || (S.valHooks[this].get = function (e) { return null === e.getAttribute(""value"") ? ""on"" : e.value }) }), y.focusin = ""onfocusin"" in C; var bt = /^(? :focusinfocus|focusoutblur)$/, wt = function (e) { e.stopPropagation() }; S.extend(S.event, { trigger: function (e, t, n, r) { var i, o, a, s, u, l, c, f, p = [n || E], d = v.call(e, ""type"") ? e.type : e, h = v.call(e, ""namespace"") ? e.namespace.split(""."") : []; if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !bt.test(d + S.event.triggered) && (-1 < d.indexOf(""."") && (d = (h = d.split("". "")).shift(), h.sort()), u = d.indexOf("":"") < 0 && ""on"" + d, (e = e[S.expando] ? e : new S.Event(d, ""object"" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("". ""), e.rnamespace = e.namespace ? new RegExp(""(^|\\.)"" + h.join(""\\.(?:. *\\.|)"") + ""(\\.|$)"") : null, e.result = void 0, e.target || (e.target = n), t = null == t ?"|data_input/cargotracker/cargotracker.txt|3e8af3d00daa42f7903eb73580f323bc
"[e] : S.makeArray(t, [e]), c = S.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) { if (!r && !c.noBubble && !x(n)) { for (s = c.delegateType || d, bt.test(s + d) || (o = o.parentNode); o; o = o.parentNode)p.push(o), a = o; a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C) } i = 0; while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ?"|data_input/cargotracker/cargotracker.txt|9aa3133b436d4c4aa174509c296c612c
"s : c.bindType || d, (l = (Y.get(o, ""events"") || Object.create(null))[e.type] && Y.get(o, ""handle"")) && l.apply(o, t), (l = u && o[u]) && l.apply && V(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault()); return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !V(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), S.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, wt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, wt), S.event.triggered = void 0, a && (n[u] = a)), e.result } }, simulate: function (e, t, n) { var r = S.extend(new S.Event, n, { type: e, isSimulated: !0 }); S.event.trigger(r, null, t) } }), S.fn.extend({ trigger: function (e, t) { return this.each(function () { S.event.trigger(e, t, this) }) }, triggerHandler: function (e, t) { var n = this[0]; if (n) return S.event.trigger(e, t, n, !0) } }), y.focusin || S.each({ focus: ""focusin"", blur: ""focusout"" }, function (n, r) { var i = function (e) { S.event.simulate(r, e.target, S.event.fix(e)) }; S.event.special[r] = { setup: function () { var e = this.ownerDocument || this.document || this, t = Y.access(e, r); t || e.addEventListener(n, i, !0), Y.access(e, r, (t || 0) + 1) }, teardown: function () { var e = this.ownerDocument || this.document || this, t = Y.access(e, r) - 1; t ?"|data_input/cargotracker/cargotracker.txt|cf7b7d6307be4950acedafaac5ed7b8d
"Y.access(e, r, t) : (e.removeEventListener(n, i, !0), Y.remove(e, r)) } } }); var Tt = C.location, Ct = { guid: Date.now() }, Et = /\?/; S.parseXML = function (e) { var t; if (!e || ""string"" != typeof e) return null; try { t = (new C.DOMParser).parseFromString(e, ""text/xml"") } catch (e) { t = void 0 } return t && !t.getElementsByTagName(""parsererror"").length || S.error(""Invalid XML: "" + e), t }; var St = /\[\]$/, kt = /\r?\n/g, At = /^(? :submit|button|image|reset|file)$/i, Nt = /^(? :input|select|textarea|keygen)/i; function Dt(n, e, r, i) { var t; if (Array.isArray(e)) S.each(e, function (e, t) { r || St.test(n) ? i(n, t) : Dt(n + ""["" + (""object"" == typeof t && null != t ? e : """") + ""]"", t, r, i) }); else if (r || ""object"" !== w(e)) i(n, e); else for (t in e) Dt(n + ""["" + t + ""]"", e[t], r, i) } S.param = function (e, t) { var n, r = [], i = function (e, t) { var n = m(t) ? t() : t; r[r.length] = encodeURIComponent(e) + ""="" + encodeURIComponent(null == n ? """" : n) }; if (null == e) return """"; if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function () { i(this.name, this.value) }); else for (n in e) Dt(n, e[n], t, i); return r.join(""&"") }, S.fn.extend({ serialize: function () { return S.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var e = S.prop(this, ""elements""); return e ?"|data_input/cargotracker/cargotracker.txt|ae51c102ad194c5188343cae4623d92c
"S.makeArray(e) : this }).filter(function () { var e = this.type; return this.name && !S(this).is("":disabled"") && Nt.test(this.nodeName) && !At.test(e) && (this.checked || !pe.test(e)) }).map(function (e, t) { var n = S(this).val(); return null == n ? null : Array.isArray(n) ? S.map(n, function (e) { return { name: t.name, value: e.replace(kt, ""\r\n"") } }) : { name: t.name, value: n.replace(kt, ""\r\n"") } }).get() } }); var jt = /%20/g, qt = /#. *$/, Lt = /([?&])_=[^&]*/, Ht = /^(.*? ):[ \t]*([^\r\n]*)$/gm, Ot = /^(? :GET|HEAD)$/, Pt = /^\/\//, Rt = {}, Mt = {}, It = ""*/"".concat(""*""), Wt = E.createElement(""a""); function Ft(o) { return function (e, t) { ""string"" != typeof e && (t = e, e = ""*""); var n, r = 0, i = e.toLowerCase().match(P) || []; if (m(t)) while (n = i[r++]) ""+"" === n[0] ? (n = n.slice(1) || ""*"", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t) } } function Bt(t, i, o, a) { var s = {}, u = t === Mt; function l(e) { var r; return s[e] = !0, S.each(t[e] || [], function (e, t) { var n = t(i, o, a); return ""string"" != typeof n || u || s[n] ? u ? ! (r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1) }), r } return l(i.dataTypes[0]) || !s[""*""] && l(""*"") } function $t(e, t) { var n, r, i = S.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && S.extend(!0, e, r), e } Wt.href = Tt.href, S.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: Tt.href, type: ""GET"", isLocal: /^(?"|data_input/cargotracker/cargotracker.txt|4b1bd2bb99864f1194b928ec529223d5
":about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol), global: !0, processData: !0, async: !0, contentType: ""application/x-www-form-urlencoded; charset=UTF-8"", accepts: { ""*"": It, text: ""text/plain"", html: ""text/html"", xml: ""application/xml, text/xml"", json: ""application/json, text/javascript"" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: ""responseXML"", text: ""responseText"", json: ""responseJSON"" }, converters: { ""* text"": String, ""text html"": !0, ""text json"": JSON.parse, ""text xml"": S.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? $t($t(e, S.ajaxSettings), t) : $t(S.ajaxSettings, e) }, ajaxPrefilter: Ft(Rt), ajaxTransport: Ft(Mt), ajax: function (e, t) { ""object"" == typeof e && (t = e, e = void 0), t = t || {}; var c, f, p, n, d, r, h, g, i, o, v = S.ajaxSetup({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event, x = S.Deferred(), b = S.Callbacks(""once memory""), w = v.statusCode || {}, a = {}, s = {}, u = ""canceled"", T = { readyState: 0, getResponseHeader: function (e) { var t; if (h) { if (!n) { n = {}; while (t = Ht.exec(p)) n[t[1].toLowerCase() + "" ""] = (n[t[1].toLowerCase() + "" ""] || []).concat(t[2]) } t = n[e.toLowerCase() + "" ""] } return null == t ? null : t.join("", "") }, getAllResponseHeaders: function () { return h ?"|data_input/cargotracker/cargotracker.txt|fb033fc151b04da8b8e8775fe12259ca
"p : null }, setRequestHeader: function (e, t) { return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this }, overrideMimeType: function (e) { return null == h && (v.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (h) T.always(e[T.status]); else for (t in e) w[t] = [w[t], e[t]]; return this }, abort: function (e) { var t = e || u; return c && c.abort(t), l(0, t), this } }; if (x.promise(T), v.url = ((e || v.url || Tt.href) + """").replace(Pt, Tt.protocol + ""//""), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || ""*"").toLowerCase().match(P) || [""""], null == v.crossDomain) { r = E.createElement(""a""); try { r.href = v.url, r.href = r.href, v.crossDomain = Wt.protocol + ""//"" + Wt.host != r.protocol + ""//"" + r.host } catch (e) { v.crossDomain = !0 } } if (v.data && v.processData && ""string"" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Bt(Rt, v, t, T), h) return T; for (i in (g = S.event && v.global) && 0 == S.active++ && S.event.trigger(""ajaxStart""), v.type = v.type.toUpperCase(), v.hasContent = !Ot.test(v.type), f = v.url.replace(qt, """"), v.hasContent ? v.data && v.processData && 0 === (v.contentType || """").indexOf(""application/x-www-form-urlencoded"") && (v.data = v.data.replace(jt, ""+"")) : (o = v.url.slice(f.length), v.data && (v.processData || ""string"" == typeof v.data) && (f += (Et.test(f) ? ""&"" : ""?"")"|data_input/cargotracker/cargotracker.txt|584338af6ba04efeae13a9f4103b9dea
"+ v.data, delete v.data), !1 === v.cache && (f = f.replace(Lt, ""$1""), o = (Et.test(f) ? ""&"" : ""?"") + ""_="" + Ct.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader(""If-Modified-Since"", S.lastModified[f]), S.etag[f] && T.setRequestHeader(""If-None-Match"", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader(""Content-Type"", v.contentType), T.setRequestHeader(""Accept"", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + (""*"" !== v.dataTypes[0] ? "", "" + It + ""; q=0.01"" : """") : v.accepts[""*""]), v.headers) T.setRequestHeader(i, v.headers[i]); if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort(); if (u = ""abort"", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Bt(Mt, v, t, T)) { if (T.readyState = 1, g && m.trigger(""ajaxSend"", [T, v]), h) return T; v.async && 0 < v.timeout && (d = C.setTimeout(function () { T.abort(""timeout"") }, v.timeout)); try { h = !1, c.send(a, l) } catch (e) { if (h) throw e; l(-1, e) } } else l(-1, ""No Transport""); function l(e, t, n, r) { var i, o, a, s, u, l = t; h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || """", T.readyState = 0 < e ?"|data_input/cargotracker/cargotracker.txt|a8ec6ca45431456cbcbeb488a35e69ea
"4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function (e, t, n) { var r, i, o, a, s = e.contents, u = e.dataTypes; while (""*"" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader(""Content-Type"")); if (r) for (i in s) if (s[i] && s[i].test(r)) { u.unshift(i); break } if (u[0] in n) o = u[0]; else { for (i in n) { if (!u[0] || e.converters[i + "" "" + u[0]]) { o = i; break } a || (a = i) } o = o || a } if (o) return o !== u[0] && u.unshift(o), n[o] }(v, T, n)), !i && -1 < S.inArray(""script"", v.dataTypes) && (v.converters[""text script""] = function () { }), s = function (e, t, n, r) { var i, o, a, s, u, l = {}, c = e.dataTypes.slice(); if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a]; o = c.shift(); while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if (""*"" === o) o = u; else if (""*"" !== u && u !== o) { if (! (a = l[u + "" "" + o] || l[""* "" + o])) for (i in l) if ((s = i.split("" ""))[1] === o && (a = l[u + "" "" + s[0]] || l[""* "" + s[0]])) { !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break } if (!0 !== a) if (a && e[""throws""]) t = a(t); else try { t = a(t) } catch (e) { return { state: ""parsererror"", error: a ? e : ""No conversion from "" + u + "" to "" + o } } } return { state: ""success"", data: t } }(v, s, T, i), i ?"|data_input/cargotracker/cargotracker.txt|f907f8d712f8424280d01b36fd57a085
"(v.ifModified && ((u = T.getResponseHeader(""Last-Modified"")) && (S.lastModified[f] = u), (u = T.getResponseHeader(""etag"")) && (S.etag[f] = u)), 204 === e || ""HEAD"" === v.type ? l = ""nocontent"" : 304 === e ? l = ""notmodified"" : (l = s.state, o = s.data, i = ! (a = s.error))) : (a = l, !e && l || (l = ""error"", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + """", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? ""ajaxSuccess"" : ""ajaxError"", [T, v, i ?"|data_input/cargotracker/cargotracker.txt|b299c31639524277ab427576962045d5
"o : a]), b.fireWith(y, [T, l]), g && (m.trigger(""ajaxComplete"", [T, v]), --S.active || S.event.trigger(""ajaxStop""))) } return T }, getJSON: function (e, t, n) { return S.get(e, t, n, ""json"") }, getScript: function (e, t) { return S.get(e, void 0, t, ""script"") } }), S.each([""get"", ""post""], function (e, i) { S[i] = function (e, t, n, r) { return m(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({ url: e, type: i, dataType: r, data: t, success: n }, S.isPlainObject(e) && e)) } }), S.ajaxPrefilter(function (e) { var t; for (t in e.headers) ""content-type"" === t.toLowerCase() && (e.contentType = e.headers[t] || """") }), S._evalUrl = function (e, t, n) { return S.ajax({ url: e, type: ""GET"", dataType: ""script"", cache: !0, async: !1, global: !1, converters: { ""text script"": function () { } }, dataFilter: function (e) { S.globalEval(e, t, n) } }) }, S.fn.extend({ wrapAll: function (e) { var t; return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () { var e = this; while (e.firstElementChild) e = e.firstElementChild; return e }).append(this)), this }, wrapInner: function (n) { return m(n) ? this.each(function (e) { S(this).wrapInner(n.call(this, e)) }) : this.each(function () { var e = S(this), t = e.contents(); t.length ? t.wrapAll(n) : e.append(n) }) }, wrap: function (t) { var n = m(t); return this.each(function (e) { S(this).wrapAll(n ?"|data_input/cargotracker/cargotracker.txt|e2ba314828ec4eb98351fc77bc0ff1bb
"t.call(this, e) : t) }) }, unwrap: function (e) { return this.parent(e).not(""body"").each(function () { S(this).replaceWith(this.childNodes) }), this } }), S.expr.pseudos.hidden = function (e) { return !S.expr.pseudos.visible(e) }, S.expr.pseudos.visible = function (e) { return ! ! (e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, S.ajaxSettings.xhr = function () { try { return new C.XMLHttpRequest } catch (e) { } }; var _t = { 0: 200, 1223: 204 }, zt = S.ajaxSettings.xhr(); y.cors = ! !zt && ""withCredentials"" in zt, y.ajax = zt = ! !zt, S.ajaxTransport(function (i) { var o, a; if (y.cors || zt && !i.crossDomain) return { send: function (e, t) { var n, r = i.xhr(); if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields) for (n in i.xhrFields) r[n] = i.xhrFields[n]; for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e[""X-Requested-With""] || (e[""X-Requested-With""] = ""XMLHttpRequest""), e) r.setRequestHeader(n, e[n]); o = function (e) { return function () { o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, ""abort"" === e ? r.abort() : ""error"" === e ? ""number"" != typeof r.status ? t(0, ""error"") : t(r.status, r.statusText) : t(_t[r.status] || r.status, r.statusText, ""text"" !== (r.responseType || ""text"") || ""string"" != typeof r.responseText ?"|data_input/cargotracker/cargotracker.txt|df2e4f567bd745be8cf6c509a8a275d3
"{ binary: r.response } : { text: r.responseText }, r.getAllResponseHeaders())) } }, r.onload = o(), a = r.onerror = r.ontimeout = o(""error""), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function () { 4 === r.readyState && C.setTimeout(function () { o && a() }) }, o = o(""abort""); try { r.send(i.hasContent && i.data || null) } catch (e) { if (o) throw e } }, abort: function () { o && o() } } }), S.ajaxPrefilter(function (e) { e.crossDomain && (e.contents.script = !1) }), S.ajaxSetup({ accepts: { script: ""text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"" }, contents: { script: /\b(? :java|ecma)script\b/ }, converters: { ""text script"": function (e) { return S.globalEval(e), e } } }), S.ajaxPrefilter(""script"", function (e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = ""GET"") }), S.ajaxTransport(""script"", function (n) { var r, i; if (n.crossDomain || n.scriptAttrs) return { send: function (e, t) { r = S(""<script>"").attr(n.scriptAttrs || {}).prop({ charset: n.scriptCharset, src: n.url }).on(""load error"", i = function (e) { r.remove(), i = null, e && t(""error"" === e.type ? 404 : 200, e.type) }), E.head.appendChild(r[0]) }, abort: function () { i && i() } } }); var Ut, Xt = [], Vt = /(=)\?"|data_input/cargotracker/cargotracker.txt|f382a90939fa47de8d120afeaf91258c
"(?=&|$)|\?\?/; S.ajaxSetup({ jsonp: ""callback"", jsonpCallback: function () { var e = Xt.pop() || S.expando + ""_"" + Ct.guid++; return this[e] = !0, e } }), S.ajaxPrefilter(""json jsonp"", function (e, t, n) { var r, i, o, a = !1 !== e.jsonp && (Vt.test(e.url) ? ""url"" : ""string"" == typeof e.data && 0 === (e.contentType || """").indexOf(""application/x-www-form-urlencoded"") && Vt.test(e.data) && ""data""); if (a || ""jsonp"" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Vt, ""$1"" + r) : !1 !== e.jsonp && (e.url += (Et.test(e.url) ? ""&"" : ""?"") + e.jsonp + ""="" + r), e.converters[""script json""] = function () { return o || S.error(r + "" was not called""), o[0] }, e.dataTypes[0] = ""json"", i = C[r], C[r] = function () { o = arguments }, n.always(function () { void 0 === i ? S(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, Xt.push(r)), o && m(i) && i(o[0]), o = i = void 0 }), ""script"" }), y.createHTMLDocument = ((Ut = E.implementation.createHTMLDocument("""").body).innerHTML = ""<form></form><form></form>"", 2 === Ut.childNodes.length), S.parseHTML = function (e, t, n) { return ""string"" != typeof e ? [] : (""boolean"" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("""")).createElement(""base"")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ?"|data_input/cargotracker/cargotracker.txt|bb6e9a36691a4c5da1bc00b0378e034d
"[t.createElement(i[1])] : (i = xe([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes))); var r, i, o }, S.fn.load = function (e, t, n) { var r, i, o, a = this, s = e.indexOf("" ""); return -1 < s && (r = vt(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && ""object"" == typeof t && (i = ""POST""), 0 < a.length && S.ajax({ url: e, type: i || ""GET"", dataType: ""html"", data: t }).done(function (e) { o = arguments, a.html(r ? S(""<div>"").append(S.parseHTML(e)).find(r) : e) }).always(n && function (e, t) { a.each(function () { n.apply(this, o || [e.responseText, t, e]) }) }), this }, S.expr.pseudos.animated = function (t) { return S.grep(S.timers, function (e) { return t === e.elem }).length }, S.offset = { setOffset: function (e, t, n) { var r, i, o, a, s, u, l = S.css(e, ""position""), c = S(e), f = {}; ""static"" === l && (e.style.position = ""relative""), s = c.offset(), o = S.css(e, ""top""), u = S.css(e, ""left""), (""absolute"" === l || ""fixed"" === l) && -1 < (o + u).indexOf(""auto"") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), ""using"" in t ? t.using.call(e, f) : (""number"" == typeof f.top && (f.top += ""px""), ""number"" == typeof f.left && (f.left += ""px""), c.css(f)) } }, S.fn.extend({ offset: function (t) { if (arguments.length) return void 0 === t ?"|data_input/cargotracker/cargotracker.txt|942b4016be5e4a019eed7712aa4ec85d
"this : this.each(function (e) { S.offset.setOffset(this, t, e) }); var e, n, r = this[0]; return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: e.top + n.pageYOffset, left: e.left + n.pageXOffset }) : { top: 0, left: 0 } : void 0 }, position: function () { if (this[0]) { var e, t, n, r = this[0], i = { top: 0, left: 0 }; if (""fixed"" === S.css(r, ""position"")) t = r.getBoundingClientRect(); else { t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && ""static"" === S.css(e, ""position"")) e = e.parentNode; e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, ""borderTopWidth"", !0), i.left += S.css(e, ""borderLeftWidth"", !0)) } return { top: t.top - i.top - S.css(r, ""marginTop"", !0), left: t.left - i.left - S.css(r, ""marginLeft"", !0) } } }, offsetParent: function () { return this.map(function () { var e = this.offsetParent; while (e && ""static"" === S.css(e, ""position"")) e = e.offsetParent; return e || re }) } }), S.each({ scrollLeft: ""pageXOffset"", scrollTop: ""pageYOffset"" }, function (t, i) { var o = ""pageYOffset"" === i; S.fn[t] = function (e) { return $(this, function (e, t, n) { var r; if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t]; r ? r.scrollTo(o ? r.pageXOffset : n, o ?"|data_input/cargotracker/cargotracker.txt|53c98d68a9da460d85f783194b1f91ae
"n : r.pageYOffset) : e[t] = n }, t, e, arguments.length) } }), S.each([""top"", ""left""], function (e, n) { S.cssHooks[n] = $e(y.pixelPosition, function (e, t) { if (t) return t = Be(e, n), Me.test(t) ? S(e).position()[n] + ""px"" : t }) }), S.each({ Height: ""height"", Width: ""width"" }, function (a, s) { S.each({ padding: ""inner"" + a, content: s, """": ""outer"" + a }, function (r, o) { S.fn[o] = function (e, t) { var n = arguments.length && (r || ""boolean"" != typeof e), i = r || (!0 === e || !0 === t ? ""margin"" : ""border""); return $(this, function (e, t, n) { var r; return x(e) ? 0 === o.indexOf(""outer"") ? e[""inner"" + a] : e.document.documentElement[""client"" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body[""scroll"" + a], r[""scroll"" + a], e.body[""offset"" + a], r[""offset"" + a], r[""client"" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i) }, s, n ? e : void 0, n) } }) }), S.each([""ajaxStart"", ""ajaxStop"", ""ajaxComplete"", ""ajaxError"", ""ajaxSuccess"", ""ajaxSend""], function (e, t) { S.fn[t] = function (e) { return this.on(t, e) } }), S.fn.extend({ bind: function (e, t, n) { return this.on(e, null, t, n) }, unbind: function (e, t) { return this.off(e, null, t) }, delegate: function (e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function (e, t, n) { return 1 === arguments.length ?"|data_input/cargotracker/cargotracker.txt|caf4b0c44a0b4a2682e9edacde800554
"this.off(e, ""**"") : this.off(t, e || ""**"", n) }, hover: function (e, t) { return this.mouseenter(e).mouseleave(t || e) } }), S.each(""blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu"".split("" ""), function (e, n) { S.fn[n] = function (e, t) { return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n) } }); var Gt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; S.proxy = function (e, t) { var n, r, i; if (""string"" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function () { return e.apply(t || this, r.concat(s.call(arguments))) }).guid = e.guid = e.guid || S.guid++, i }, S.holdReady = function (e) { e ? S.readyWait++ : S.ready(!0) }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (e) { var t = S.type(e); return (""number"" === t || ""string"" === t) && !isNaN(e - parseFloat(e)) }, S.trim = function (e) { return null == e ? """" : (e + """").replace(Gt, """") }, ""function"" == typeof define && define.amd && define(""jquery"", [], function () { return S }); var Yt = C.jQuery, Qt = C.$; return S.noConflict = function (e) { return C.$ === S && (C.$ = Qt), e && C.jQuery === S && (C.jQuery = Yt), S }, ""undefined"" == typeof e && (C.jQuery = C.$ = S), S });"|data_input/cargotracker/cargotracker.txt|3a692cf0983d4a29a297751c596e2f05
"../cargotracker/src/main/webapp/resources/js/progress.js $(function () { function resetToDefaults() { topbar.config({ autoRun: true, barThickness: 3, barColors: { '.75': 'rgba(255, 255, 60, .9)', '.75': 'rgba(255, 212, 0, .9)', '1.0': 'rgba(211, 84,  0, .9)' }, shadowBlur: 10, shadowColor: 'rgba(0,   0,   0,   .6)', className: 'topbar' }) } resetToDefaults() topbar.show() setTimeout(function () { $('#container').fadeIn('slow') topbar.hide() }, 1500) }) ../cargotracker/src/main/webapp/resources/js/topbar.js /** * @license MIT * topbar 2.0.0, 2023-02-04 * http://buunguyen.github.io/topbar * Copyright (c) 2021 Buu Nguyen */ (function (window, document) { ""use strict"";

var canvas, currentProgress, showing, progressTimerId = null, fadeTimerId = null, delayTimerId = null, addEvent = function (elem, type, handler) { if (elem.addEventListener) elem.addEventListener(type, handler, false); else if (elem.attachEvent) elem.attachEvent(""on"" + type, handler); else elem[""on"" + type] = handler; }, options = { autoRun: true, barThickness: 3, barColors: { 0: ""rgba(26,  188, 156, .9)"", "".25"": ""rgba(52,  152, 219, .9)"", "".50"": ""rgba(241, 196, 15,  .9)"", "".75"": ""rgba(230, 126, 34,  .9)"", ""1.0"": ""rgba(211, 84,  0,   .9)"", }, shadowBlur: 10, shadowColor: ""rgba(0,   0,   0,   .6)"", className: null, }, repaint = function () { canvas.width = window.innerWidth; canvas.height = options.barThickness * 5; // need space for shadow

var ctx = canvas.getContext(""2d"");

ctx.shadowBlur = options.shadowBlur;"|data_input/cargotracker/cargotracker.txt|39dddaca962945c79d44aaf17f78bc29
"var ctx = canvas.getContext(""2d"");

ctx.shadowBlur = options.shadowBlur;

ctx.shadowColor = options.shadowColor;

var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0); for (var stop in options.barColors) lineGradient.addColorStop(stop, options.barColors[stop]); ctx.lineWidth = options.barThickness; ctx.beginPath(); ctx.moveTo(0, options.barThickness / 2); ctx.lineTo( Math.ceil(currentProgress * canvas.width), options.barThickness / 2 ); ctx.strokeStyle = lineGradient; ctx.stroke(); }, createCanvas = function () { canvas = document.createElement(""canvas""); var style = canvas.style; style.position = ""fixed""; style.top = style.left = style.right = style.margin = style.padding = 0; style.zIndex = 100001; style.display = ""none""; if (options.className) canvas.classList.add(options.className); document.body.appendChild(canvas); addEvent(window, ""resize"", repaint); }, topbar = { config:"|data_input/cargotracker/cargotracker.txt|464e8a0c1ec34d97b3a545b8809b3df4
"function (opts) { for (var key in opts) if (options.hasOwnProperty(key)) options[key] = opts[key]; }, show: function (delay) { if (showing) return; if (delay) { if (delayTimerId) return; delayTimerId = setTimeout(() => topbar.show(), delay); } else { showing = true; if (fadeTimerId !== null) window.cancelAnimationFrame(fadeTimerId); if (!canvas) createCanvas(); canvas.style.opacity = 1; canvas.style.display = ""block""; topbar.progress(0); if (options.autoRun) { (function loop() { progressTimerId = window.requestAnimationFrame(loop); topbar.progress( ""+"" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2) ); })(); } } }, progress: function (to) { if (typeof to === ""undefined"") return currentProgress; if (typeof to === ""string"") { to = (to.indexOf(""+"") >= 0 || to.indexOf(""-"") >= 0 ? currentProgress : 0) + parseFloat(to); } currentProgress = to > 1 ? 1 : to; repaint(); return currentProgress; }, hide: function () { clearTimeout(delayTimerId); delayTimerId = null; if (!showing) return; showing = false; if (progressTimerId != null) { window.cancelAnimationFrame(progressTimerId); progressTimerId = null; } (function loop() { if (topbar.progress(""+.1"") >= 1) { canvas.style.opacity -= 0.05; if (canvas.style.opacity <= 0.05) { canvas.style.display = ""none""; fadeTimerId = null; return; } } fadeTimerId = window.requestAnimationFrame(loop); })(); }, };"|data_input/cargotracker/cargotracker.txt|4a11b6b72722481ba65c39e149256aec
"if (typeof module === ""object"" && typeof module.exports === ""object"") { module.exports = topbar; } else if (typeof define === ""function"" && define.amd) { define(function () { return topbar; }); } else { this.topbar = topbar; } }.call(this, window, document));"|data_input/cargotracker/cargotracker.txt|1a947072126e4433b5824a230d1b81a4
"../cargotracker/src/main/webapp/resources/js/topbar.min.js /** * @license MIT * topbar 2.0.0, 2023-02-04 * http://buunguyen.github.io/topbar * Copyright (c) 2021 Buu Nguyen */ (function (window, document) { ""use strict""; function repaint() { canvas.width = window.innerWidth, canvas.height = 5 * options.barThickness; var ctx = canvas.getContext(""2d""); ctx.shadowBlur = options.shadowBlur, ctx.shadowColor = options.shadowColor; var stop, lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0); for (stop in options.barColors) lineGradient.addColorStop(stop, options.barColors[stop]); ctx.lineWidth = options.barThickness, ctx.beginPath(), ctx.moveTo(0, options.barThickness / 2), ctx.lineTo(Math.ceil(currentProgress * canvas.width), options.barThickness / 2), ctx.strokeStyle = lineGradient, ctx.stroke() } var canvas, currentProgress, showing, progressTimerId = null, fadeTimerId = null, delayTimerId = null, options = { autoRun: !0, barThickness: 3, barColors: { 0: ""rgba(26,  188, 156, .9)"", "".25"": ""rgba(52,  152, 219, .9)"", "".50"": ""rgba(241, 196, 15,  .9)"", "".75"": ""rgba(230, 126, 34,  .9)"", ""1.0"": ""rgba(211, 84,  0,   .9)"" }, shadowBlur: 10, shadowColor: ""rgba(0,   0,   0,   .6)"", className: null }, topbar = { config: function (opts) { for (var key in opts) options.hasOwnProperty(key) && (options[key] = opts[key]) }, show: function (handler) { var type, elem; showing || (handler ?"|data_input/cargotracker/cargotracker.txt|a3eed50c0dfa4de0b021d0454a636e2b
text|source|chunk_id
"delayTimerId = delayTimerId || setTimeout(() => topbar.show(), handler) : (showing = !0, null !== fadeTimerId && window.cancelAnimationFrame(fadeTimerId), canvas || ((elem = (canvas = document.createElement(""canvas"")).style).position = ""fixed"", elem.top = elem.left = elem.right = elem.margin = elem.padding = 0, elem.zIndex = 100001, elem.display = ""none"", options.className && canvas.classList.add(options.className), document.body.appendChild(canvas), type = ""resize"", handler = repaint, (elem = window).addEventListener ? elem.addEventListener(type, handler, !1) : elem.attachEvent ? elem.attachEvent(""on"" + type, handler) : elem[""on"" + type] = handler), canvas.style.opacity = 1, canvas.style.display = ""block"", topbar.progress(0), options.autoRun && function loop() { progressTimerId = window.requestAnimationFrame(loop), topbar.progress(""+"" + .05 * Math.pow(1 - Math.sqrt(currentProgress), 2)) }())) }, progress: function (to) { return void 0 === to || (""string"" == typeof to && (to = (0 <= to.indexOf(""+"") || 0 <= to.indexOf(""-"") ? currentProgress : 0) + parseFloat(to)), currentProgress = 1 < to ? 1 : to, repaint()), currentProgress }, hide: function () { clearTimeout(delayTimerId), delayTimerId = null, showing && (showing = !1, null != progressTimerId && (window.cancelAnimationFrame(progressTimerId), progressTimerId = null), function loop() { return 1 <= topbar.progress(""+.1"") && (canvas.style.opacity -= .05, canvas.style.opacity <= .05) ?"|data_input/cargotracker/cargotracker.txt|c2f07e2514eb466991dd41746b520e25
"(canvas.style.display = ""none"", void (fadeTimerId = null)) : void (fadeTimerId = window.requestAnimationFrame(loop)) }()) } }; ""object"" == typeof module && ""object"" == typeof module.exports ? module.exports = topbar : ""function"" == typeof define && define.amd ? define(function () { return topbar }) : this.topbar = topbar }).call(this, window, document);

../cargotracker/src/main/webapp/resources/leaflet/leaflet-src.esm.js /* @preserve * Leaflet 1.6.0+Detached: bd88f73e8ddb90eb945a28bc1de9eb07f7386118.bd88f73, a JS library for interactive maps. http://leafletjs.com * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade */

var version = ""1.6.0"";

/* * @namespace Util * * Various utility functions, used by Leaflet internally. */

// @function extend(dest: Object, src? : Object): Object // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut. function extend(dest) { var i, j, len, src;

for (j = 1, len = arguments.length; j < len; j++) { src = arguments[j]; for (i in src) { dest[i] = src[i]; } } return dest; }

// @function create(proto: Object, properties? : Object): Object // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create) var create = Object.create || (function () { function F() {} return function (proto) { F.prototype = proto; return new F(); }; })();"|data_input/cargotracker/cargotracker.txt|1f6db836823946f1b1d728e354b71bae
"// @function bind(fn: Function, ): Function // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind). // Has a `L.bind()` shortcut. function bind(fn, obj) { var slice = Array.prototype.slice;

if (fn.bind) {

return fn.bind.apply(fn, slice.call(arguments, 1));

}

var args = slice.call(arguments, 2);

return function () { return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments); }; }

// @property lastId: Number // Last unique ID used by [`stamp()`](#util-stamp) var lastId = 0;

// @function stamp(obj: Object): Number // Returns the unique ID of an object, assigning it one if it doesn't have it. function stamp(obj) { /*eslint-disable */ obj._leaflet_id = obj._leaflet_id || ++lastId; return obj._leaflet_id; /* eslint-enable */ }

// @function throttle(fn: Function, time: Number, context: Object): Function // Returns a function which executes function `fn` with the given scope `context` // (so that the `this` keyword refers to `context` inside `fn`'s code). The function // `fn` will be called no more than one time per given amount of `time`. The arguments // received by the bound function will be any arguments passed when binding the // function, followed by any arguments passed when invoking the bound function. // Has an `L.throttle` shortcut. function throttle(fn, time, context) { var lock, args, wrapperFn, later;"|data_input/cargotracker/cargotracker.txt|846670021f544519bd586cb40521d516
"later = function () { // reset lock and call if queued lock = false; if (args) { wrapperFn.apply(context, args); args = false; } };

wrapperFn = function () { if (lock) { // called too soon, queue to call later args = arguments;

} else { // call and lock until later fn.apply(context, arguments); setTimeout(later, time); lock = true; } };

return wrapperFn;

}

// @function wrapNum(num: Number, range: Number[], includeMax? : Boolean): Number // Returns the number `num` modulo `range` in such a way so it lies within // `range[0]` and `range[1]`. The returned value will be always smaller than // `range[1]` unless `includeMax` is set to `true`. function wrapNum(x, range, includeMax) { var max = range[1], min = range[0], d = max - min; return x === max && includeMax ? x : ((x - min) % d + d) % d + min; }

// @function falseFn(): Function // Returns a function which always returns `false`. function falseFn() { return false; }

// @function formatNum(num: Number, digits? : Number): Number // Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default. function formatNum(num, digits) { var pow = Math.pow(10, (digits === undefined ? 6 : digits)); return Math.round(num * pow) / pow; }

// @function trim(str: String): String // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim) function trim(str) { return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, ''); }"|data_input/cargotracker/cargotracker.txt|53ab76f23c874efe9358d07cb4ac0064
"// @function splitWords(str: String): String[] // Trims and splits the string on whitespace and returns the array of parts. function splitWords(str) { return trim(str).split(/\s+/); }

// @function setOptions(obj: Object, options: Object): Object // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut. function setOptions(obj, options) { if (!Object.prototype.hasOwnProperty.call(obj, 'options')) { obj.options = obj.options ? create(obj.options) : {}; } for (var i in options) { obj.options[i] = options[i]; } return obj.options; }

// @function getParamString(obj: Object, existingUrl? : String, uppercase? : Boolean): String // Converts an object into a parameter URL string, e.g. `{a: ""foo"", b: ""bar""}` // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will // be appended at the end. If `uppercase` is `true`, the parameter names will // be uppercased (e.g. `'?A=foo&B=bar'`) function getParamString(obj, existingUrl, uppercase) { var params = []; for (var i in obj) { params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i])); } return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&'); }

var templateRe = /\{

([\w_

]+)

\}/g;"|data_input/cargotracker/cargotracker.txt|a4cc129333084b67b19226ca67710520
"var templateRe = /\{

([\w_

]+)

\}/g;

// @function template(str: String, data: Object): String // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'` // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string // `('Hello foo, bar')`. You can also specify functions instead of strings for // data values  they will be evaluated passing `data` as an argument. function template(str, data) { return str.replace(templateRe, function (str, key) { var value = data[key];

if (value === undefined) { throw new Error('No value provided for variable ' + str);

} else if (typeof value === 'function') { value = value(data); } return value; }); }

// @function isArray(obj): Boolean // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray) var isArray = Array.isArray || function (obj) { return (Object.prototype.toString.call(obj) === '[object Array]'); };

// @function indexOf(array: Array, el: Object): Number // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) function indexOf(array, el) { for (var i = 0; i < array.length; i++) { if (array[i] === el) { return i; } } return -1; }"|data_input/cargotracker/cargotracker.txt|2bc8d32add944bc38f505684019f1729
"// @property emptyImageUrl: String // Data URI string containing a base64-encoded empty GIF image. // Used as a hack to free memory from unused images on WebKit-powered // mobile devices (by setting image `src` to this string). var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

// inspired by http://paulirish.com/2011/requestanimationframe

for

smart

animating/

function getPrefixed(name) { return window['webkit' + name] || window['moz' + name] || window['ms' + name]; }

var lastTime = 0;

// fallback for IE 7-8 function timeoutDefer(fn) { var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));

lastTime = time + timeToCall; return window.setTimeout(fn, timeToCall); }

var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer; var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };"|data_input/cargotracker/cargotracker.txt|f066e773ff784a29912fb4b6603acf4e
"// @function requestAnimFrame(fn: Function, context? : Object, immediate? : Boolean): Number // Schedules `fn` to be executed when the browser repaints. `fn` is bound to // `context` if given. When `immediate` is set, `fn` is called immediately if // the browser doesn't have native support for // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame), // otherwise it's delayed. Returns a request ID that can be used to cancel the request. function requestAnimFrame(fn, context, immediate) { if (immediate && requestFn === timeoutDefer) { fn.call(context); } else { return requestFn.call(window, bind(fn, context)); } }

// @function cancelAnimFrame(id: Number): undefined // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame). function cancelAnimFrame(id) { if (id) { cancelFn.call(window, id); } }

var Util = ({ extend: extend, create: create, bind: bind, get lastId () { return lastId; }, stamp: stamp, throttle: throttle, wrapNum: wrapNum, falseFn: falseFn, formatNum: formatNum, trim: trim, splitWords: splitWords, setOptions: setOptions, getParamString: getParamString, template: template, isArray: isArray, indexOf: indexOf, emptyImageUrl: emptyImageUrl, requestFn: requestFn, cancelFn: cancelFn, requestAnimFrame: requestAnimFrame, cancelAnimFrame: cancelAnimFrame });

// @class Class

// @aka L.Class

// @section

// @uninheritable"|data_input/cargotracker/cargotracker.txt|13bfb230771f449a88c65623de5adb90
"// @class Class

// @aka L.Class

// @section

// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

function Class() {}

Class.extend = function (props) {

// @function extend(props: Object): Function // [Extends the current class](#class-inheritance) given the properties to be included. // Returns a Javascript function that is a class constructor (to be called with `new`). var NewClass = function () {

// call the constructor

if (this.initialize) {

this.initialize.apply(this, arguments);

}

// call all constructor hooks this.callInitHooks(); };

var parentProto = NewClass.__super__ = this.prototype;

var proto = create(parentProto);

proto.constructor = NewClass;

NewClass.prototype = proto;

// inherit parent's statics for (var i in this) { if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') { NewClass[i] = this[i]; } }

// mix static properties into the class if (props.statics) { extend(NewClass, props.statics); delete props.statics; }

// mix includes into the prototype if (props.includes) { checkDeprecatedMixinEvents(props.includes); extend.apply(null, [proto].concat(props.includes)); delete props.includes; }

// merge options

if (proto.options) {

props.options = extend(create(proto.options), props.options);

}

// mix given properties into the prototype extend(proto, props);

proto._initHooks = [];

// add method for calling all hooks proto.callInitHooks = function () {"|data_input/cargotracker/cargotracker.txt|2e4373b1b9424cf2bf83fa0a920d6c47
"proto._initHooks = [];

// add method for calling all hooks proto.callInitHooks = function () {

if (this._initHooksCalled) { return; }

if (parentProto.callInitHooks) {

parentProto.callInitHooks.call(this);

}

this._initHooksCalled = true;

for (var i = 0, len = proto._initHooks.length; i < len; i++) { proto._initHooks[i].call(this); } };

return NewClass;

};

// @function include(properties: Object): this // [Includes a mixin](#class-includes) into the current class. Class.include = function (props) { extend(this.prototype, props); return this; };

// @function mergeOptions(options: Object): this // [Merges `options`](#class-options) into the defaults of the class. Class.mergeOptions = function (options) { extend(this.prototype.options, options); return this; };

// @function addInitHook(fn: Function): this // Adds a [constructor hook](#class-constructor-hooks) to the class. Class.addInitHook = function (fn) { // (Function) || (String, args...) var args = Array.prototype.slice.call(arguments, 1);

var init = typeof fn === 'function' ? fn : function () { this[fn].apply(this, args); };

this.prototype._initHooks = this.prototype._initHooks || []; this.prototype._initHooks.push(init); return this; };

function checkDeprecatedMixinEvents(includes) { if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

includes = isArray(includes) ? includes : [includes];"|data_input/cargotracker/cargotracker.txt|2251538aa6b14228950c8a595448aa26
"includes = isArray(includes) ? includes : [includes];

for (var i = 0; i < includes.length; i++) { if (includes[i] === L.Mixin.Events) { console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead. ', new Error().stack); } } }

/* * @class Evented * @aka L.Evented * @inherits Class * * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event). * * @example * * ```js * map.on('click', function(e) { * 	alert(e.latlng); * } ); * ``` * * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function: * * ```js * function onClick(e) { ... } * * map.on('click', onClick); * map.off('click', onClick); * ``` */

var Events = { /* @method on(type: String, fn: Function, context? : Object): this * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`). * * @alternative * @method on(eventMap: Object): this * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}` */ on: function (types, fn, context) {"|data_input/cargotracker/cargotracker.txt|5bd7adc572e64302a3dfbd78776a9ca3
"// types can be a map of types/handlers if (typeof types === 'object') { for (var type in types) { // we don't process space-separated events here for performance; // it's a hot path since Layer uses the on(obj) syntax this._on(type, types[type], fn); }

} else { // types can be a string of space-separated words types = splitWords(types);

for (var i = 0, len = types.length; i < len; i++) { this._on(types[i], fn, context); } }

return this;

},

/* @method off(type: String, fn? : Function, context? : Object): this * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener. * * @alternative * @method off(eventMap: Object): this * Removes a set of type/listener pairs. * * @alternative * @method off: this * Removes all listeners to all events on the object. This includes implicitly attached events. */ off: function (types, fn, context) {

if (!types) { // clear all listeners if called without arguments delete this._events;

} else if (typeof types === 'object') { for (var type in types) { this._off(type, types[type], fn); }

} else {

types = splitWords(types);

for (var i = 0, len = types.length; i < len; i++) { this._off(types[i], fn, context); } }

return this;

},"|data_input/cargotracker/cargotracker.txt|e80600d7edf1426486506f7ead2d367b
"} else {

types = splitWords(types);

for (var i = 0, len = types.length; i < len; i++) { this._off(types[i], fn, context); } }

return this;

},

// attach listener (without syntactic sugar now) _on: function (type, fn, context) { this._events = this._events || {};

/

get/init listeners for type

/

var typeListeners = this._events[type];

if (!typeListeners) {

typeListeners = [];

this._events[type] = typeListeners;

}

if (context === this) { // Less memory footprint. context = undefined; } var newListener = {fn: fn, ctx: context}, listeners = typeListeners;

// check if fn already there for (var i = 0, len = listeners.length; i < len; i++) { if (listeners[i].fn === fn && listeners[i].ctx === context) { return; } }

listeners.push(newListener);

},

_off: function (type, fn, context) { var listeners, i, len;

if (!this._events) { return; }

listeners = this._events[type];

if (!listeners) {

return;

}

if (!fn) { // Set all removed listeners to noop so they are not called if remove happens in fire for (i = 0, len = listeners.length; i < len; i++) { listeners[i].fn = falseFn; } // clear all listeners for a type if function isn't specified delete this._events[type]; return; }

if (context === this) { context = undefined; }

if (listeners) {

// find fn and remove it for (i = 0, len = listeners.length; i < len; i++) { var l = listeners[i]; if (l.ctx !== context) { continue; } if (l.fn === fn) {"|data_input/cargotracker/cargotracker.txt|8b2543c45c1e4c8980d742f381541c66
"// set the removed listener to noop so that's not called if remove happens in fire l.fn = falseFn;

if (this._firingCount) { /* copy array in case events are being fired */ this._events[type] = listeners = listeners.slice(); } listeners.splice(i, 1);

return;

}

}

}

},

// @method fire(type: String, data? : Object, propagate? : Boolean): this // Fires an event of the specified type. You can optionally provide an data // object  the first argument of the listener function will contain its // properties. The event can optionally be propagated to event parents. fire: function (type, data, propagate) { if (!this.listens(type, propagate)) { return this; }

var event = extend({}, data, { type: type, target: this, sourceTarget: data && data.sourceTarget || this });

if (this._events) {

var listeners = this._events[type];

if (listeners) { this._firingCount = (this._firingCount + 1) || 1; for (var i = 0, len = listeners.length; i < len; i++) { var l = listeners[i]; l.fn.call(l.ctx || this, event); }

this._firingCount-

;

}

}

if (propagate) { // propagate the event to parents (set with addEventParent) this._propagateEvent(event); }

return this;

},

// @method listens(type: String): Boolean // Returns `true` if a particular event type has any listeners attached to it. listens: function (type, propagate) { var listeners = this._events && this._events[type]; if (listeners && listeners.length) { return true; }"|data_input/cargotracker/cargotracker.txt|ce1b950e82e74698936038524832e33b
"if (propagate) { // also check parents for listeners if event propagates for (var id in this._eventParents) { if (this._eventParents[id].listens(type, propagate)) { return true; } } } return false; },

// @method once(): this // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed. once: function (types, fn, context) {

if (typeof types === 'object') { for (var type in types) { this.once(type, types[type], fn); } return this; }

var handler = bind(function () { this .off(types, fn, context) .off(types, handler, context); }, this);

// add a listener that's executed once and removed after that return this .on(types, fn, context) .on(types, handler, context); },

// @method addEventParent(obj: Evented): this // Adds an event parent - an `Evented` that will receive propagated events addEventParent: function (obj) { this._eventParents = this._eventParents || {}; this._eventParents[stamp(obj)] = obj; return this; },

// @method removeEventParent(obj: Evented): this // Removes an event parent, so it will stop receiving propagated events removeEventParent: function (obj) { if (this._eventParents) { delete this._eventParents[stamp(obj)]; } return this; },

_propagateEvent: function (e) { for (var id in this._eventParents) { this._eventParents[id].fire(e.type, extend({ layer: e.target, propagatedFrom: e.target }, e), true); } } };

// aliases; we should ditch those eventually

// @method addEventListener(): this"|data_input/cargotracker/cargotracker.txt|c9b6de9176884144a4e8ac14c986249e
"// aliases; we should ditch those eventually

// @method addEventListener(): this

// Alias to [`on()`](#evented

on)

Events.addEventListener = Events.on;

// @method removeEventListener(): this

// Alias to [`off()`](#evented

off)

// @method clearAllEventListeners(): this // Alias to [`off()`](#evented-off) Events.removeEventListener = Events.clearAllEventListeners = Events.off;

// @method addOneTimeEventListener(): this

// Alias to [`once()`](#evented

once)

Events.addOneTimeEventListener = Events.once;

// @method fireEvent(): this

// Alias to [`fire()`](#evented

fire)

Events.fireEvent = Events.fire;

// @method hasEventListeners(): Boolean

// Alias to [`listens()`](#evented

listens)

Events.hasEventListeners = Events.listens;

var Evented = Class.extend(Events);

/* * @class Point * @aka L.Point * * Represents a point with `x` and `y` coordinates in pixels. * * @example * * ```js * var point = L.point(200, 300); * ``` * * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent: * * ```js * map.panBy([200, 300]); * map.panBy(L.point(200, 300)); * ``` * * Note that `Point` does not inherit from Leaflet's `Class` object, * which means new classes can't inherit from it, and new methods * can't be added to it with the `include` function. */"|data_input/cargotracker/cargotracker.txt|9f00313632f04298a95b6a0ba9e38c10
"function Point(x, y, round) { // @property x: Number; The `x` coordinate of the point this.x = (round ? Math.round(x) : x); // @property y: Number; The `y` coordinate of the point this.y = (round ? Math.round(y) : y); }

var trunc = Math.trunc || function (v) { return v > 0 ? Math.floor(v) : Math.ceil(v); };

Point.prototype = {

// @method clone(): Point // Returns a copy of the current point. clone: function () { return new Point(this.x, this.y); },

// @method add(otherPoint: Point): Point // Returns the result of addition of the current and the given points. add: function (point) { // non-destructive, returns a new point return this.clone()._add(toPoint(point)); },

_add: function (point) { // destructive, used directly for performance in situations where it's safe to modify existing point this.x += point.x; this.y += point.y; return this; },

// @method subtract(otherPoint: Point): Point // Returns the result of subtraction of the given point from the current. subtract: function (point) { return this.clone()._subtract(toPoint(point)); },

_subtract: function (point) {

this.x

= point.x;

this.y

= point.y;

return this;

},

// @method divideBy(num: Number): Point // Returns the result of division of the current point by the given number. divideBy: function (num) { return this.clone()._divideBy(num); },

_divideBy: function (num) {

this.x /= num;

this.y /= num;

return this;

},"|data_input/cargotracker/cargotracker.txt|68005789e5624a81be2ed2ac40f8081a
"_divideBy: function (num) {

this.x /= num;

this.y /= num;

return this;

},

// @method multiplyBy(num: Number): Point // Returns the result of multiplication of the current point by the given number. multiplyBy: function (num) { return this.clone()._multiplyBy(num); },

_multiplyBy: function (num) {

this.x

= num;

this.y

= num;

return this;

},

// @method scaleBy(scale: Point): Point // Multiply each coordinate of the current point by each coordinate of // `scale`. In linear algebra terms, multiply the point by the // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation) // defined by `scale`. scaleBy: function (point) { return new Point(this.x * point.x, this.y * point.y); },

// @method unscaleBy(scale: Point): Point // Inverse of `scaleBy`. Divide each coordinate of the current point by // each coordinate of `scale`. unscaleBy: function (point) { return new Point(this.x / point.x, this.y / point.y); },

// @method round(): Point // Returns a copy of the current point with rounded coordinates. round: function () { return this.clone()._round(); },

_round: function () {

this.x = Math.round(this.x);

this.y = Math.round(this.y);

return this;

},

// @method floor(): Point // Returns a copy of the current point with floored coordinates (rounded down). floor: function () { return this.clone()._floor(); },

_floor: function () {

this.x = Math.floor(this.x);

this.y = Math.floor(this.y);

return this;

},"|data_input/cargotracker/cargotracker.txt|3302bb192a75492ab2f5f1696449d5e3
"_floor: function () {

this.x = Math.floor(this.x);

this.y = Math.floor(this.y);

return this;

},

// @method ceil(): Point // Returns a copy of the current point with ceiled coordinates (rounded up). ceil: function () { return this.clone()._ceil(); },

_ceil: function () {

this.x = Math.ceil(this.x);

this.y = Math.ceil(this.y);

return this;

},

// @method trunc(): Point // Returns a copy of the current point with truncated coordinates (rounded towards zero). trunc: function () { return this.clone()._trunc(); },

_trunc: function () {

this.x = trunc(this.x);

this.y = trunc(this.y);

return this;

},

// @method distanceTo(otherPoint: Point): Number // Returns the cartesian distance between the current and the given points. distanceTo: function (point) { point = toPoint(point);

var x = point.x

this.x,

y = point.y

this.y;

return Math.sqrt(x

x + y

y);

},

// @method equals(otherPoint: Point): Boolean // Returns `true` if the given point has the same coordinates. equals: function (point) { point = toPoint(point);

return point.x === this.x && point.y === this.y; },

// @method contains(otherPoint: Point): Boolean // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values). contains: function (point) { point = toPoint(point);

return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y); },"|data_input/cargotracker/cargotracker.txt|10d9074a783847898392b0820de56fee
"return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y); },

// @method toString(): String // Returns a string representation of the point for debugging purposes. toString: function () { return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')'; } };

// @factory L.point(x: Number, y: Number, round? : Boolean) // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative // @factory L.point(coords: Number[]) // Expects an array of the form `[x, y]` instead.

// @alternative // @factory L.point(coords: Object) // Expects a plain object of the form `{x: Number, y: Number}` instead. function toPoint(x, y, round) { if (x instanceof Point) { return x; } if (isArray(x)) { return new Point(x[0], x[1]); } if (x === undefined || x === null) { return x; } if (typeof x === 'object' && 'x' in x && 'y' in x) { return new Point(x.x, x.y); } return new Point(x, y, round); }"|data_input/cargotracker/cargotracker.txt|5687000f919d427f930a8f6c5df759c3
"/* * @class Bounds * @aka L.Bounds * * Represents a rectangular area in pixel coordinates. * * @example * * ```js * var p1 = L.point(10, 10), * p2 = L.point(40, 60), * bounds = L.bounds(p1, p2); * ``` * * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this: * * ```js * otherBounds.intersects([[10, 10], [40, 60]]); * ``` * * Note that `Bounds` does not inherit from Leaflet's `Class` object, * which means new classes can't inherit from it, and new methods * can't be added to it with the `include` function. */

function Bounds(a, b) { if (!a) { return; }

var points = b ? [a, b] : a;

for (var i = 0, len = points.length; i < len; i++) { this.extend(points[i]); } }

Bounds.prototype = { // @method extend(point: Point): this // Extends the bounds to contain the given point. extend: function (point) { // (Point) point = toPoint(point);

// @property min: Point // The top left corner of the rectangle. // @property max: Point // The bottom right corner of the rectangle. if (!this.min && !this.max) { this.min = point.clone(); this.max = point.clone(); } else { this.min.x = Math.min(point.x, this.min.x); this.max.x = Math.max(point.x, this.max.x); this.min.y = Math.min(point.y, this.min.y); this.max.y = Math.max(point.y, this.max.y); } return this; },"|data_input/cargotracker/cargotracker.txt|be8f0fa9b5a34923ae3bee1ec88ae716
"// @method getCenter(round? : Boolean): Point // Returns the center point of the bounds. getCenter: function (round) { return new Point( (this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round); },

// @method getBottomLeft(): Point // Returns the bottom-left point of the bounds. getBottomLeft: function () { return new Point(this.min.x, this.max.y); },

// @method getTopRight(): Point // Returns the top-right point of the bounds. getTopRight: function () { // -> Point return new Point(this.max.x, this.min.y); },

// @method getTopLeft(): Point // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)). getTopLeft: function () { return this.min; // left, top },

// @method getBottomRight(): Point // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)). getBottomRight: function () { return this.max; // right, bottom },

// @method getSize(): Point // Returns the size of the given bounds getSize: function () { return this.max.subtract(this.min); },

// @method contains(otherBounds: Bounds): Boolean // Returns `true` if the rectangle contains the given one. // @alternative // @method contains(point: Point): Boolean // Returns `true` if the rectangle contains the given point. contains: function (obj) { var min, max;

if (typeof obj[0] === 'number' || obj instanceof Point) { obj = toPoint(obj); } else { obj = toBounds(obj); }

if (obj instanceof Bounds) { min = obj.min; max = obj.max; } else { min = max = obj; }"|data_input/cargotracker/cargotracker.txt|9d90e15a69384256b4f8a7a3a819aa6c
"if (obj instanceof Bounds) { min = obj.min; max = obj.max; } else { min = max = obj; }

return (min.x >= this.min.x) && (max.x <= this.max.x) && (min.y >= this.min.y) && (max.y <= this.max.y); },

// @method intersects(otherBounds: Bounds): Boolean // Returns `true` if the rectangle intersects the given bounds. Two bounds // intersect if they have at least one point in common. intersects: function (bounds) { // (Bounds) -> Boolean bounds = toBounds(bounds);

var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = (max2.x >= min.x) && (min2.x <= max.x), yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

return xIntersects && yIntersects;

},

// @method overlaps(otherBounds: Bounds): Boolean // Returns `true` if the rectangle overlaps the given bounds. Two bounds // overlap if their intersection is an area. overlaps: function (bounds) { // (Bounds) -> Boolean bounds = toBounds(bounds);

var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = (max2.x > min.x) && (min2.x < max.x), yOverlaps = (max2.y > min.y) && (min2.y < max.y);

return xOverlaps && yOverlaps;

},

isValid: function () {

return ! ! (this.min && this.max);

}

};"|data_input/cargotracker/cargotracker.txt|7f5a269b7e174256b2752ec84ba5fd4c
"return xOverlaps && yOverlaps;

},

isValid: function () {

return ! ! (this.min && this.max);

}

};

// @factory L.bounds(corner1: Point, corner2: Point) // Creates a Bounds object from two corners coordinate pairs. // @alternative // @factory L.bounds(points: Point[]) // Creates a Bounds object from the given array of points. function toBounds(a, b) { if (!a || a instanceof Bounds) { return a; } return new Bounds(a, b); }

/* * @class LatLngBounds * @aka L.LatLngBounds * * Represents a rectangular geographical area on a map. * * @example * * ```js * var corner1 = L.latLng(40.712, -74.227), * corner2 = L.latLng(40.774, -74.125), * bounds = L.latLngBounds(corner1, corner2); * ``` * * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this: * * ```js * map.fitBounds([ * 	[40.712, -74.227], * 	[40.774, -74.125] * ]); * ``` * * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range. * * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object, * which means new classes can't inherit from it, and new methods * can't be added to it with the `include` function. */

function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[]) if (!corner1) { return; }

var latlngs = corner2 ? [corner1, corner2] : corner1;"|data_input/cargotracker/cargotracker.txt|09ed59f6a76549dba88a62d25156b144
"var latlngs = corner2 ? [corner1, corner2] : corner1;

for (var i = 0, len = latlngs.length; i < len; i++) { this.extend(latlngs[i]); } }

LatLngBounds.prototype = {

// @method extend(latlng: LatLng): this // Extend the bounds to contain the given point

// @alternative // @method extend(otherBounds: LatLngBounds): this // Extend the bounds to contain the given bounds extend: function (obj) { var sw = this._southWest, ne = this._northEast, sw2, ne2;

if (obj instanceof LatLng) { sw2 = obj; ne2 = obj;

} else if (obj instanceof LatLngBounds) { sw2 = obj._southWest; ne2 = obj._northEast;

if (!sw2 || !ne2) { return this; }

} else { return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this; }

if (!sw && !ne) { this._southWest = new LatLng(sw2.lat, sw2.lng); this._northEast = new LatLng(ne2.lat, ne2.lng); } else { sw.lat = Math.min(sw2.lat, sw.lat); sw.lng = Math.min(sw2.lng, sw.lng); ne.lat = Math.max(ne2.lat, ne.lat); ne.lng = Math.max(ne2.lng, ne.lng); }

return this;

},

// @method pad(bufferRatio: Number): LatLngBounds // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction. // For example, a ratio of 0.5 extends the bounds by 50% in each direction. // Negative values will retract the bounds. pad: function (bufferRatio) { var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;"|data_input/cargotracker/cargotracker.txt|870e5fe2873b44d6a2cce924526fb158
"return new LatLngBounds( new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)); },

// @method getCenter(): LatLng // Returns the center point of the bounds. getCenter: function () { return new LatLng( (this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2); },

// @method getSouthWest(): LatLng // Returns the south-west point of the bounds. getSouthWest: function () { return this._southWest; },

// @method getNorthEast(): LatLng // Returns the north-east point of the bounds. getNorthEast: function () { return this._northEast; },

// @method getNorthWest(): LatLng // Returns the north-west point of the bounds. getNorthWest: function () { return new LatLng(this.getNorth(), this.getWest()); },

// @method getSouthEast(): LatLng // Returns the south-east point of the bounds. getSouthEast: function () { return new LatLng(this.getSouth(), this.getEast()); },

// @method getWest(): Number // Returns the west longitude of the bounds getWest: function () { return this._southWest.lng; },

// @method getSouth(): Number // Returns the south latitude of the bounds getSouth: function () { return this._southWest.lat; },

// @method getEast(): Number // Returns the east longitude of the bounds getEast: function () { return this._northEast.lng; },

// @method getNorth(): Number // Returns the north latitude of the bounds getNorth: function () { return this._northEast.lat; },"|data_input/cargotracker/cargotracker.txt|eac409f0ad5e4dc8b04b58321f2b1132
"// @method getNorth(): Number // Returns the north latitude of the bounds getNorth: function () { return this._northEast.lat; },

// @method contains(otherBounds: LatLngBounds): Boolean // Returns `true` if the rectangle contains the given one.

// @alternative // @method contains (latlng: LatLng): Boolean // Returns `true` if the rectangle contains the given point. contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) { obj = toLatLng(obj); } else { obj = toLatLngBounds(obj); }

var sw = this._southWest,

ne = this._northEast,

sw2, ne2;

if (obj instanceof LatLngBounds) { sw2 = obj.getSouthWest(); ne2 = obj.getNorthEast(); } else { sw2 = ne2 = obj; }

return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) && (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng); },

// @method intersects(otherBounds: LatLngBounds): Boolean // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common. intersects: function (bounds) { bounds = toLatLngBounds(bounds);

var sw = this._southWest,

ne = this._northEast,

sw2 = bounds.getSouthWest(),

ne2 = bounds.getNorthEast(),

latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat), lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

return latIntersects && lngIntersects;

},"|data_input/cargotracker/cargotracker.txt|9a25a79594a74d8792f9dc04d7cbda5d
"return latIntersects && lngIntersects;

},

// @method overlaps(otherBounds: LatLngBounds): Boolean // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area. overlaps: function (bounds) { bounds = toLatLngBounds(bounds);

var sw = this._southWest,

ne = this._northEast,

sw2 = bounds.getSouthWest(),

ne2 = bounds.getNorthEast(),

latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat), lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

return latOverlaps && lngOverlaps;

},

// @method toBBoxString(): String // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data. toBBoxString: function () { return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(','); },

// @method equals(otherBounds: LatLngBounds, maxMargin? : Number): Boolean // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number. equals: function (bounds, maxMargin) { if (!bounds) { return false; }

bounds = toLatLngBounds(bounds);

return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&

this._northEast.equals(bounds.getNorthEast(), maxMargin);

},"|data_input/cargotracker/cargotracker.txt|c2e7c1f91f7d40789e9b4e7d3dd90051
"return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&

this._northEast.equals(bounds.getNorthEast(), maxMargin);

},

// @method isValid(): Boolean // Returns `true` if the bounds are properly initialized. isValid: function () { return ! ! (this._southWest && this._northEast); } };

// TODO International date line?

// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng) // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

// @alternative // @factory L.latLngBounds(latlngs: LatLng[]) // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds). function toLatLngBounds(a, b) { if (a instanceof LatLngBounds) { return a; } return new LatLngBounds(a, b); }"|data_input/cargotracker/cargotracker.txt|abcee6a95c6e4146a7892e804043a6ac
"/* @class LatLng * @aka L.LatLng * * Represents a geographical point with a certain latitude and longitude. * * @example * * ``` * var latlng = L.latLng(50.5, 30.5); * ``` * * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent: * * ``` * map.panTo([50, 30]); * map.panTo({lon: 30, lat: 50}); * map.panTo({lat: 50, lng: 30}); * map.panTo(L.latLng(50, 30)); * ``` * * Note that `LatLng` does not inherit from Leaflet's `Class` object, * which means new classes can't inherit from it, and new methods * can't be added to it with the `include` function. */

function LatLng(lat, lng, alt) { if (isNaN(lat) || isNaN(lng)) { throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')'); }

// @property lat: Number

// Latitude in degrees

this.lat = +lat;

// @property lng: Number

// Longitude in degrees

this.lng = +lng;

// @property alt: Number // Altitude in meters (optional) if (alt !== undefined) { this.alt = +alt; } }

LatLng.prototype = { // @method equals(otherLatLng: LatLng, maxMargin? : Number): Boolean // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number. equals: function (obj, maxMargin) { if (!obj) { return false; }

obj = toLatLng(obj);

var margin = Math.max(

Math.abs(this.lat

obj.lat),

Math.abs(this.lng

obj.lng));"|data_input/cargotracker/cargotracker.txt|566ca1dc3b2c4aa08c534cefb70093c2
"obj = toLatLng(obj);

var margin = Math.max(

Math.abs(this.lat

obj.lat),

Math.abs(this.lng

obj.lng));

return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin); },

// @method toString(): String // Returns a string representation of the point (for debugging purposes). toString: function (precision) { return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')'; },

// @method distanceTo(otherLatLng: LatLng): Number // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines). distanceTo: function (other) { return Earth.distance(this, toLatLng(other)); },

// @method wrap(): LatLng // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees. wrap: function () { return Earth.wrapLatLng(this); },

// @method toBounds(sizeInMeters: Number): LatLngBounds // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`. toBounds: function (sizeInMeters) { var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

return toLatLngBounds( [this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]); },

clone: function () { return new LatLng(this.lat, this.lng, this.alt); } };"|data_input/cargotracker/cargotracker.txt|ba66ca55fbfa4360b6c8b6a9ec89bea5
"clone: function () { return new LatLng(this.lat, this.lng, this.alt); } };

// @factory L.latLng(latitude: Number, longitude: Number, altitude? : Number): LatLng // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative // @factory L.latLng(coords: Array): LatLng // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative // @factory L.latLng(coords: Object): LatLng // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

function toLatLng(a, b, c) { if (a instanceof LatLng) { return a; } if (isArray(a) && typeof a[0] !== 'object') { if (a.length === 3) { return new LatLng(a[0], a[1], a[2]); } if (a.length === 2) { return new LatLng(a[0], a[1]); } return null; } if (a === undefined || a === null) { return a; } if (typeof a === 'object' && 'lat' in a) { return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt); } if (b === undefined) { return null; } return new LatLng(a, b, c); }"|data_input/cargotracker/cargotracker.txt|505a60ac0db64c2fb98417a6984a3149
text|source|chunk_id
"/* * @namespace CRS * @crs L.CRS.Base * Object that defines coordinate reference systems for projecting * geographical points into pixel (screen) coordinates and back (and to * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system). * * Leaflet defines the most usual CRSs by default. If you want to use a * CRS not defined by default, take a look at the * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin. * * Note that the CRS instances do not inherit from Leaflet's `Class` object, * and can't be instantiated. Also, new classes can't inherit from them, * and methods can't be added to them with the `include` function. */

var CRS = { // @method latLngToPoint(latlng: LatLng, zoom: Number): Point // Projects geographical coordinates into pixel coordinates for a given zoom. latLngToPoint: function (latlng, zoom) { var projectedPoint = this.projection.project(latlng), scale = this.scale(zoom);

return this.transformation._transform(projectedPoint, scale);

},

// @method pointToLatLng(point: Point, zoom: Number): LatLng // The inverse of `latLngToPoint`. Projects pixel coordinates on a given // zoom into geographical coordinates. pointToLatLng: function (point, zoom) { var scale = this.scale(zoom), untransformedPoint = this.transformation.untransform(point, scale);

return this.projection.unproject(untransformedPoint);

},"|data_input/cargotracker/cargotracker.txt|2faf26b318df417fb7530480dc6fa677
"return this.projection.unproject(untransformedPoint);

},

// @method project(latlng: LatLng): Point // Projects geographical coordinates into coordinates in units accepted for // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services). project: function (latlng) { return this.projection.project(latlng); },

// @method unproject(point: Point): LatLng // Given a projected coordinate returns the corresponding LatLng. // The inverse of `project`. unproject: function (point) { return this.projection.unproject(point); },

// @method scale(zoom: Number): Number // Returns the scale used when transforming projected coordinates into // pixel coordinates for a particular zoom. For example, it returns // `256 * 2^zoom` for Mercator-based CRS. scale: function (zoom) { return 256 * Math.pow(2, zoom); },

// @method zoom(scale: Number): Number // Inverse of `scale()`, returns the zoom level corresponding to a scale // factor of `scale`. zoom: function (scale) { return Math.log(scale / 256) / Math.LN2; },

// @method getProjectedBounds(zoom: Number): Bounds // Returns the projection's bounds scaled and transformed for the provided `zoom`. getProjectedBounds: function (zoom) { if (this.infinite) { return null; }

var b = this.projection.bounds,

s = this.scale(zoom),

min = this.transformation.transform(b.min, s),

max = this.transformation.transform(b.max, s);

return new Bounds(min, max);

},"|data_input/cargotracker/cargotracker.txt|1518435421f74679a2d6c47e95b9ea92
"min = this.transformation.transform(b.min, s),

max = this.transformation.transform(b.max, s);

return new Bounds(min, max);

},

// @method distance(latlng1: LatLng, latlng2: LatLng): Number // Returns the distance between two geographical coordinates.

// @property code: String // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`) // // @property wrapLng: Number[] // An array of two numbers defining whether the longitude (horizontal) coordinate // axis wraps around a given range and how. Defaults to `[-180, 180]` in most // geographical CRSs. If `undefined`, the longitude axis does not wrap around. // // @property wrapLat: Number[] // Like `wrapLng`, but for the latitude (vertical) axis.

// wrapLng: [min, max],

// wrapLat: [min, max],

// @property infinite: Boolean // If true, the coordinate space will be unbounded (infinite in both axes) infinite: false,

// @method wrapLatLng(latlng: LatLng): LatLng // Returns a `LatLng` where lat and lng has been wrapped according to the // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds. wrapLatLng: function (latlng) { var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;

return new LatLng(lat, lng, alt); },"|data_input/cargotracker/cargotracker.txt|e7f226b489574650bf1ef4d60ce13442
"return new LatLng(lat, lng, alt); },

// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds // Returns a `LatLngBounds` with the same size as the given one, ensuring // that its center is within the CRS's bounds. // Only accepts actual `L.LatLngBounds` instances, not arrays. wrapLatLngBounds: function (bounds) { var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;

if (latShift === 0 && lngShift === 0) { return bounds; }

var sw = bounds.getSouthWest(),

ne = bounds.getNorthEast(),

newSw = new LatLng(sw.lat

latShift, sw.lng

lngShift),

newNe = new LatLng(ne.lat

latShift, ne.lng

lngShift);

return new LatLngBounds(newSw, newNe);

}

};

/* * @namespace CRS * @crs L.CRS.Earth * * Serves as the base for CRS that are global such that they cover the earth. * Can only be used as the base for other CRS and cannot be used directly, * since it does not have a `code`, `projection` or `transformation`. `distance()` returns * meters. */

var Earth = extend({}, CRS, { wrapLng: [-180, 180],

// Mean Earth Radius, as recommended for use by // the International Union of Geodesy and Geophysics, // see http://rosettacode.org/wiki/Haversine_formula R: 6371000,"|data_input/cargotracker/cargotracker.txt|b92afe8b90d548948a114e81be1bf2ee
"// distance between two geographical points using spherical law of cosines approximation distance: function (latlng1, latlng2) { var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return this.R * c; } });

/* * @namespace Projection * @projection L.Projection.SphericalMercator * * Spherical Mercator projection  the most common projection for online maps, * used by almost all free and commercial tile providers. Assumes that Earth is * a sphere. Used by the `EPSG:3857` CRS. */

var earthRadius = 6378137;

var SphericalMercator = {

R: earthRadius,

MAX_LATITUDE: 85.0511287798,

project: function (latlng) { var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);

return new Point( this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2); },

unproject: function (point) { var d = 180 / Math.PI;

return new LatLng(

(2

Math.atan(Math.exp(point.y / this.R))

(Math.PI / 2))

d,

point.x

d / this.R);

},

bounds: (function () {

var d = earthRadius

Math.PI;

return new Bounds([

d,

d], [d, d]);

})()

};"|data_input/cargotracker/cargotracker.txt|bc9a15e607ad433eafce3b5519154e2c
"d,

point.x

d / this.R);

},

bounds: (function () {

var d = earthRadius

Math.PI;

return new Bounds([

d,

d], [d, d]);

})()

};

/* * @class Transformation * @aka L.Transformation * * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d` * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing * the reverse. Used by Leaflet in its projections code. * * @example * * ```js * var transformation = L.transformation(2, 5, -1, 10), * 	p = L.point(1, 2), * 	p2 = transformation.transform(p), //  L.point(7, 8) * 	p3 = transformation.untransform(p2); //  L.point(1, 2) * ``` */

// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number) // Creates a `Transformation` object with the given coefficients. function Transformation(a, b, c, d) { if (isArray(a)) { // use array properties this._a = a[0]; this._b = a[1]; this._c = a[2]; this._d = a[3]; return; } this._a = a; this._b = b; this._c = c; this._d = d; }

Transformation.prototype = { // @method transform(point: Point, scale? : Number): Point // Returns a transformed point, optionally multiplied by the given scale. // Only accepts actual `L.Point` instances, not arrays. transform: function (point, scale) { // (Point, Number) -> Point return this._transform(point.clone(), scale); },"|data_input/cargotracker/cargotracker.txt|7a08cb831cd44379ab5bb6c821fbf9f7
"// destructive transform (faster) _transform: function (point, scale) { scale = scale || 1; point.x = scale * (this._a * point.x + this._b); point.y = scale * (this._c * point.y + this._d); return point; },

// @method untransform(point: Point, scale? : Number): Point // Returns the reverse transformation of the given point, optionally divided // by the given scale. Only accepts actual `L.Point` instances, not arrays. untransform: function (point, scale) { scale = scale || 1; return new Point( (point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c); } };

// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

// @factory L.transformation(a: Number, b: Number, c: Number, d: Number) // Instantiates a Transformation object with the given coefficients.

// @alternative // @factory L.transformation(coefficients: Array): Transformation // Expects an coefficients array of the form // `[a: Number, b: Number, c: Number, d: Number]`.

function toTransformation(a, b, c, d) { return new Transformation(a, b, c, d); }

/* * @namespace CRS * @crs L.CRS.EPSG3857 * * The most common CRS for online maps, used by almost all free and commercial * tile providers. Uses Spherical Mercator projection. Set in by default in * Map's `crs` option. */

var EPSG3857 = extend({}, Earth, { code: 'EPSG:3857', projection: SphericalMercator,"|data_input/cargotracker/cargotracker.txt|ffaa1d50f31e44daaa2bf4a523f944a8
"var EPSG3857 = extend({}, Earth, { code: 'EPSG:3857', projection: SphericalMercator,

transformation: (function () { var scale = 0.5 / (Math.PI * SphericalMercator.R); return toTransformation(scale, 0.5, -scale, 0.5); }()) });

var EPSG900913 = extend({}, EPSG3857, { code: 'EPSG:900913' });

// @namespace SVG; @section // There are several static functions which can be called without instantiating L.SVG:

// @function create(name: String): SVGElement // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement), // corresponding to the class name passed. For example, using 'line' will return // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement). function svgCreate(name) { return document.createElementNS('http://www.w3.org/2000/svg', name); }

// @function pointsToPath(rings: Point[], closed: Boolean): String // Generates a SVG path string for multiple rings, with each ring turning // into ""M..L..L.."" instructions function pointsToPath(rings, closed) { var str = '', i, j, len, len2, points, p;

for (i = 0, len = rings.length; i < len; i++) { points = rings[i];

for (j = 0, len2 = points.length; j < len2; j++) { p = points[j]; str += (j ? 'L' : 'M') + p.x + ' ' + p.y; }

// closes the ring for polygons; ""x"" is VML syntax str += closed ? (svg ? 'z' : 'x') : ''; }

// SVG complains about empty path strings return str || 'M0 0'; }"|data_input/cargotracker/cargotracker.txt|5d83fd46d294462eab8f0a2a9495358b
"// SVG complains about empty path strings return str || 'M0 0'; }

/* * @namespace Browser * @aka L.Browser * * A namespace with static properties for browser/feature detection used by Leaflet internally. * * @example * * ```js * if (L.Browser.ielt9) { *   alert('Upgrade your browser, dude! '); * } * ``` */

var style$1 = document.documentElement.style;

// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge). var ie = 'ActiveXObject' in window;

// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9. var ielt9 = ie && !document.addEventListener;

// @property edge: Boolean; `true` for the Edge web browser. var edge = 'msLaunchUri' in navigator && ! ('documentMode' in document);

// @property webkit: Boolean; // `true` for webkit-based browsers like Chrome and Safari (including mobile versions). var webkit = userAgentContains('webkit');

// @property android: Boolean // `true` for any browser running on an Android platform. var android = userAgentContains('android');

// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3. var android23 = userAgentContains('android 2') || userAgentContains('android 3');"|data_input/cargotracker/cargotracker.txt|5f9158cf72324b69b6b4779dd7cf3f82
"/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */ var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit // @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome) var androidStock = android && userAgentContains('Google') && webkitVer < 537 && ! ('AudioNode' in window);

// @property opera: Boolean; `true` for the Opera browser var opera = ! !window.opera;

// @property chrome: Boolean; `true` for the Chrome browser. var chrome = !edge && userAgentContains('chrome');

// @property gecko: Boolean; `true` for gecko-based browsers like Firefox. var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

// @property safari: Boolean; `true` for the Safari browser. var safari = !chrome && userAgentContains('safari');

var phantom = userAgentContains('phantom');

// @property opera12: Boolean // `true` for the Opera browser supporting CSS transforms (version 12 or later). var opera12 = 'OTransition' in style$1;

// @property win: Boolean; `true` when the browser is running in a Windows platform var win = navigator.platform.indexOf('Win') === 0;

// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms. var ie3d = ie && ('transition' in style$1);"|data_input/cargotracker/cargotracker.txt|a53410ff83594714b42a82ec00d2ad13
"// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms. var ie3d = ie && ('transition' in style$1);

// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms. var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms. var gecko3d = 'MozPerspective' in style$1;

// @property any3d: Boolean // `true` for all browsers supporting CSS transforms. var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

// @property mobile: Boolean; `true` for all browsers running in a mobile device. var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device. var mobileWebkit = mobile && webkit;

// @property mobileWebkit3d: Boolean // `true` for all webkit-based browsers in a mobile device supporting CSS transforms. var mobileWebkit3d = mobile && webkit3d;

// @property msPointer: Boolean // `true` for browsers implementing the Microsoft touch events model (notably IE10). var msPointer = !window.PointerEvent && window.MSPointerEvent;

// @property pointer: Boolean // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx). var pointer = ! ! (window.PointerEvent || msPointer);"|data_input/cargotracker/cargotracker.txt|68b5da5c457f44e78d305b808268bff0
"// @property touch: Boolean // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events). // This does not necessarily mean that the browser is running in a computer with // a touchscreen, it only means that the browser is capable of understanding // touch events. var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || (window.DocumentTouch && document instanceof window.DocumentTouch));

// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device. var mobileOpera = mobile && opera;

// @property mobileGecko: Boolean // `true` for gecko-based browsers running in a mobile device. var mobileGecko = mobile && gecko;

// @property retina: Boolean // `true` for browsers on a high-resolution ""retina"" screen or on any screen when browser's display zoom is more than 100%. var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;"|data_input/cargotracker/cargotracker.txt|f3c38d888da24f89bf4c992c5e77ff07
"// @property passiveEvents: Boolean // `true` for browsers that support passive events. var passiveEvents = (function () { var supportsPassiveOption = false; try { var opts = Object.defineProperty({}, 'passive', { get: function () { // eslint-disable-line getter-return supportsPassiveOption = true; } }); window.addEventListener('testPassiveEventSupport', falseFn, opts); window.removeEventListener('testPassiveEventSupport', falseFn, opts); } catch (e) { // Errors can safely be ignored since this is only a browser support test. } return supportsPassiveOption; }());

// @property canvas: Boolean // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API). var canvas = (function () { return ! !document.createElement('canvas').getContext; }());

// @property svg: Boolean // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG). var svg = ! ! (document.createElementNS && svgCreate('svg').createSVGRect);

// @property vml: Boolean // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language). var vml = !svg && (function () { try { var div = document.createElement('div'); div.innerHTML = '<v:shape adj=""1""/>';

var shape = div.firstChild;

shape.style.behavior = 'url(#default#VML)';

return shape && (typeof shape.adj === 'object');

} catch (e) {

return false;

}

}());

function userAgentContains(str) {

return navigator.userAgent.toLowerCase().indexOf(str) >= 0;

}"|data_input/cargotracker/cargotracker.txt|37ae719fd9784a2eae346ede1112c736
"} catch (e) {

return false;

}

}());

function userAgentContains(str) {

return navigator.userAgent.toLowerCase().indexOf(str) >= 0;

}

var Browser = ({

ie: ie,

ielt9: ielt9,

edge: edge,

webkit: webkit,

android: android,

android23: android23,

androidStock: androidStock,

opera: opera,

chrome: chrome,

gecko: gecko,

safari: safari,

phantom: phantom,

opera12: opera12,

win: win,

ie3d: ie3d,

webkit3d: webkit3d,

gecko3d: gecko3d,

any3d: any3d,

mobile: mobile,

mobileWebkit: mobileWebkit,

mobileWebkit3d: mobileWebkit3d,

msPointer: msPointer,

pointer: pointer,

touch: touch,

mobileOpera: mobileOpera,

mobileGecko: mobileGecko,

retina: retina,

passiveEvents: passiveEvents,

canvas: canvas,

svg: svg,

vml: vml

});

/* * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices. */

var POINTER_DOWN =   msPointer ? 'MSPointerDown'   : 'pointerdown'; var POINTER_MOVE =   msPointer ? 'MSPointerMove'   : 'pointermove'; var POINTER_UP =     msPointer ? 'MSPointerUp'     : 'pointerup'; var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';

var _pointers = {};

var _pointerDocListener = false;

// Provides a touch events wrapper for (ms)pointer events. // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

function addPointerListener(obj, type, handler, id) { if (type === 'touchstart') { _addPointerStart(obj, handler, id);"|data_input/cargotracker/cargotracker.txt|c33c5f854fa542d5a39dc58c964cd834
"function addPointerListener(obj, type, handler, id) { if (type === 'touchstart') { _addPointerStart(obj, handler, id);

} else if (type === 'touchmove') { _addPointerMove(obj, handler, id);

} else if (type === 'touchend') { _addPointerEnd(obj, handler, id); }

return this;

}

function removePointerListener(obj, type, id) { var handler = obj['_leaflet_' + type + id];

if (type === 'touchstart') { obj.removeEventListener(POINTER_DOWN, handler, false);

} else if (type === 'touchmove') { obj.removeEventListener(POINTER_MOVE, handler, false);

} else if (type === 'touchend') { obj.removeEventListener(POINTER_UP, handler, false); obj.removeEventListener(POINTER_CANCEL, handler, false); }

return this;

}

function _addPointerStart(obj, handler, id) { var onDown = bind(function (e) { // IE10 specific: MsTouch needs preventDefault. See #2000 if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) { preventDefault(e); }

_handlePointer(e, handler);

});

obj['_leaflet_touchstart' + id] = onDown; obj.addEventListener(POINTER_DOWN, onDown, false);"|data_input/cargotracker/cargotracker.txt|ddaf291e7e9c47778c18bfbee050073a
"_handlePointer(e, handler);

});

obj['_leaflet_touchstart' + id] = onDown; obj.addEventListener(POINTER_DOWN, onDown, false);

// need to keep track of what pointers and how many are active to provide e.touches emulation if (!_pointerDocListener) { // we listen document as any drags that end by moving the touch off the screen get fired there document.addEventListener(POINTER_DOWN, _globalPointerDown, true); document.addEventListener(POINTER_MOVE, _globalPointerMove, true); document.addEventListener(POINTER_UP, _globalPointerUp, true); document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

_pointerDocListener = true;

}

}

function _globalPointerDown(e) {

_pointers[e.pointerId] = e;

}

function _globalPointerMove(e) {

if (_pointers[e.pointerId]) {

_pointers[e.pointerId] = e;

}

}

function _globalPointerUp(e) {

delete _pointers[e.pointerId];

}

function _handlePointer(e, handler) { e.touches = []; for (var i in _pointers) { e.touches.push(_pointers[i]); } e.changedTouches = [e];

handler(e);

}

function _addPointerMove(obj, handler, id) { var onMove = function (e) { // don't fire touch moves when mouse isn't down if ((e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) && e.buttons === 0) { return; }

_handlePointer(e, handler);

};

obj['_leaflet_touchmove' + id] = onMove; obj.addEventListener(POINTER_MOVE, onMove, false); }

function _addPointerEnd(obj, handler, id) { var onUp = function (e) { _handlePointer(e, handler); };"|data_input/cargotracker/cargotracker.txt|46c7f6af496f413fa76398afa2dd8e4d
"function _addPointerEnd(obj, handler, id) { var onUp = function (e) { _handlePointer(e, handler); };

obj['_leaflet_touchend' + id] = onUp; obj.addEventListener(POINTER_UP, onUp, false); obj.addEventListener(POINTER_CANCEL, onUp, false); }

/* * Extends the event handling code with double tap support for mobile browsers. */

var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart'; var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend'; var _pre = '_leaflet_';

// inspired by Zepto touch code by Thomas Fuchs function addDoubleTapListener(obj, handler, id) { var last, touch$$1, doubleTap = false, delay = 250;

function onTouchStart(e) {

if (pointer) { if (!e.isPrimary) { return; } if (e.pointerType === 'mouse') { return; } // mouse fires native dblclick } else if (e.touches.length > 1) { return; }

var now = Date.now(),

delta = now

(last || now);

touch$$1 = e.touches ? e.touches[0] : e; doubleTap = (delta > 0 && delta <= delay); last = now; }

function onTouchEnd(e) { if (doubleTap && !touch$$1.cancelBubble) { if (pointer) { if (e.pointerType === 'mouse') { return; } // work around .type being readonly with MSPointer* events var newTouch = {}, prop, i;

for (i in touch$$1) { prop = touch$$1[i]; newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop; } touch$$1 = newTouch; } touch$$1.type = 'dblclick'; touch$$1.button = 0; handler(touch$$1); last = null; } }"|data_input/cargotracker/cargotracker.txt|782eb1d9ed834c31997a6010201f38e1
"obj[_pre + _touchstart + id] = onTouchStart; obj[_pre + _touchend + id] = onTouchEnd; obj[_pre + 'dblclick' + id] = handler;

obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {passive: false} : false); obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {passive: false} : false);

// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse), // the browser doesn't fire touchend/pointerup events but does fire // native dblclicks. See #4127. // Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180. obj.addEventListener('dblclick', handler, false);

return this;

}

function removeDoubleTapListener(obj, id) { var touchstart = obj[_pre + _touchstart + id], touchend = obj[_pre + _touchend + id], dblclick = obj[_pre + 'dblclick' + id];

obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {passive: false} : false); obj.removeEventListener(_touchend, touchend, passiveEvents ? {passive: false} : false); obj.removeEventListener('dblclick', dblclick, false);

return this;

}

/* * @namespace DomUtil * * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model) * tree, used by Leaflet internally. * * Most functions expecting or returning a `HTMLElement` also work for * SVG elements. The only difference is that classes refer to CSS classes * in HTML and SVG classes in SVG. */"|data_input/cargotracker/cargotracker.txt|f5b49a5ec6484c348c0dc00d62978b73
"// @property TRANSFORM: String // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit). var TRANSFORM = testProp( ['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do // the same for the transitionend event, in particular the Android 4.1 stock browser

// @property TRANSITION: String // Vendor-prefixed transition style name. var TRANSITION = testProp( ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

// @property TRANSITION_END: String // Vendor-prefixed transitionend event name. var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';

// @function get(id: String|HTMLElement): HTMLElement // Returns an element given its DOM id, or returns the element itself // if it was passed directly. function get(id) { return typeof id === 'string' ? document.getElementById(id) : id; }

// @function getStyle(el: HTMLElement, styleAttrib: String): String // Returns the value for a certain style attribute on an element, // including computed values or values set through CSS. function getStyle(el, style) { var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);"|data_input/cargotracker/cargotracker.txt|13ac453705f747afb148c742831400a4
"if ((!value || value === 'auto') && document.defaultView) { var css = document.defaultView.getComputedStyle(el, null); value = css ? css[style] : null; } return value === 'auto' ? null : value; }

// @function create(tagName: String, className? : String, container? : HTMLElement): HTMLElement // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element. function create$1(tagName, className, container) { var el = document.createElement(tagName); el.className = className || '';

if (container) {

container.appendChild(el);

}

return el;

}

// @function remove(el: HTMLElement) // Removes `el` from its parent element function remove(el) { var parent = el.parentNode; if (parent) { parent.removeChild(el); } }

// @function empty(el: HTMLElement) // Removes all of `el`'s children elements from `el` function empty(el) { while (el.firstChild) { el.removeChild(el.firstChild); } }

// @function toFront(el: HTMLElement) // Makes `el` the last child of its parent, so it renders in front of the other children. function toFront(el) { var parent = el.parentNode; if (parent && parent.lastChild !== el) { parent.appendChild(el); } }

// @function toBack(el: HTMLElement) // Makes `el` the first child of its parent, so it renders behind the other children. function toBack(el) { var parent = el.parentNode; if (parent && parent.firstChild !== el) { parent.insertBefore(el, parent.firstChild); } }"|data_input/cargotracker/cargotracker.txt|4e72880e184448da934eddb8edd21c1a
"// @function hasClass(el: HTMLElement, name: String): Boolean // Returns `true` if the element's class attribute contains `name`. function hasClass(el, name) { if (el.classList !== undefined) { return el.classList.contains(name); } var className = getClass(el); return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className); }

// @function addClass(el: HTMLElement, name: String) // Adds `name` to the element's class attribute. function addClass(el, name) { if (el.classList !== undefined) { var classes = splitWords(name); for (var i = 0, len = classes.length; i < len; i++) { el.classList.add(classes[i]); } } else if (!hasClass(el, name)) { var className = getClass(el); setClass(el, (className ? className + ' ' : '') + name); } }

// @function removeClass(el: HTMLElement, name: String) // Removes `name` from the element's class attribute. function removeClass(el, name) { if (el.classList !== undefined) { el.classList.remove(name); } else { setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' '))); } }

// @function setClass(el: HTMLElement, name: String) // Sets the element's class. function setClass(el, name) { if (el.className.baseVal === undefined) { el.className = name; } else { // in case of SVG element el.className.baseVal = name; } }"|data_input/cargotracker/cargotracker.txt|73fc497d4eeb45338919bf999be4761d
"// @function getClass(el: HTMLElement): String // Returns the element's class. function getClass(el) { // Check if the element is an SVGElementInstance and use the correspondingElement instead // (Required for linked SVG elements in IE11.) if (el.correspondingElement) { el = el.correspondingElement; } return el.className.baseVal === undefined ? el.className : el.className.baseVal; }

// @function setOpacity(el: HTMLElement, opacity: Number) // Set the opacity of an element (including old IE support). // `opacity` must be a number from `0` to `1`. function setOpacity(el, value) { if ('opacity' in el.style) { el.style.opacity = value; } else if ('filter' in el.style) { _setOpacityIE(el, value); } }

function _setOpacityIE(el, value) {

var filter = false,

filterName = 'DXImageTransform.Microsoft.Alpha';

// filters collection throws an error if we try to retrieve a filter that doesn't exist try { filter = el.filters.item(filterName); } catch (e) { // don't set opacity to 1 if we haven't already set an opacity, // it isn't needed and breaks transparent pngs. if (value === 1) { return; } }

value = Math.round(value

100);

if (filter) { filter.Enabled = (value !== 100); filter.Opacity = value; } else { el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')'; } }"|data_input/cargotracker/cargotracker.txt|00a300743e9345b3887bb5bfaaa49707
"// @function testProp(props: String[]): String|false // Goes through the array of style names and returns the first name // that is a valid style name for an element. If no such name is found, // it returns false. Useful for vendor-prefixed styles like `transform`. function testProp(props) { var style = document.documentElement.style;

for (var i = 0; i < props.length; i++) { if (props[i] in style) { return props[i]; } } return false; }

// @function setTransform(el: HTMLElement, offset: Point, scale? : Number) // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels // and optionally scaled by `scale`. Does not have an effect if the // browser doesn't support 3D CSS transforms. function setTransform(el, offset, scale) { var pos = offset || new Point(0, 0);

el.style[TRANSFORM] = (ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : ''); }

// @function setPosition(el: HTMLElement, position: Point) // Sets the position of `el` to coordinates specified by `position`, // using CSS translate or top/left positioning depending on the browser // (used by Leaflet internally to position its layers). function setPosition(el, point) {

/

eslint

disable

/

el._leaflet_pos = point;

/

eslint

enable

/

if (any3d) { setTransform(el, point); } else { el.style.left = point.x + 'px'; el.style.top = point.y + 'px'; } }"|data_input/cargotracker/cargotracker.txt|519d4b7159534c55b01c839f38aae2ce
"/

eslint

enable

/

if (any3d) { setTransform(el, point); } else { el.style.left = point.x + 'px'; el.style.top = point.y + 'px'; } }

// @function getPosition(el: HTMLElement): Point // Returns the coordinates of an element previously positioned with setPosition. function getPosition(el) { // this method is only used for elements previously positioned using setPosition, // so it's safe to cache the position for performance

return el._leaflet_pos || new Point(0, 0); } /* * @namespace DomEvent * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally. */

var eventsKey = '_leaflet_events';

// @function off(el: HTMLElement, types: String, fn: Function, context? : Object): this // Removes a previously added listener function. // Note that if you passed a custom context to on, you must pass the same // context to `off` in order to remove the listener.

// @alternative // @function off(el: HTMLElement, eventMap: Object, context? : Object): this // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}` function off(obj, types, fn, context) {

if (typeof types === 'object') { for (var type in types) { removeOne(obj, type, types[type], fn); } } else if (types) { types = splitWords(types);"|data_input/cargotracker/cargotracker.txt|f2a4b9afad0a4f60a80c4ac84ea36906
"if (typeof types === 'object') { for (var type in types) { removeOne(obj, type, types[type], fn); } } else if (types) { types = splitWords(types);

for (var i = 0, len = types.length; i < len; i++) { removeOne(obj, types[i], fn, context); } } else { for (var j in obj[eventsKey]) { removeOne(obj, j, obj[eventsKey][j]); } delete obj[eventsKey]; }

return this;

}

function browserFiresNativeDblClick() {

// See https://github.com/w3c/pointerevents/issues/171

if (pointer) {

return ! (edge || safari);

}

}

var mouseSubst = { mouseenter: 'mouseover', mouseleave: 'mouseout', wheel: ! ('onwheel' in window) && 'mousewheel' };

function addOne(obj, type, fn, context) { var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

var handler = function (e) { return fn.call(context || obj, e || window.event); };

var originalHandler = handler;

if (pointer && type.indexOf('touch') === 0) { // Needs DomEvent.Pointer.js addPointerListener(obj, type, handler, id);

} else if (touch && (type === 'dblclick') && !browserFiresNativeDblClick()) { addDoubleTapListener(obj, handler, id);

} else if ('addEventListener' in obj) {

if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' ||  type === 'mousewheel') { obj.addEventListener(mouseSubst[type] || type, handler, passiveEvents ? {passive: false} : false);"|data_input/cargotracker/cargotracker.txt|61a70233ac6c495fb8e5c94db2659c9d
"} else if (type === 'mouseenter' || type === 'mouseleave') { handler = function (e) { e = e || window.event; if (isExternalTarget(obj, e)) { originalHandler(e); } }; obj.addEventListener(mouseSubst[type], handler, false);

} else {

obj.addEventListener(type, originalHandler, false);

}

} else if ('attachEvent' in obj) { obj.attachEvent('on' + type, handler); }

obj[eventsKey] = obj[eventsKey] || {}; obj[eventsKey][id] = handler; }

function removeOne(obj, type, fn, context) {

var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''), handler = obj[eventsKey] && obj[eventsKey][id];

if (!handler) { return this; }

if (pointer && type.indexOf('touch') === 0) { removePointerListener(obj, type, id);

} else if (touch && (type === 'dblclick') && !browserFiresNativeDblClick()) { removeDoubleTapListener(obj, id);

} else if ('removeEventListener' in obj) {

obj.removeEventListener(mouseSubst[type] || type, handler, false);

} else if ('detachEvent' in obj) { obj.detachEvent('on' + type, handler); }

obj[eventsKey][id] = null;

}

// @function disableScrollPropagation(el: HTMLElement): this // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants). function disableScrollPropagation(el) { addOne(el, 'wheel', stopPropagation); return this; }"|data_input/cargotracker/cargotracker.txt|2aa5a0e5ccf2470cbe189f2835edbb78
"// @function disableClickPropagation(el: HTMLElement): this // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`, // `'mousedown'` and `'touchstart'` events (plus browser variants). function disableClickPropagation(el) { on(el, 'mousedown touchstart dblclick', stopPropagation); addOne(el, 'click', fakeStop); return this; }

// @function preventDefault(ev: DOMEvent): this // Prevents the default action of the DOM Event `ev` from happening (such as // following a link in the href of the a element, or doing a POST request // with page reload when a `<form>` is submitted). // Use it inside listener functions. function preventDefault(e) { if (e.preventDefault) { e.preventDefault(); } else { e.returnValue = false; } return this; }

// @function stop(ev: DOMEvent): this // Does `stopPropagation` and `preventDefault` at the same time. function stop(e) { preventDefault(e); stopPropagation(e); return this; }

// @function getMousePosition(ev: DOMEvent, container? : HTMLElement): Point // Gets normalized mouse position from a DOM event relative to the // `container` (border excluded) or to the whole page if not specified. function getMousePosition(e, container) { if (!container) { return new Point(e.clientX, e.clientY); }

var scale = getScale(container), offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)"|data_input/cargotracker/cargotracker.txt|ff30dd8c38e948028b5e43aa9a45deea
"var scale = getScale(container), offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

return new Point( // offset.left/top values are in page scale (like clientX/Y), // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies). (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop ); }

// Chrome on Win scrolls double the pixels as in other platforms (see #4538), // and Firefox scrolls device pixels, not CSS pixels var wheelPxFactor = (win && chrome) ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1;"|data_input/cargotracker/cargotracker.txt|74be565417b4435cb43c995d2f01568f
"// @function getWheelDelta(ev: DOMEvent): Number // Gets normalized wheel delta from a wheel DOM event, in vertical // pixels scrolled (negative if scrolling down). // Events from pointing devices without precise scrolling are mapped to // a best guess of 60 pixels. function getWheelDelta(e) { return (edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages 0; }

var skipEvents = {};

function fakeStop(e) { // fakes stopPropagation by setting a special event flag, checked/reset with skipped(e) skipEvents[e.type] = true; }

function skipped(e) { var events = skipEvents[e.type]; // reset when checking, as it's only used in map container and propagates outside of the map skipEvents[e.type] = false; return events; }

// check if element really left/entered the event target (for mouseenter/mouseleave) function isExternalTarget(el, e) {

var related = e.relatedTarget;

if (!related) { return true; }"|data_input/cargotracker/cargotracker.txt|ebf20d8fad20430f8dd65c67a9588156
"var related = e.relatedTarget;

if (!related) { return true; }

try { while (related && (related !== el)) { related = related.parentNode; } } catch (err) { return false; } return (related !== el); }

var DomEvent = ({

on: on,

off: off,

stopPropagation: stopPropagation,

disableScrollPropagation: disableScrollPropagation,

disableClickPropagation: disableClickPropagation,

preventDefault: preventDefault,

stop: stop,

getMousePosition: getMousePosition,

getWheelDelta: getWheelDelta,

fakeStop: fakeStop,

skipped: skipped,

isExternalTarget: isExternalTarget,

addListener: on,

removeListener: off

});

/* * @class PosAnimation * @aka L.PosAnimation * @inherits Evented * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9. * * @example * ```js * var fx = new L.PosAnimation(); * fx.run(el, [300, 500], 0.5); * ``` * * @constructor L.PosAnimation() * Creates a `PosAnimation` object. * */

var PosAnimation = Evented.extend({

// @method run(el: HTMLElement, newPos: Point, duration? : Number, easeLinearity? : Number) // Run an animation of a given element to a new position, optionally setting // duration in seconds (`0.25` by default) and easing linearity factor (3rd // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1), // `0.5` by default). run: function (el, newPos, duration, easeLinearity) { this.stop();"|data_input/cargotracker/cargotracker.txt|c4efb0f2168b4ab39ff17008d4901556
"this._el = el; this._inProgress = true; this._duration = duration || 0.25; this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

this._startPos = getPosition(el);

this._offset = newPos.subtract(this._startPos);

this._startTime = +new Date();

// @event start: Event // Fired when the animation starts this.fire('start');

this._animate();

},

// @method stop() // Stops the animation (if currently running). stop: function () { if (!this._inProgress) { return; }

this._step(true);

this._complete();

},

_animate: function () {

// animation loop

this._animId = requestAnimFrame(this._animate, this);

this._step();

},

_step: function (round) { var elapsed = (+new Date()) - this._startTime, duration = this._duration * 1000;

if (elapsed < duration) { this._runFrame(this._easeOut(elapsed / duration), round); } else { this._runFrame(1); this._complete(); } },

_runFrame: function (progress, round) { var pos = this._startPos.add(this._offset.multiplyBy(progress)); if (round) { pos._round(); } setPosition(this._el, pos);

// @event step: Event // Fired continuously during the animation. this.fire('step'); },

_complete: function () {

cancelAnimFrame(this._animId);

this._inProgress = false; // @event end: Event // Fired when the animation ends. this.fire('end'); },

_easeOut: function (t) {

return 1

Math.pow(1

t, this._easeOutPower);

}

});"|data_input/cargotracker/cargotracker.txt|6a5767398b504d3e833b6e37c9a43f12
"_easeOut: function (t) {

return 1

Math.pow(1

t, this._easeOutPower);

}

});

/* * @class Map * @aka L.Map * @inherits Evented * * The central class of the API  it is used to create a map on a page and manipulate it. * * @example * * ```js * // initialize the map on the ""map"" div with a given center and zoom * var map = L.map('map', { * 	center: [51.505, -0.09], * 	zoom: 13 * }); * ``` * */

var Map = Evented.extend({

options: { // @section Map State Options // @option crs: CRS = L.CRS.EPSG3857 // The [Coordinate Reference System](#crs) to use. Don't change this if you're not // sure what it means. crs: EPSG3857,

// @option center: LatLng = undefined // Initial geographic center of the map center: undefined,

// @option zoom: Number = undefined // Initial map zoom level zoom: undefined,

// @option minZoom: Number = * // Minimum zoom level of the map. // If not specified and at least one `GridLayer` or `TileLayer` is in the map, // the lowest of their `minZoom` options will be used instead. minZoom: undefined,

// @option maxZoom: Number = * // Maximum zoom level of the map. // If not specified and at least one `GridLayer` or `TileLayer` is in the map, // the highest of their `maxZoom` options will be used instead. maxZoom: undefined,

// @option layers: Layer[] = [] // Array of layers that will be added to the map initially layers: [],"|data_input/cargotracker/cargotracker.txt|26b1cd7b88bd46169eb6f2bffb2bb7b7
text|source|chunk_id
"// @option layers: Layer[] = [] // Array of layers that will be added to the map initially layers: [],

// @option maxBounds: LatLngBounds = null // When this option is set, the map restricts the view to the given // geographical bounds, bouncing the user back if the user tries to pan // outside the view. To set the restriction dynamically, use // [`setMaxBounds`](#map-setmaxbounds) method. maxBounds: undefined,

// @option renderer: Renderer = * // The default method for drawing vector layers on the map. `L.SVG` // or `L.Canvas` by default depending on browser support. renderer: undefined,

// @section Animation Options // @option zoomAnimation: Boolean = true // Whether the map zoom animation is enabled. By default it's enabled // in all browsers that support CSS3 Transitions except Android. zoomAnimation: true,

// @option zoomAnimationThreshold: Number = 4 // Won't animate zoom if the zoom difference exceeds this value. zoomAnimationThreshold: 4,

// @option fadeAnimation: Boolean = true // Whether the tile fade animation is enabled. By default it's enabled // in all browsers that support CSS3 Transitions except Android. fadeAnimation: true,

// @option markerZoomAnimation: Boolean = true // Whether markers animate their zoom with the zoom animation, if disabled // they will disappear for the length of the animation. By default it's // enabled in all browsers that support CSS3 Transitions except Android. markerZoomAnimation: true,"|data_input/cargotracker/cargotracker.txt|06241be308a547e496b2a4bca05cca4d
"// @option transform3DLimit: Number = 2^23 // Defines the maximum size of a CSS translation transform. The default // value should not be changed unless a web browser positions layers in // the wrong place after doing a large `panBy`. transform3DLimit: 8388608, // Precision limit of a 32-bit float

// @section Interaction Options // @option zoomSnap: Number = 1 // Forces the map's zoom level to always be a multiple of this, particularly // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom. // By default, the zoom level snaps to the nearest integer; lower values // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0` // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom. zoomSnap: 1,

// @option zoomDelta: Number = 1 // Controls how much the map's zoom level will change after a // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+` // or `-` on the keyboard, or using the [zoom controls](#control-zoom). // Values smaller than `1` (e.g. `0.5`) allow for greater granularity. zoomDelta: 1,

// @option trackResize: Boolean = true // Whether the map automatically handles browser window resize to update itself. trackResize: true },

initialize: function (id, options) { // (HTMLElement or String, Object) options = setOptions(this, options);"|data_input/cargotracker/cargotracker.txt|68aa07ab2dfe48ef937b0592ddb76f6f
"initialize: function (id, options) { // (HTMLElement or String, Object) options = setOptions(this, options);

// Make sure to assign internal flags at the beginning, // to avoid inconsistent state in some edge cases. this._handlers = []; this._layers = {}; this._zoomBoundLayers = {}; this._sizeChanged = true;

this._initContainer(id);

this._initLayout();

// hack for https://github.com/Leaflet/Leaflet/issues/1980

this._onResize = bind(this._onResize, this);

this._initEvents();

if (options.maxBounds) {

this.setMaxBounds(options.maxBounds);

}

if (options.zoom !== undefined) { this._zoom = this._limitZoom(options.zoom); }

if (options.center && options.zoom !== undefined) { this.setView(toLatLng(options.center), options.zoom, {reset: true}); }

this.callInitHooks();

// don't animate on browsers without hardware-accelerated transitions or old Android/Opera this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation;

// zoom transitions run with the same duration for all layers, so if one of transitionend events // happens after starting zoom animation (propagating to the map pane), we know that it ended globally if (this._zoomAnimated) { this._createAnimProxy(); on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this); }

this._addLayers(this.options.layers);

},

// @section Methods for modifying map state"|data_input/cargotracker/cargotracker.txt|27ff7324ff9d49b79b5025763b2f2992
"this._addLayers(this.options.layers);

},

// @section Methods for modifying map state

// @method setView(center: LatLng, zoom: Number, options? : Zoom/pan options): this // Sets the view of the map (geographical center and zoom) with the given // animation options. setView: function (center, zoom, options) {

zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom); center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds); options = options || {};

this._stop();

if (this._loaded && !options.reset && options !== true) {

if (options.animate !== undefined) { options.zoom = extend({animate: options.animate}, options.zoom); options.pan = extend({animate: options.animate, duration: options.duration}, options.pan); }

// try animating pan or zoom var moved = (this._zoom !== zoom) ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

if (moved) { // prevent resize handler call, the view will refresh after animation anyway clearTimeout(this._sizeTimer); return this; } }

// animation didn't start, just reset the map view this._resetView(center, zoom);

return this;

},

// @method setZoom(zoom: Number, options? : Zoom/pan options): this // Sets the zoom of the map. setZoom: function (zoom, options) { if (!this._loaded) { this._zoom = zoom; return this; } return this.setView(this.getCenter(), zoom, {zoom: options}); },"|data_input/cargotracker/cargotracker.txt|74691ef27b704d7cb2357008cf7e9ff9
"// @method zoomIn(delta? : Number, options? : Zoom options): this // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default). zoomIn: function (delta, options) { delta = delta || (any3d ? this.options.zoomDelta : 1); return this.setZoom(this._zoom + delta, options); },

// @method zoomOut(delta? : Number, options? : Zoom options): this // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default). zoomOut: function (delta, options) { delta = delta || (any3d ? this.options.zoomDelta : 1); return this.setZoom(this._zoom - delta, options); }, // @section

// @factory L.map(id: String, options? : Map options) // Instantiates a map object given the DOM ID of a `<div>` element // and optionally an object literal with `Map options`. // // @alternative // @factory L.map(el: HTMLElement, options? : Map options) // Instantiates a map object given an instance of a `<div>` HTML element // and optionally an object literal with `Map options`. function createMap(id, options) { return new Map(id, options); }

/* * @class Control * @aka L.Control * @inherits Class * * L.Control is a base class for implementing map controls. Handles positioning. * All other controls extend from this class. */"|data_input/cargotracker/cargotracker.txt|0f79a45f89174e9a98b39b5fe6407dd3
"var Control = Class.extend({ // @section // @aka Control options options: { // @option position: String = 'topright' // The position of the control (one of the map corners). Possible values are `'topleft'`, // `'topright'`, `'bottomleft'` or `'bottomright'` position: 'topright' },

initialize: function (options) {

setOptions(this, options);

},

/* @section * Classes extending L.Control will inherit the following methods: * * @method getPosition: string * Returns the position of the control. */ getPosition: function () { return this.options.position; },

// @method setPosition(position: string): this // Sets the position of the control. setPosition: function (position) { var map = this._map;

if (map) {

map.removeControl(this);

}

this.options.position = position;

if (map) {

map.addControl(this);

}

return this;

},

// @method getContainer: HTMLElement // Returns the HTMLElement that contains the control. getContainer: function () { return this._container; },

// @method addTo(map: Map): this // Adds the control to the given map. addTo: function (map) { this.remove(); this._map = map;

var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];

addClass(container, 'leaflet

control');

if (pos.indexOf('bottom') !==

1) {

corner.insertBefore(container, corner.firstChild);

} else {

corner.appendChild(container);

}

this._map.on('unload', this.remove, this);

return this;

},"|data_input/cargotracker/cargotracker.txt|008bd277e6dc448192bc570f662c6a32
"} else {

corner.appendChild(container);

}

this._map.on('unload', this.remove, this);

return this;

},

// @method remove: this // Removes the control from the map it is currently active on. remove: function () { if (!this._map) { return this; }

remove(this._container);

if (this.onRemove) {

this.onRemove(this._map);

}

this._map.off('unload', this.remove, this);

this._map = null;

return this;

},

_refocusOnMap: function (e) { // if map exists and event is not a keyboard event if (this._map && e && e.screenX > 0 && e.screenY > 0) { this._map.getContainer().focus(); } } });

var control = function (options) { return new Control(options); };

/* @section Extension methods * @uninheritable * * Every control should extend from `L.Control` and (re-)implement the following methods. * * @method onAdd(map: Map): HTMLElement * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo). * * @method onRemove(map: Map) * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove). */

// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe) _createRadioElement: function (name, checked) {"|data_input/cargotracker/cargotracker.txt|c16019fe73264ec4ab6be0a31d0dff70
"var radioHtml = '<input type=""radio"" class=""leaflet-control-layers-selector"" name=""' + name + '""' + (checked ? ' checked=""checked""' : '') + '/>';

var radioFragment = document.createElement('div');

radioFragment.innerHTML = radioHtml;

return radioFragment.firstChild;

},

// Bugfix issue 2318: Should remove all old layers before readding new ones for (i = 0; i < removedLayers.length; i++) { if (this._map.hasLayer(removedLayers[i])) { this._map.removeLayer(removedLayers[i]); } } for (i = 0; i < addedLayers.length; i++) { if (!this._map.hasLayer(addedLayers[i])) { this._map.addLayer(addedLayers[i]); } }

this._handlingClick = false;

this._refocusOnMap();

},

_checkDisabledLayers: function () {

var inputs = this._layerControlInputs,

input,

layer,

zoom = this._map.getZoom();

for (var i = inputs.length - 1; i >= 0; i--) { input = inputs[i]; layer = this._getLayer(input.layerId).layer; input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) || (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

}

},

_expandIfNotCollapsed: function () { if (this._map && !this.options.collapsed) { this.expand(); } return this; },

_expand: function () { // Backward compatibility, remove me in 1.1. return this.expand(); },

_collapse: function () { // Backward compatibility, remove me in 1.1. return this.collapse(); }"|data_input/cargotracker/cargotracker.txt|e504296836764406b9efb205825c70b0
"_collapse: function () { // Backward compatibility, remove me in 1.1. return this.collapse(); }

}); // @namespace Map // @section Control options // @option zoomControl: Boolean = true // Whether a [zoom control](#control-zoom) is added to the map by default. Map.mergeOptions({ zoomControl: true });

Map.addInitHook(function () { if (this.options.zoomControl) { // @section Controls // @property zoomControl: Control.Zoom // The default zoom control (only available if the // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map). this.zoomControl = new Zoom(); this.addControl(this.zoomControl); } });

// @namespace Control.Zoom // @factory L.control.zoom(options: Control.Zoom options) // Creates a zoom control var zoom = function (options) { return new Zoom(options); };

/* * @class Control.Scale * @aka L.Control.Scale * @inherits Control * * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`. * * @example * * ```js * L.control.scale().addTo(map); * ``` */

var Scale = Control.extend({

// @section

// @aka Control.Scale options

options: {

position: 'bottomleft',

// @option maxWidth: Number = 100 // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500). maxWidth: 100,

// @option metric: Boolean = True // Whether to show the metric scale line (m/km). metric: true,"|data_input/cargotracker/cargotracker.txt|1a579945c10a417da6f473502a9219bc
"// @option metric: Boolean = True // Whether to show the metric scale line (m/km). metric: true,

// @option imperial: Boolean = True // Whether to show the imperial scale line (mi/ft). imperial: true

// @option updateWhenIdle: Boolean = false // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)). },

onAdd: function (map) {

var className = 'leaflet

control

scale',

container = create$1('div', className),

options = this.options;

this._addScales(options, className + '

line', container);

map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this); map.whenReady(this._update, this);

return container;

},

onRemove: function (map) { map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this); },

_addScales: function (options, className, container) { if (options.metric) { this._mScale = create$1('div', className, container); } if (options.imperial) { this._iScale = create$1('div', className, container); } },

_update: function () { var map = this._map, y = map.getSize().y / 2;

var maxMeters = map.distance(

map.containerPointToLatLng([0, y]),

map.containerPointToLatLng([this.options.maxWidth, y]));

this._updateScales(maxMeters);

},

_updateScales: function (maxMeters) { if (this.options.metric && maxMeters) { this._updateMetric(maxMeters); } if (this.options.imperial && maxMeters) { this._updateImperial(maxMeters); } },"|data_input/cargotracker/cargotracker.txt|b81e3c9071794afa8762e4be38bbf786
"_updateMetric: function (maxMeters) { var meters = this._getRoundNum(maxMeters), label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

this._updateScale(this._mScale, label, meters / maxMeters); },

_updateImperial: function (maxMeters) {

var maxFeet = maxMeters

3.2808399,

maxMiles, miles, feet;

if (maxFeet > 5280) { maxMiles = maxFeet / 5280; miles = this._getRoundNum(maxMiles); this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

} else { feet = this._getRoundNum(maxFeet); this._updateScale(this._iScale, feet + ' ft', feet / maxFeet); } },

_updateScale: function (scale, text, ratio) { scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px'; scale.innerHTML = text; },

_getRoundNum: function (num) { var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1), d = num / pow10;

d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

return pow10

d;

}

});

// @factory L.control.scale(options? : Control.Scale options) // Creates an scale control with the given options. var scale = function (options) { return new Scale(options); };"|data_input/cargotracker/cargotracker.txt|b314bbbe0fb743ee9a1f35a885c4c41c
"/* * @class Control.Attribution * @aka L.Control.Attribution * @inherits Control * * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control. */

var Attribution = Control.extend({

// @section

// @aka Control.Attribution options

options: {

position: 'bottomright',

// @option prefix: String = 'Leaflet' // The HTML text shown before the attributions. Pass `false` to disable. prefix: '<a href=""https://leafletjs.com"" title=""A JS library for interactive maps"">Leaflet</a>' },

initialize: function (options) {

setOptions(this, options);

this._attributions = {};

},

onAdd: function (map) {

map.attributionControl = this;

this._container = create$1('div', 'leaflet

control

attribution');

disableClickPropagation(this._container);

// TODO ugly, refactor for (var i in map._layers) { if (map._layers[i].getAttribution) { this.addAttribution(map._layers[i].getAttribution()); } }

this._update();

return this._container;

},

// @method setPrefix(prefix: String): this // Sets the text before the attributions. setPrefix: function (prefix) { this.options.prefix = prefix; this._update(); return this; },"|data_input/cargotracker/cargotracker.txt|e762c841fe2a41e2999fe121922e0759
"// @method addAttribution(text: String): this // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`). addAttribution: function (text) { if (!text) { return this; }

if (!this._attributions[text]) {

this._attributions[text] = 0;

}

this._attributions[text]++;

this._update();

return this;

},

// @method removeAttribution(text: String): this // Removes an attribution text. removeAttribution: function (text) { if (!text) { return this; }

if (this._attributions[text]) {

this._attributions[text]-

;

this._update();

}

return this;

},

_update: function () { if (!this._map) { return; }

var attribs = [];

for (var i in this._attributions) { if (this._attributions[i]) { attribs.push(i); } }

var prefixAndAttribs = [];

if (this.options.prefix) {

prefixAndAttribs.push(this.options.prefix);

}

if (attribs.length) {

prefixAndAttribs.push(attribs.join(', '));

}

this._container.innerHTML = prefixAndAttribs.join(' | '); } });

// @namespace Map // @section Control options // @option attributionControl: Boolean = true // Whether a [attribution control](#control-attribution) is added to the map by default. Map.mergeOptions({ attributionControl: true });

Map.addInitHook(function () {

if (this.options.attributionControl) {

new Attribution().addTo(this);

}

});"|data_input/cargotracker/cargotracker.txt|976ec959da774b31b5f84205a547c7ab
"Map.addInitHook(function () {

if (this.options.attributionControl) {

new Attribution().addTo(this);

}

});

// @namespace Control.Attribution // @factory L.control.attribution(options: Control.Attribution options) // Creates an attribution control. var attribution = function (options) { return new Attribution(options); };

Control.Layers = Layers;

Control.Zoom = Zoom;

Control.Scale = Scale;

Control.Attribution = Attribution;

control.layers = layers;

control.zoom = zoom;

control.scale = scale;

control.attribution = attribution;

/* L.Handler is a base class for handler classes that are used internally to inject interaction features like dragging to classes like Map and Marker. */

// @class Handler // @aka L.Handler // Abstract class for map interaction handlers

var Handler = Class.extend({

initialize: function (map) {

this._map = map;

},

// @method enable(): this // Enables the handler enable: function () { if (this._enabled) { return this; }

this._enabled = true;

this.addHooks();

return this;

},

// @method disable(): this // Disables the handler disable: function () { if (!this._enabled) { return this; }

this._enabled = false;

this.removeHooks();

return this;

},

// @method enabled(): Boolean // Returns `true` if the handler is enabled enabled: function () { return ! !this._enabled; }"|data_input/cargotracker/cargotracker.txt|e2f9044eb8c44035b788c9555880636e
"return this;

},

// @method enabled(): Boolean // Returns `true` if the handler is enabled enabled: function () { return ! !this._enabled; }

// @section Extension methods // Classes inheriting from `Handler` must implement the two following methods: // @method addHooks() // Called when the handler is enabled, should add event hooks. // @method removeHooks() // Called when the handler is disabled, should remove the event hooks added previously. });

// @section There is static function which can be called without instantiating L.Handler: // @function addTo(map: Map, name: String): this // Adds a new Handler to the given map with the given name. Handler.addTo = function (map, name) { map.addHandler(name, this); return this; };

if (!tolerance || !points.length) { return points.slice(); }

var sqTolerance = tolerance

tolerance;

// stage 1: vertex reduction points = _reducePoints(points, sqTolerance);

// stage 2: Douglas

Peucker simplification

points = _simplifyDP(points, sqTolerance);

return points;

}

// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number // Returns the distance between point `p` and segment `p1` to `p2`. function pointToSegmentDistance(p, p1, p2) { return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true)); }"|data_input/cargotracker/cargotracker.txt|80bcc1c32e0846efae4b5a0c29c5ef35
"// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number // Returns the closest point from a point `p` on a segment `p1` to `p2`. function closestPointOnSegment(p, p1, p2) { return _sqClosestPointOnSegment(p, p1, p2); }

// Douglas

Peucker simplification, see http://en.wikipedia.org/wiki/Douglas

Peucker_algorithm

function _simplifyDP(points, sqTolerance) {

var len = points.length, ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array, markers = new ArrayConstructor(len);

markers[0] = markers[len

1] = 1;

_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

var i,

newPoints = [];

for (i = 0; i < len; i++) { if (markers[i]) { newPoints.push(points[i]); } }

return newPoints;

}

function _simplifyDPStep(points, markers, sqTolerance, first, last) {

var maxSqDist = 0,

index, i, sqDist;

for (i = first + 1; i <= last - 1; i++) { sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

if (sqDist > maxSqDist) { index = i; maxSqDist = sqDist; } }

if (maxSqDist > sqTolerance) { markers[index] = 1;

_simplifyDPStep(points, markers, sqTolerance, first, index); _simplifyDPStep(points, markers, sqTolerance, index, last); } }

// reduce points that are too close to each other to a single point function _reducePoints(points, sqTolerance) { var reducedPoints = [points[0]];"|data_input/cargotracker/cargotracker.txt|f54bbb34e80a4dcf9065e530c62e7283
"// reduce points that are too close to each other to a single point function _reducePoints(points, sqTolerance) { var reducedPoints = [points[0]];

for (var i = 1, prev = 0, len = points.length; i < len; i++) { if (_sqDist(points[i], points[prev]) > sqTolerance) { reducedPoints.push(points[i]); prev = i; } } if (prev < len - 1) { reducedPoints.push(points[len - 1]); } return reducedPoints; }

var _lastCode;

// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode? : Boolean, round? : Boolean): Point[]|Boolean // Clips the segment a to b by rectangular bounds with the // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm) // (modifying the segment points directly!). Used by Leaflet to only show polyline // points that are on the screen or near, increasing performance. function clipSegment(a, b, bounds, useLastCode, round) { var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds),

codeOut, p, newCode;

// save 2nd code to avoid calculating it on the next segment _lastCode = codeB;

while (true) { // if a,b is inside the clip window (trivial accept) if (! (codeA | codeB)) { return [a, b]; }

// if a,b is outside the clip window (trivial reject) if (codeA & codeB) { return false; }

// other cases codeOut = codeA || codeB; p = _getEdgeIntersection(a, b, codeOut, bounds, round); newCode = _getBitCode(p, bounds);"|data_input/cargotracker/cargotracker.txt|ed3ea64c35f74a6eaed17834f106f87d
"// other cases codeOut = codeA || codeB; p = _getEdgeIntersection(a, b, codeOut, bounds, round); newCode = _getBitCode(p, bounds);

if (codeOut === codeA) { a = p; codeA = newCode; } else { b = p; codeB = newCode; } } }

function _getEdgeIntersection(a, b, code, bounds, round) { var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;

if (code & 8) { // top x = a.x + dx * (max.y - a.y) / dy; y = max.y;

} else if (code & 4) { // bottom x = a.x + dx * (min.y - a.y) / dy; y = min.y;

} else if (code & 2) { // right x = max.x; y = a.y + dy * (max.x - a.x) / dx;

} else if (code & 1) { // left x = min.x; y = a.y + dy * (min.x - a.x) / dx; }

return new Point(x, y, round); }

function _getBitCode(p, bounds) {

var code = 0;

if (p.x < bounds.min.x) { // left code |= 1; } else if (p.x > bounds.max.x) { // right code |= 2; }

if (p.y < bounds.min.y) { // bottom code |= 4; } else if (p.y > bounds.max.y) { // top code |= 8; }

return code;

}

// square distance (to avoid unnecessary Math.sqrt calls) function _sqDist(p1, p2) { var dx = p2.x - p1.x, dy = p2.y - p1.y; return dx * dx + dy * dy; }

// return closest point on segment or distance to that point function _sqClosestPointOnSegment(p, p1, p2, sqDist) { var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;

if (dot > 0) { t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

if (t > 1) { x = p2.x; y = p2.y; } else if (t > 0) { x += dx * t; y += dy * t; } }

dx = p.x

x;

dy = p.y

y;"|data_input/cargotracker/cargotracker.txt|7da88a7a464248f7a51de720ea038e9c
"if (t > 1) { x = p2.x; y = p2.y; } else if (t > 0) { x += dx * t; y += dy * t; } }

dx = p.x

x;

dy = p.y

y;

return sqDist ? dx * dx + dy * dy : new Point(x, y); }

// @function isFlat(latlngs: LatLng[]): Boolean // Returns true if `latlngs` is a flat array, false is nested. function isFlat(latlngs) { return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined'); }

function _flat(latlngs) { console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead. '); return isFlat(latlngs); }

var LineUtil = ({

simplify: simplify,

pointToSegmentDistance: pointToSegmentDistance,

closestPointOnSegment: closestPointOnSegment,

clipSegment: clipSegment,

_getEdgeIntersection: _getEdgeIntersection,

_getBitCode: _getBitCode,

_sqClosestPointOnSegment: _sqClosestPointOnSegment,

isFlat: isFlat,

_flat: _flat

});

/* * @namespace PolyUtil * Various utility functions for polygon geometries. */"|data_input/cargotracker/cargotracker.txt|cb016567f9834899a108be3f5d996366
"isFlat: isFlat,

_flat: _flat

});

/* * @namespace PolyUtil * Various utility functions for polygon geometries. */

/* @function clipPolygon(points: Point[], bounds: Bounds, round? : Boolean): Point[] * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)). * Used by Leaflet to only show polygon points that are on the screen or near, increasing * performance. Note that polygon points needs different algorithm for clipping * than polyline, so there's a separate method for it. */ function clipPolygon(points, bounds, round) { var clippedPoints, edges = [1, 4, 2, 8], i, j, k, a, b, len, edge, p;

for (i = 0, len = points.length; i < len; i++) { points[i]._code = _getBitCode(points[i], bounds); }

// for each edge (left, bottom, right, top) for (k = 0; k < 4; k++) { edge = edges[k]; clippedPoints = [];

for (i = 0, len = points.length, j = len - 1; i < len; j = i++) { a = points[i]; b = points[j];

// if a is inside the clip window if (! (a._code & edge)) { // if b is outside the clip window (a->b goes out of screen) if (b._code & edge) { p = _getEdgeIntersection(b, a, edge, bounds, round); p._code = _getBitCode(p, bounds); clippedPoints.push(p); } clippedPoints.push(a);"|data_input/cargotracker/cargotracker.txt|d48c759e3cdf40dcb646b08cc78f4dfd
"// else if b is inside the clip window (a->b enters the screen) } else if (! (b._code & edge)) { p = _getEdgeIntersection(b, a, edge, bounds, round); p._code = _getBitCode(p, bounds); clippedPoints.push(p); } } points = clippedPoints; }

return points;

}

var PolyUtil = ({

clipPolygon: clipPolygon

});

/* * @namespace Projection * @section * Leaflet comes with a set of already defined Projections out of the box: * * @projection L.Projection.LonLat * * Equirectangular, or Plate Carree projection  the most simple projection, * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as * latitude. Also suitable for flat worlds, e.g. game maps. Used by the * `EPSG:4326` and `Simple` CRS. */

var LonLat = {

project: function (latlng) {

return new Point(latlng.lng, latlng.lat);

},

unproject: function (point) {

return new LatLng(point.y, point.x);

},

bounds: new Bounds([

180,

90], [180, 90])

};

/* * @namespace Projection * @projection L.Projection.Mercator * * Elliptical Mercator projection  more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS. */

var Mercator = {

R: 6378137,

R_MINOR: 6356752.314245179,

bounds: new Bounds([

20037508.34279,

15496570.73972], [20037508.34279, 18764656.23138]),

project: function (latlng) { var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);"|data_input/cargotracker/cargotracker.txt|925af338a6f2498d8a3bfbe9c263ba90
"var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2); y = -r * Math.log(Math.max(ts, 1E-10));

return new Point(latlng.lng

d

r, y);

},

unproject: function (point) { var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);

for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) { con = e * Math.sin(phi); con = Math.pow((1 - con) / (1 + con), e / 2); dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi; phi += dphi; }

return new LatLng(phi

d, point.x

d / r);

}

};

/

@class Projection

An object with methods for projecting geographical coordinates of the world onto

a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).

@property bounds: Bounds

The bounds (specified in CRS units) where the projection is valid

@method project(latlng: LatLng): Point

Projects geographical coordinates into a 2D point.

Only accepts actual `L.LatLng` instances, not arrays.

@method unproject(point: Point): LatLng

The inverse of `project`. Projects a 2D point into a geographical location.

Only accepts actual `L.Point` instances, not arrays.

Note that the projection instances do not inherit from Leaflet's `Class` object,

and can't be instantiated. Also, new classes can't inherit from them,

and methods can't be added to them with the `include` function.

/

var index = ({

LonLat: LonLat,"|data_input/cargotracker/cargotracker.txt|ded636dd4ff44f5281e1eafff03be021
"and methods can't be added to them with the `include` function.

/

var index = ({

LonLat: LonLat,

Mercator: Mercator,

SphericalMercator: SphericalMercator

});

/* * @namespace CRS * @crs L.CRS.EPSG3395 * * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection. */ var EPSG3395 = extend({}, Earth, { code: 'EPSG:3395', projection: Mercator,

transformation: (function () { var scale = 0.5 / (Math.PI * Mercator.R); return toTransformation(scale, 0.5, -scale, 0.5); }()) });

/* * @namespace CRS * @crs L.CRS.EPSG4326 * * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection. * * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic), * which is a breaking change from 0.7.x behaviour. If you are using a `TileLayer` * with this CRS, ensure that there are two 256x256 pixel tiles covering the * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90), * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set. */

var EPSG4326 = extend({}, Earth, { code: 'EPSG:4326', projection: LonLat, transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5) });"|data_input/cargotracker/cargotracker.txt|83ffaa7c391b484e95e080f8a221bab5
"var EPSG4326 = extend({}, Earth, { code: 'EPSG:4326', projection: LonLat, transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5) });

/* * @namespace CRS * @crs L.CRS.Simple * * A simple CRS that maps longitude and latitude into `x` and `y` directly. * May be used for maps of flat surfaces (e.g. game maps). Note that the `y` * axis should still be inverted (going from bottom to top). `distance()` returns * simple euclidean distance. */

var Simple = extend({}, CRS, { projection: LonLat, transformation: toTransformation(1, 0, -1, 0),

scale: function (zoom) {

return Math.pow(2, zoom);

},

zoom: function (scale) {

return Math.log(scale) / Math.LN2;

},

distance: function (latlng1, latlng2) { var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;

return Math.sqrt(dx

dx + dy

dy);

},

infinite: true

});

CRS.Earth = Earth;

CRS.EPSG3395 = EPSG3395;

CRS.EPSG3857 = EPSG3857;

CRS.EPSG900913 = EPSG900913;

CRS.EPSG4326 = EPSG4326;

CRS.Simple = Simple;

/* * @class Layer * @inherits Evented * @aka L.Layer * @aka ILayer * * A set of methods from the Layer base class that all Leaflet layers use. * Inherits all methods, options and events from `L.Evented`. * * @example * * ```js * var layer = L.marker(latlng).addTo(map); * layer.addTo(map); * layer.remove(); * ``` * * @event add: Event * Fired after the layer is added to a map * * @event remove: Event * Fired after the layer is removed from a map */

var Layer = Evented.extend({"|data_input/cargotracker/cargotracker.txt|df341690dda24af1b8ae5befc31c446a
"var Layer = Evented.extend({

// Classes extending `L.Layer` will inherit the following options: options: { // @option pane: String = 'overlayPane' // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default. pane: 'overlayPane',

// @option attribution: String = null // String to be shown in the attribution control, e.g. "" OpenStreetMap contributors"". It describes the layer data and is often a legal obligation towards copyright holders and tile providers. attribution: null,

bubblingMouseEvents: true

},

/* @section * Classes extending `L.Layer` will inherit the following methods: * * @method addTo(map: Map|LayerGroup): this * Adds the layer to the given map or layer group. */ addTo: function (map) { map.addLayer(this); return this; },

// @method remove: this // Removes the layer from the map it is currently active on. remove: function () { return this.removeFrom(this._map || this._mapToAdd); },

// @method removeFrom(map: Map): this // Removes the layer from the given map // // @alternative // @method removeFrom(group: LayerGroup): this // Removes the layer from the given `LayerGroup` removeFrom: function (obj) { if (obj) { obj.removeLayer(this); } return this; },"|data_input/cargotracker/cargotracker.txt|b26a05dfba1f4cfe8cadf439e68fa83c
"// @method getPane(name? : String): HTMLElement // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer. getPane: function (name) { return this._map.getPane(name ? (this.options[name] || name) : this.options.pane); },

addInteractiveTarget: function (targetEl) {

this._map._targets[stamp(targetEl)] = this;

return this;

},

removeInteractiveTarget: function (targetEl) {

delete this._map._targets[stamp(targetEl)];

return this;

},

// @method getAttribution: String // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution). getAttribution: function () { return this.options.attribution; },

_layerAdd: function (e) {

var map = e.target;

// check in case layer gets added and then removed before the map is ready if (!map.hasLayer(this)) { return; }

this._map = map;

this._zoomAnimated = map._zoomAnimated;

if (this.getEvents) {

var events = this.getEvents();

map.on(events, this);

this.once('remove', function () {

map.off(events, this);

}, this);

}

this.onAdd(map);

if (this.getAttribution && map.attributionControl) { map.attributionControl.addAttribution(this.getAttribution()); }

this.fire('add');

map.fire('layeradd', {layer: this});

}

});"|data_input/cargotracker/cargotracker.txt|809252d970674d12927c07eb20ef3452
"this.fire('add');

map.fire('layeradd', {layer: this});

}

});

/* @section Extension methods * @uninheritable * * Every layer should extend from `L.Layer` and (re-)implement the following methods. * * @method onAdd(map: Map): this * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer). * * @method onRemove(map: Map): this * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer). * * @method getEvents(): Object * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer. * * @method getAttribution(): String * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible. * * @method beforeAdd(map: Map): this * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only. */

/

@namespace Map"|data_input/cargotracker/cargotracker.txt|2c589730d354472481d1c112453d0218
"/

@namespace Map

Map.include({ // @method addLayer(layer: Layer): this // Adds the given layer to the map addLayer: function (layer) { if (!layer._layerAdd) { throw new Error('The provided object is not a Layer. '); }

var id = stamp(layer); if (this._layers[id]) { return this; } this._layers[id] = layer;

layer._mapToAdd = this;

if (layer.beforeAdd) {

layer.beforeAdd(this);

}

this.whenReady(layer._layerAdd, layer);

return this;

},

// @method removeLayer(layer: Layer): this // Removes the given layer from the map. removeLayer: function (layer) { var id = stamp(layer);

if (!this._layers[id]) { return this; }

if (this._loaded) {

layer.onRemove(this);

}

if (layer.getAttribution && this.attributionControl) { this.attributionControl.removeAttribution(layer.getAttribution()); }

delete this._layers[id];

if (this._loaded) {

this.fire('layerremove', {layer: layer});

layer.fire('remove');

}

layer._map = layer._mapToAdd = null;

return this;

},

// @method hasLayer(layer: Layer): Boolean // Returns `true` if the given layer is currently added to the map hasLayer: function (layer) { return ! !layer && (stamp(layer) in this._layers); },"|data_input/cargotracker/cargotracker.txt|8c9ee1ff6ea24277ad6baf06f7530f57
"/* @method eachLayer(fn: Function, context? : Object): this * Iterates over the layers of the map, optionally specifying context of the iterator function. * ``` * map.eachLayer(function(layer){ *     layer.bindPopup('Hello'); * }); * ``` */ eachLayer: function (method, context) { for (var i in this._layers) { method.call(context, this._layers[i]); } return this; },

_addLayers: function (layers) { layers = layers ? (isArray(layers) ? layers : [layers]) : [];

for (var i = 0, len = layers.length; i < len; i++) { this.addLayer(layers[i]); } },

_addZoomLimit: function (layer) { if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) { this._zoomBoundLayers[stamp(layer)] = layer; this._updateZoomLevels(); } },

// @section Map state change events // @event zoomlevelschange: Event // Fired when the number of zoomlevels on the map is changed due // to adding or removing a layer. if (oldZoomSpan !== this._getZoomSpan()) { this.fire('zoomlevelschange'); }

if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) { this.setZoom(this._layersMaxZoom); } if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) { this.setZoom(this._layersMinZoom); } } });"|data_input/cargotracker/cargotracker.txt|4708e639846a424ba9c74fc2d0827527
"/* * @class LayerGroup * @aka L.LayerGroup * @inherits Layer * * Used to group several layers and handle them as one. If you add it to the map, * any layers added or removed from the group will be added/removed on the map as * well. Extends `Layer`. * * @example * * ```js * L.layerGroup([marker1, marker2]) * 	.addLayer(polyline) * 	.addTo(map); * ``` */

var LayerGroup = Layer.extend({

initialize: function (layers, options) { setOptions(this, options);

this._layers = {};

var i, len;

if (layers) { for (i = 0, len = layers.length; i < len; i++) { this.addLayer(layers[i]); } } },

// @method addLayer(layer: Layer): this // Adds the given layer to the group. addLayer: function (layer) { var id = this.getLayerId(layer);

this._layers[id] = layer;

if (this._map) {

this._map.addLayer(layer);

}

return this;

},

// @method removeLayer(layer: Layer): this // Removes the given layer from the group. // @alternative // @method removeLayer(id: Number): this // Removes the layer with the given internal ID from the group. removeLayer: function (layer) { var id = layer in this._layers ? layer : this.getLayerId(layer);

if (this._map && this._layers[id]) { this._map.removeLayer(this._layers[id]); }

delete this._layers[id];

return this;

},"|data_input/cargotracker/cargotracker.txt|4d19b9ae8ab249a49fabdedad9b56677
"if (this._map && this._layers[id]) { this._map.removeLayer(this._layers[id]); }

delete this._layers[id];

return this;

},

// @method hasLayer(layer: Layer): Boolean // Returns `true` if the given layer is currently added to the group. // @alternative // @method hasLayer(id: Number): Boolean // Returns `true` if the given internal ID is currently added to the group. hasLayer: function (layer) { if (!layer) { return false; } var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer); return layerId in this._layers; },

// @method clearLayers(): this // Removes all the layers from the group. clearLayers: function () { return this.eachLayer(this.removeLayer, this); },

// @method invoke(methodName: String, ): this // Calls `methodName` on every layer contained in this group, passing any // additional parameters. Has no effect if the layers contained do not // implement `methodName`. invoke: function (methodName) { var args = Array.prototype.slice.call(arguments, 1), i, layer;

for (i in this._layers) { layer = this._layers[i];

if (layer[methodName]) {

layer[methodName].apply(layer, args);

}

}

return this;

},

onAdd: function (map) {

this.eachLayer(map.addLayer, map);

},

onRemove: function (map) {

this.eachLayer(map.removeLayer, map);

},"|data_input/cargotracker/cargotracker.txt|8e946fb29ee848cc87508236c8f50947
"},

onAdd: function (map) {

this.eachLayer(map.addLayer, map);

},

onRemove: function (map) {

this.eachLayer(map.removeLayer, map);

},

// @method eachLayer(fn: Function, context? : Object): this // Iterates over the layers of the group, optionally specifying context of the iterator function. // ```js // group.eachLayer(function (layer) { // 	layer.bindPopup('Hello'); // }); // ``` eachLayer: function (method, context) { for (var i in this._layers) { method.call(context, this._layers[i]); } return this; },

// @method getLayer(id: Number): Layer // Returns the layer with the given internal ID. getLayer: function (id) { return this._layers[id]; },

// @method getLayers(): Layer[] // Returns an array of all the layers added to the group. getLayers: function () { var layers = []; this.eachLayer(layers.push, layers); return layers; },

// @method setZIndex(zIndex: Number): this // Calls `setZIndex` on every layer contained in this group, passing the z-index. setZIndex: function (zIndex) { return this.invoke('setZIndex', zIndex); },

// @method getLayerId(layer: Layer): Number // Returns the internal ID for a layer getLayerId: function (layer) { return stamp(layer); } });

// @factory L.layerGroup(layers? : Layer[], options? : Object) // Create a layer group, optionally given an initial set of layers and an `options` object. var layerGroup = function (layers, options) { return new LayerGroup(layers, options); };"|data_input/cargotracker/cargotracker.txt|20dbb7af87f649df9367ca10d8898c14
text|source|chunk_id
"/* * @class FeatureGroup * @aka L.FeatureGroup * @inherits LayerGroup * * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers: *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip)) *  * Events are propagated to the `FeatureGroup`, so if the group has an event * handler, it will handle events from any of the layers. This includes mouse events * and custom events. *  * Has `layeradd` and `layerremove` events * * @example * * ```js * L.featureGroup([marker1, marker2, polyline]) * 	.bindPopup('Hello world!') * 	.on('click', function() { alert('Clicked on a member of the group! '); }) * 	.addTo(map); * ``` */

var FeatureGroup = LayerGroup.extend({

addLayer: function (layer) {

if (this.hasLayer(layer)) {

return this;

}

layer.addEventParent(this);

LayerGroup.prototype.addLayer.call(this, layer);

// @event layeradd: LayerEvent // Fired when a layer is added to this `FeatureGroup` return this.fire('layeradd', {layer: layer}); },

removeLayer: function (layer) { if (!this.hasLayer(layer)) { return this; } if (layer in this._layers) { layer = this._layers[layer]; }

layer.removeEventParent(this);

LayerGroup.prototype.removeLayer.call(this, layer);

map = marker._map,

speed = this._marker.options.autoPanSpeed,

padding = this._marker.options.autoPanPadding,

iconPos = getPosition(marker._icon),

bounds = map.getPixelBounds(),

origin = map.getPixelOrigin();"|data_input/cargotracker/cargotracker.txt|ffecd3df17654851822f981696c2dc3d
"padding = this._marker.options.autoPanPadding,

iconPos = getPosition(marker._icon),

bounds = map.getPixelBounds(),

origin = map.getPixelOrigin();

var panBounds = toBounds(

bounds.min._subtract(origin).add(padding),

bounds.max._subtract(origin).subtract(padding)

);

if (!panBounds.contains(iconPos)) {

// Compute incremental movement

var movement = toPoint(

(Math.max(panBounds.max.x, iconPos.x)

panBounds.max.x) / (bounds.max.x

panBounds.max.x)

(Math.min(panBounds.min.x, iconPos.x)

panBounds.min.x) / (bounds.min.x

panBounds.min.x),

(Math.max(panBounds.max.y, iconPos.y)

panBounds.max.y) / (bounds.max.y

panBounds.max.y)

(Math.min(panBounds.min.y, iconPos.y)

panBounds.min.y) / (bounds.min.y

panBounds.min.y)

).multiplyBy(speed);

map.panBy(movement, {animate: false});

this._draggable._newPos._add(movement);

this._draggable._startPos._add(movement);

setPosition(marker._icon, this._draggable._newPos);

this._onDrag(e);

this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));

}

},

/* * @class Marker * @inherits Interactive layer * @aka L.Marker * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`. * * @example * * ```js * L.marker([50.5, 30.5]).addTo(map); * ``` */

var Marker = Layer.extend({"|data_input/cargotracker/cargotracker.txt|715ecacbbb1d45e5b93d1448b477f2e9
"var Marker = Layer.extend({

// @section // @aka Marker options options: { // @option icon: Icon = * // Icon instance to use for rendering the marker. // See [Icon documentation](#L.Icon) for details on how to customize the marker icon. // If not specified, a common instance of `L.Icon.Default` is used. icon: new IconDefault(),

// Option inherited from ""Interactive layer"" abstract class interactive: true,

// @option keyboard: Boolean = true // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter. keyboard: true,

// @option title: String = '' // Text for the browser tooltip that appear on marker hover (no tooltip by default). title: '',

// @option alt: String = '' // Text for the `alt` attribute of the icon image (useful for accessibility). alt: '',

// @option zIndexOffset: Number = 0 // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively). zIndexOffset: 0,

// @option opacity: Number = 1.0 // The opacity of the marker. opacity: 1,

// @option riseOnHover: Boolean = false // If `true`, the marker will get on top of others when you hover the mouse over it. riseOnHover: false,

// @option riseOffset: Number = 250 // The z-index offset used for the `riseOnHover` feature. riseOffset: 250,"|data_input/cargotracker/cargotracker.txt|b33ea56c8e0b4d9c90f26692ba6b55f8
"// @option riseOffset: Number = 250 // The z-index offset used for the `riseOnHover` feature. riseOffset: 250,

// @option pane: String = 'markerPane' // `Map pane` where the markers icon will be added. pane: 'markerPane',

// @option shadowPane: String = 'shadowPane' // `Map pane` where the markers shadow will be added. shadowPane: 'shadowPane',

// @option bubblingMouseEvents: Boolean = false // When `true`, a mouse event on this marker will trigger the same event on the map // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used). bubblingMouseEvents: false,

// @section Draggable marker options // @option draggable: Boolean = false // Whether the marker is draggable with mouse/touch or not. draggable: false,

// @option autoPan: Boolean = false // Whether to pan the map when dragging this marker near its edge or not. autoPan: false,

// @option autoPanPadding: Point = Point(50, 50) // Distance (in pixels to the left/right and to the top/bottom) of the // map edge to start panning the map. autoPanPadding: [50, 50],

// @option autoPanSpeed: Number = 10 // Number of pixels the map should pan by. autoPanSpeed: 10 },

/* @section * * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods: */

initialize: function (latlng, options) { setOptions(this, options); this._latlng = toLatLng(latlng); },"|data_input/cargotracker/cargotracker.txt|d2f035c6d17948638f22dc6998354e0e
"initialize: function (latlng, options) { setOptions(this, options); this._latlng = toLatLng(latlng); },

onAdd: function (map) { this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

if (this._zoomAnimated) {

map.on('zoomanim', this._animateZoom, this);

}

this._initIcon();

this.update();

},

onRemove: function (map) { if (this.dragging && this.dragging.enabled()) { this.options.draggable = true; this.dragging.removeHooks(); } delete this.dragging;

if (this._zoomAnimated) {

map.off('zoomanim', this._animateZoom, this);

}

this._removeIcon();

this._removeShadow();

},

getEvents: function () {

return {

zoom: this.update,

viewreset: this.update

};

},

// @method getLatLng: LatLng // Returns the current geographical position of the marker. getLatLng: function () { return this._latlng; },

// @method setLatLng(latlng: LatLng): this // Changes the marker position to the given point. setLatLng: function (latlng) { var oldLatLng = this._latlng; this._latlng = toLatLng(latlng); this.update();

// @event move: Event // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`. return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng}); },"|data_input/cargotracker/cargotracker.txt|7ab559bb70fd4867ac3639bea49ed714
"// @method setZIndexOffset(offset: Number): this // Changes the [zIndex offset](#marker-zindexoffset) of the marker. setZIndexOffset: function (offset) { this.options.zIndexOffset = offset; return this.update(); },

// @method getIcon: Icon // Returns the current icon used by the marker getIcon: function () { return this.options.icon; },

// @method setIcon(icon: Icon): this // Changes the marker icon. setIcon: function (icon) {

this.options.icon = icon;

if (this._map) {

this._initIcon();

this.update();

}

if (this._popup) {

this.bindPopup(this._popup, this._popup.options);

}

return this;

},

getElement: function () {

return this._icon;

},

update: function () {

if (this._icon && this._map) { var pos = this._map.latLngToLayerPoint(this._latlng).round(); this._setPos(pos); }

return this;

},

_initIcon: function () { var options = this.options, classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

var icon = options.icon.createIcon(this._icon),

addIcon = false;

// if we're not reusing the icon, remove the old one and init new one if (icon !== this._icon) { if (this._icon) { this._removeIcon(); } addIcon = true;

if (options.title) {

icon.title = options.title;

}

if (icon.tagName === 'IMG') { icon.alt = options.alt || ''; } }

addClass(icon, classToAdd);

if (options.keyboard) {

icon.tabIndex = '0';

}

this._icon = icon;

if (options.riseOnHover) {

this.on({

mouseover: this._bringToFront,

mouseout: this._resetZIndex

});

}"|data_input/cargotracker/cargotracker.txt|d3da4f94f04d4ca5b606ebeedb2341e3
"}

this._icon = icon;

if (options.riseOnHover) {

this.on({

mouseover: this._bringToFront,

mouseout: this._resetZIndex

});

}

var newShadow = options.icon.createShadow(this._shadow),

addShadow = false;

if (newShadow !== this._shadow) { this._removeShadow(); addShadow = true; }

if (newShadow) {

addClass(newShadow, classToAdd);

newShadow.alt = '';

}

this._shadow = newShadow;

if (options.opacity < 1) { this._updateOpacity(); }

if (addIcon) { this.getPane().appendChild(this._icon); } this._initInteraction(); if (newShadow && addShadow) { this.getPane(options.shadowPane).appendChild(this._shadow); } },

_removeIcon: function () {

if (this.options.riseOnHover) {

this.off({

mouseover: this._bringToFront,

mouseout: this._resetZIndex

});

}

remove(this._icon);

this.removeInteractiveTarget(this._icon);

this._icon = null;

},

_removeShadow: function () {

if (this._shadow) {

remove(this._shadow);

}

this._shadow = null;

},

_setPos: function (pos) {

if (this._icon) {

setPosition(this._icon, pos);

}

if (this._shadow) {

setPosition(this._shadow, pos);

}

this._zIndex = pos.y + this.options.zIndexOffset;

this._resetZIndex();

},

_updateZIndex: function (offset) { if (this._icon) { this._icon.style.zIndex = this._zIndex + offset; } },

_animateZoom: function (opt) { var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

this._setPos(pos);

},

_initInteraction: function () {

if (!this.options.interactive) { return; }"|data_input/cargotracker/cargotracker.txt|d7756a6ff0854c1286f1f00a1157b63f
"this._setPos(pos);

},

_initInteraction: function () {

if (!this.options.interactive) { return; }

addClass(this._icon, 'leaflet

interactive');

this.addInteractiveTarget(this._icon);

if (MarkerDrag) {

var draggable = this.options.draggable;

if (this.dragging) {

draggable = this.dragging.enabled();

this.dragging.disable();

}

this.dragging = new MarkerDrag(this);

if (draggable) {

this.dragging.enable();

}

}

},

// @method setOpacity(opacity: Number): this // Changes the opacity of the marker. setOpacity: function (opacity) { this.options.opacity = opacity; if (this._map) { this._updateOpacity(); }

return this;

},

_updateOpacity: function () {

var opacity = this.options.opacity;

if (this._icon) {

setOpacity(this._icon, opacity);

}

if (this._shadow) {

setOpacity(this._shadow, opacity);

}

},

_bringToFront: function () {

this._updateZIndex(this.options.riseOffset);

},

_resetZIndex: function () {

this._updateZIndex(0);

},

_getPopupAnchor: function () {

return this.options.icon.options.popupAnchor;

},

_getTooltipAnchor: function () {

return this.options.icon.options.tooltipAnchor;

}

});

// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options) // Instantiates a Marker object given a geographical point and optionally an options object. function marker(latlng, options) { return new Marker(latlng, options); }"|data_input/cargotracker/cargotracker.txt|ebd59f660ab94a67bebe0b812da13ea0
"/* * @class Path * @aka L.Path * @inherits Interactive layer * * An abstract class that contains options and constants shared between vector * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`. */

var Path = Layer.extend({

// @section // @aka Path options options: { // @option stroke: Boolean = true // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles. stroke: true,

// @option color: String = '#3388ff' // Stroke color color: '#3388ff',

// @option weight: Number = 3 // Stroke width in pixels weight: 3,

// @option opacity: Number = 1.0 // Stroke opacity opacity: 1,

// @option lineCap: String= 'round' // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke. lineCap: 'round',

// @option lineJoin: String = 'round' // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke. lineJoin: 'round',

// @option dashArray: String = null // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility). dashArray: null,"|data_input/cargotracker/cargotracker.txt|0d11ac129ac341ed8c3aca7984a0a5af
"// @option dashOffset: String = null // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility). dashOffset: null,

// @option fill: Boolean = depends // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles. fill: false,

// @option fillColor: String = * // Fill color. Defaults to the value of the [`color`](#path-color) option fillColor: null,

// @option fillOpacity: Number = 0.2 // Fill opacity. fillOpacity: 0.2,

// @option fillRule: String = 'evenodd' // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined. fillRule: 'evenodd',

// className: '',

// Option inherited from ""Interactive layer"" abstract class interactive: true,

// @option bubblingMouseEvents: Boolean = true // When `true`, a mouse event on this path will trigger the same event on the map // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used). bubblingMouseEvents: true },

beforeAdd: function (map) { // Renderer is set here because we need to call renderer.getEvents // before this.getEvents. this._renderer = map.getRenderer(this); },

onAdd: function () {

this._renderer._initPath(this);

this._reset();"|data_input/cargotracker/cargotracker.txt|442d9101da0447159118132ebed2f0e3
"onAdd: function () {

this._renderer._initPath(this);

this._reset();

this._renderer._addPath(this);

},

onRemove: function () {

this._renderer._removePath(this);

},

// @method redraw(): this // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses. redraw: function () { if (this._map) { this._renderer._updatePath(this); } return this; },

// @method setStyle(style: Path options): this // Changes the appearance of a Path based on the options in the `Path options` object. setStyle: function (style) { setOptions(this, style); if (this._renderer) { this._renderer._updateStyle(this); if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) { this._updateBounds(); } } return this; },

// @method bringToFront(): this // Brings the layer to the top of all path layers. bringToFront: function () { if (this._renderer) { this._renderer._bringToFront(this); } return this; },

// @method bringToBack(): this // Brings the layer to the bottom of all path layers. bringToBack: function () { if (this._renderer) { this._renderer._bringToBack(this); } return this; },

getElement: function () {

return this._path;

},

_reset: function () { // defined in child classes this._project(); this._update(); },

_clickTolerance: function () { // used when doing hit detection for Canvas layers return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance; } });"|data_input/cargotracker/cargotracker.txt|7c6981ed808b4a21b18c524c5a7600d6
"/* * @class CircleMarker * @aka L.CircleMarker * @inherits Path * * A circle of a fixed size with radius specified in pixels. Extends `Path`. */

var CircleMarker = Path.extend({

// @section

// @aka CircleMarker options

options: {

fill: true,

// @option radius: Number = 10 // Radius of the circle marker, in pixels radius: 10 },

initialize: function (latlng, options) { setOptions(this, options); this._latlng = toLatLng(latlng); this._radius = this.options.radius; },

// @method setLatLng(latLng: LatLng): this // Sets the position of a circle marker to a new location. setLatLng: function (latlng) { var oldLatLng = this._latlng; this._latlng = toLatLng(latlng); this.redraw();

// @event move: Event // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`. return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng}); },

// @method getLatLng(): LatLng // Returns the current geographical position of the circle marker getLatLng: function () { return this._latlng; },

// @method setRadius(radius: Number): this // Sets the radius of a circle marker. Units are in pixels. setRadius: function (radius) { this.options.radius = this._radius = radius; return this.redraw(); },

// @method getRadius(): Number // Returns the current radius of the circle getRadius: function () { return this._radius; },"|data_input/cargotracker/cargotracker.txt|add6e07bdc8c4236856ace8a976b195c
"// @method getRadius(): Number // Returns the current radius of the circle getRadius: function () { return this._radius; },

setStyle : function (options) { var radius = options && options.radius || this._radius; Path.prototype.setStyle.call(this, options); this.setRadius(radius); return this; },

_project: function () {

this._point = this._map.latLngToLayerPoint(this._latlng);

this._updateBounds();

},

_updateBounds: function () { var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w]; this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p)); },

_update: function () {

if (this._map) {

this._updatePath();

}

},

_updatePath: function () {

this._renderer._updateCircle(this);

},

_empty: function () {

return this._radius && !this._renderer._bounds.intersects(this._pxBounds);

},

// Needed by the `Canvas` renderer for interactivity _containsPoint: function (p) { return p.distanceTo(this._point) <= this._radius + this._clickTolerance(); } });

// @factory L.circleMarker(latlng: LatLng, options? : CircleMarker options) // Instantiates a circle marker object given a geographical point, and an optional options object. function circleMarker(latlng, options) { return new CircleMarker(latlng, options); }"|data_input/cargotracker/cargotracker.txt|9097c1e3a3cf444b944ec56c209a434f
"/* * @class Circle * @aka L.Circle * @inherits CircleMarker * * A class for drawing circle overlays on a map. Extends `CircleMarker`. * * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion). * * @example * * ```js * L.circle([50.5, 30.5], {radius: 200}).addTo(map); * ``` */

var Circle = CircleMarker.extend({

initialize: function (latlng, options, legacyOptions) { if (typeof options === 'number') { // Backwards compatibility with 0.7.x factory (latlng, radius, options?) options = extend({}, legacyOptions, {radius: options}); } setOptions(this, options); this._latlng = toLatLng(latlng);

if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

// @section // @aka Circle options // @option radius: Number; Radius of the circle, in meters. this._mRadius = this.options.radius; },

// @method setRadius(radius: Number): this // Sets the radius of a circle. Units are in meters. setRadius: function (radius) { this._mRadius = radius; return this.redraw(); },

// @method getRadius(): Number // Returns the current radius of a circle. Units are in meters. getRadius: function () { return this._mRadius; },

// @method getBounds(): LatLngBounds // Returns the `LatLngBounds` of the path. getBounds: function () { var half = [this._radius, this._radiusY || this._radius];

return new LatLngBounds(

this._map.layerPointToLatLng(this._point.subtract(half)),"|data_input/cargotracker/cargotracker.txt|f2f8979ffd134a9398be444bea3ff226
"return new LatLngBounds(

this._map.layerPointToLatLng(this._point.subtract(half)),

this._map.layerPointToLatLng(this._point.add(half)));

},

setStyle: Path.prototype.setStyle,

_project: function () {

var lng = this._latlng.lng,

lat = this._latlng.lat,

map = this._map,

crs = map.options.crs;

if (crs.distance === Earth.distance) { var d = Math.PI / 180, latR = (this._mRadius / Earth.R) / d, top = map.project([lat + latR, lng]), bottom = map.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

if (isNaN(lngR) || lngR === 0) { lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425 }

this._point = p.subtract(map.getPixelOrigin()); this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x; this._radiusY = p.y - top.y;

} else { var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

this._point = map.latLngToLayerPoint(this._latlng);

this._radius = this._point.x

map.latLngToLayerPoint(latlng2).x;

}

this._updateBounds();

}

});"|data_input/cargotracker/cargotracker.txt|d59610afa91e48e584ffc8e224627bd7
"this._radius = this._point.x

map.latLngToLayerPoint(latlng2).x;

}

this._updateBounds();

}

});

// @factory L.circle(latlng: LatLng, options? : Circle options) // Instantiates a circle object given a geographical point, and an options object // which contains the circle radius. // @alternative // @factory L.circle(latlng: LatLng, radius: Number, options? : Circle options) // Obsolete way of instantiating a circle, for compatibility with 0.7.x code. // Do not use in new applications or plugins. function circle(latlng, options, legacyOptions) { return new Circle(latlng, options, legacyOptions); }

/* * @class Polyline * @aka L.Polyline * @inherits Path * * A class for drawing polyline overlays on a map. Extends `Path`. * * @example * * ```js * // create a red polyline from an array of LatLng points * var latlngs = [ * 	[45.51, -122.68], * 	[37.77, -122.43], * 	[34.04, -118.2] * ]; * * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map); * * // zoom the map to the polyline * map.fitBounds(polyline.getBounds()); * ``` * * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape: * * ```js * // create a red polyline from an array of arrays of LatLng points * var latlngs = [ * 	[[45.51, -122.68], * 	 [37.77, -122.43], * 	 [34.04, -118.2]], * 	[[40.78, -73.91], * 	 [41.83, -87.62], * 	 [32.76, -96.72]] * ]; * ``` */

var Polyline = Path.extend({"|data_input/cargotracker/cargotracker.txt|c07751540f7e4f44819692fa50dd44a6
"var Polyline = Path.extend({

// @section // @aka Polyline options options: { // @option smoothFactor: Number = 1.0 // How much to simplify the polyline on each zoom level. More means // better performance and smoother look, and less means more accurate representation. smoothFactor: 1.0,

// @option noClip: Boolean = false // Disable polyline clipping. noClip: false },

initialize: function (latlngs, options) { setOptions(this, options); this._setLatLngs(latlngs); },

// @method getLatLngs(): LatLng[] // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline. getLatLngs: function () { return this._latlngs; },

// @method setLatLngs(latlngs: LatLng[]): this // Replaces all the points in the polyline with the given array of geographical points. setLatLngs: function (latlngs) { this._setLatLngs(latlngs); return this.redraw(); },

// @method isEmpty(): Boolean // Returns `true` if the Polyline has no LatLngs. isEmpty: function () { return !this._latlngs.length; },

// @method closestLayerPoint(p: Point): Point // Returns the point closest to `p` on the Polyline. closestLayerPoint: function (p) { var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;

for (var j = 0, jLen = this._parts.length; j < jLen; j++) { var points = this._parts[j];

for (var i = 1, len = points.length; i < len; i++) { p1 = points[i - 1]; p2 = points[i];

var sqDist = closest(p, p1, p2, true);"|data_input/cargotracker/cargotracker.txt|328f007ffc2c4e14b38d34f69c8209d3
"for (var i = 1, len = points.length; i < len; i++) { p1 = points[i - 1]; p2 = points[i];

var sqDist = closest(p, p1, p2, true);

if (sqDist < minDistance) { minDistance = sqDist; minPoint = closest(p, p1, p2); } } } if (minPoint) { minPoint.distance = Math.sqrt(minDistance); } return minPoint; },

// @method getCenter(): LatLng // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline. getCenter: function () { // throws error when not yet added to map as this center calculation requires projected coordinates if (!this._map) { throw new Error('Must add layer to map before using getCenter()'); }

var i, halfDist, segDist, dist, p1, p2, ratio, points = this._rings[0], len = points.length;

if (!len) { return null; }

// polyline centroid algorithm; only uses the first ring if there are multiple

for (i = 0, halfDist = 0; i < len - 1; i++) { halfDist += points[i].distanceTo(points[i + 1]) / 2; }

// The line is so small in the current view that all points are on the same pixel. if (halfDist === 0) { return this._map.layerPointToLatLng(points[0]); }

for (i = 0, dist = 0; i < len - 1; i++) { p1 = points[i]; p2 = points[i + 1]; segDist = p1.distanceTo(p2); dist += segDist;

if (dist > halfDist) { ratio = (dist - halfDist) / segDist; return this._map.layerPointToLatLng([ p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y) ]); } } },"|data_input/cargotracker/cargotracker.txt|80984e25573e49c9aff5ffaada28f1c2
"// @method getBounds(): LatLngBounds // Returns the `LatLngBounds` of the path. getBounds: function () { return this._bounds; },

// @method addLatLng(latlng: LatLng, latlngs? : LatLng[]): this // Adds a given point to the polyline. By default, adds to the first ring of // the polyline in case of a multi-polyline, but can be overridden by passing // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)). addLatLng: function (latlng, latlngs) { latlngs = latlngs || this._defaultShape(); latlng = toLatLng(latlng); latlngs.push(latlng); this._bounds.extend(latlng); return this.redraw(); },

_setLatLngs: function (latlngs) {

this._bounds = new LatLngBounds();

this._latlngs = this._convertLatLngs(latlngs);

},

_defaultShape: function () { return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0]; },

// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way _convertLatLngs: function (latlngs) { var result = [], flat = isFlat(latlngs);

for (var i = 0, len = latlngs.length; i < len; i++) { if (flat) { result[i] = toLatLng(latlngs[i]); this._bounds.extend(result[i]); } else { result[i] = this._convertLatLngs(latlngs[i]); } }

return result;

},

_project: function () { var pxBounds = new Bounds(); this._rings = []; this._projectLatlngs(this._latlngs, this._rings, pxBounds);

if (this._bounds.isValid() && pxBounds.isValid()) { this._rawPxBounds = pxBounds; this._updateBounds(); } },"|data_input/cargotracker/cargotracker.txt|6c2eabb586c54c24ae42dee4b4d1dcf6
"if (this._bounds.isValid() && pxBounds.isValid()) { this._rawPxBounds = pxBounds; this._updateBounds(); } },

_updateBounds: function () { var w = this._clickTolerance(), p = new Point(w, w); this._pxBounds = new Bounds([ this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p) ]); },

// recursively turns latlngs into a set of rings with projected coordinates _projectLatlngs: function (latlngs, result, projectedBounds) { var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;

if (flat) { ring = []; for (i = 0; i < len; i++) { ring[i] = this._map.latLngToLayerPoint(latlngs[i]); projectedBounds.extend(ring[i]); } result.push(ring); } else { for (i = 0; i < len; i++) { this._projectLatlngs(latlngs[i], result, projectedBounds); } } },

// clip polyline by renderer bounds so that we have less to render for performance _clipPoints: function () { var bounds = this._renderer._bounds;

this._parts = []; if (!this._pxBounds || !this._pxBounds.intersects(bounds)) { return; }

if (this.options.noClip) {

this._parts = this._rings;

return;

}

var parts = this._parts, i, j, k, len, len2, segment, points;

for (i = 0, k = 0, len = this._rings.length; i < len; i++) { points = this._rings[i];

for (j = 0, len2 = points.length; j < len2 - 1; j++) { segment = clipSegment(points[j], points[j + 1], bounds, j, true);

if (!segment) { continue; }

parts[k] = parts[k] || []; parts[k].push(segment[0]);"|data_input/cargotracker/cargotracker.txt|46aa05fb2a7f45499ba52f42f22db079
"if (!segment) { continue; }

parts[k] = parts[k] || []; parts[k].push(segment[0]);

// if segment goes out of screen, or it's the last one, it's the end of the line part if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) { parts[k].push(segment[1]); k++; } } } },

// simplify each clipped part of the polyline for performance _simplifyPoints: function () { var parts = this._parts, tolerance = this.options.smoothFactor;

for (var i = 0, len = parts.length; i < len; i++) { parts[i] = simplify(parts[i], tolerance); } },

_update: function () { if (!this._map) { return; }

this._clipPoints();

this._simplifyPoints();

this._updatePath();

},

_updatePath: function () {

this._renderer._updatePoly(this);

},

// Needed by the `Canvas` renderer for interactivity _containsPoint: function (p, closed) { var i, j, k, len, len2, part, w = this._clickTolerance();

if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

// hit detection for polylines for (i = 0, len = this._parts.length; i < len; i++) { part = this._parts[i];

for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) { if (!closed && (j === 0)) { continue; }

if (pointToSegmentDistance(p, part[k], part[j]) <= w) { return true; } } } return false; } });"|data_input/cargotracker/cargotracker.txt|7e8c8abe408149248cf1b5c928b6069f
"if (pointToSegmentDistance(p, part[k], part[j]) <= w) { return true; } } } return false; } });

// @factory L.polyline(latlngs: LatLng[], options? : Polyline options) // Instantiates a polyline object given an array of geographical points and // optionally an options object. You can create a `Polyline` object with // multiple separate lines (`MultiPolyline`) by passing an array of arrays // of geographic points. function polyline(latlngs, options) { return new Polyline(latlngs, options); }

// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1. Polyline._flat = _flat;"|data_input/cargotracker/cargotracker.txt|fa9ce64639d549009dfc901904af5346
"// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1. Polyline._flat = _flat;

/* * @class Polygon * @aka L.Polygon * @inherits Polyline * * A class for drawing polygon overlays on a map. Extends `Polyline`. * * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points. * * * @example * * ```js * // create a red polygon from an array of LatLng points * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]]; * * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map); * * // zoom the map to the polygon * map.fitBounds(polygon.getBounds()); * ``` * * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape: * * ```js * var latlngs = [ *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole * ]; * ``` * * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape. * * ```js * var latlngs = [ *   [ // first polygon *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole *   ], *   [ // second polygon *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]] *   ] * ]; * ``` */"|data_input/cargotracker/cargotracker.txt|1f3716b5ac204e61821236bf5f9e318e
"var Polygon = Polyline.extend({

options: {

fill: true

},

isEmpty: function () {

return !this._latlngs.length || !this._latlngs[0].length;

},

getCenter: function () { // throws error when not yet added to map as this center calculation requires projected coordinates if (!this._map) { throw new Error('Must add layer to map before using getCenter()'); }

var i, j, p1, p2, f, area, x, y, center, points = this._rings[0], len = points.length;

if (!len) { return null; }

// polygon centroid algorithm; only uses the first ring if there are multiple

area = x = y = 0;

for (i = 0, j = len - 1; i < len; j = i++) { p1 = points[i]; p2 = points[j];

f = p1.y * p2.x - p2.y * p1.x; x += (p1.x + p2.x) * f; y += (p1.y + p2.y) * f; area += f * 3; }

if (area === 0) { // Polygon is so small that all points are on same pixel. center = points[0]; } else { center = [x / area, y / area]; } return this._map.layerPointToLatLng(center); },

_convertLatLngs: function (latlngs) { var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;

// remove last point if it equals first one if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) { result.pop(); } return result; },

_setLatLngs: function (latlngs) {

Polyline.prototype._setLatLngs.call(this, latlngs);

if (isFlat(this._latlngs)) {

this._latlngs = [this._latlngs];

}

},

_defaultShape: function () { return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0]; },"|data_input/cargotracker/cargotracker.txt|627f2e0a261f497caee973f3a5a6db9a
"this._latlngs = [this._latlngs];

}

},

_defaultShape: function () { return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0]; },

_clipPoints: function () { // polygons need a different clipping algorithm so we redefine that

var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);

// increase clip padding by stroke width to avoid stroke on clip edges bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

this._parts = []; if (!this._pxBounds || !this._pxBounds.intersects(bounds)) { return; }

if (this.options.noClip) {

this._parts = this._rings;

return;

}

for (var i = 0, len = this._rings.length, clipped; i < len; i++) { clipped = clipPolygon(this._rings[i], bounds, true); if (clipped.length) { this._parts.push(clipped); } } },

_updatePath: function () {

this._renderer._updatePoly(this, true);

},

// Needed by the `Canvas` renderer for interactivity _containsPoint: function (p) { var inside = false, part, p1, p2, i, j, k, len, len2;

if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

// ray casting algorithm for detecting if point is in polygon for (i = 0, len = this._parts.length; i < len; i++) { part = this._parts[i];

for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) { p1 = part[j]; p2 = part[k];

if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) { inside = !inside; } } }"|data_input/cargotracker/cargotracker.txt|0f66c84289344dc9b784620e693e79e6
"if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) { inside = !inside; } } }

// also check if it's on polygon stroke return inside || Polyline.prototype._containsPoint.call(this, p, true); }

});

// @factory L.polygon(latlngs: LatLng[], options? : Polyline options) function polygon(latlngs, options) { return new Polygon(latlngs, options); }

/* * @class GeoJSON * @aka L.GeoJSON * @inherits FeatureGroup * * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse * GeoJSON data and display it on the map. Extends `FeatureGroup`. * * @example * * ```js * L.geoJSON(data, { * 	style: function (feature) { * 		return {color: feature.properties.color}; * 	} * }).bindPopup(function (layer) { * 	return layer.feature.properties.description; * }).addTo(map); * ``` */

var GeoJSON = FeatureGroup.extend({"|data_input/cargotracker/cargotracker.txt|69a926475b264596b81b9eec12c1ab14
/* @section * @aka GeoJSON options * * @option pointToLayer: Function = * * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally * called when data is added, passing the GeoJSON point feature and its `LatLng`. * The default is to spawn a default `Marker`: * ```js * function(geoJsonPoint, latlng) { * 	return L.marker(latlng); * } * ``` * * @option style: Function = * * A `Function` defining the `Path options` for styling GeoJSON lines and polygons, * called internally when data is added. * The default value is to not override any defaults: * ```js * function (geoJsonFeature) { * 	return {} * } * ``` * * @option onEachFeature: Function = * * A `Function` that will be called once for each created `Feature`, after it has * been created and styled. Useful for attaching events and popups to features. * The default is to do nothing with the newly created layers: * ```js * function (feature, layer) {} * ``` * * @option filter: Function = * * A `Function` that will be used to decide whether to include a feature or not. * The default is to include all features: * ```js * function (geoJsonFeature) { * 	return true; * } * ``` * Note: dynamically changing the `filter` option will have effect only on newly * added data. It will _not_ re-evaluate already included features. * * @option coordsToLatLng: Function = * * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s. * The default is the `coordsToLatLng` static method.|data_input/cargotracker/cargotracker.txt|d1c1f09134844d57ad7fc4f508e13474
"* @option markersInheritOptions: Boolean = false * Whether default Markers for ""Point"" type Features inherit from group options. */

initialize: function (geojson, options) { setOptions(this, options);

this._layers = {};

if (geojson) {

this.addData(geojson);

}

},

// @method addData( <GeoJSON> data ): this // Adds a GeoJSON object to the layer. addData: function (geojson) { var features = isArray(geojson) ? geojson : geojson.features, i, len, feature;

if (features) { for (i = 0, len = features.length; i < len; i++) { // only add this if geometry or geometries are set and not null feature = features[i]; if (feature.geometries || feature.geometry || feature.features || feature.coordinates) { this.addData(feature); } } return this; }

var options = this.options;

if (options.filter && !options.filter(geojson)) { return this; }

var layer = geometryToLayer(geojson, options); if (!layer) { return this; } layer.feature = asFeature(geojson);

layer.defaultOptions = layer.options;

this.resetStyle(layer);

if (options.onEachFeature) {

options.onEachFeature(geojson, layer);

}

return this.addLayer(layer);

},"|data_input/cargotracker/cargotracker.txt|ba8c3a2a52514bf59f2f7be8a8c6d9c7
"this.resetStyle(layer);

if (options.onEachFeature) {

options.onEachFeature(geojson, layer);

}

return this.addLayer(layer);

},

// @method resetStyle( <Path> layer? ): this // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events. // If `layer` is omitted, the style of all features in the current layer is reset. resetStyle: function (layer) { if (layer === undefined) { return this.eachLayer(this.resetStyle, this); } // reset any custom styles layer.options = extend({}, layer.defaultOptions); this._setLayerStyle(layer, this.options.style); return this; },

// @method setStyle( <Function> style ): this // Changes styles of GeoJSON vector layers with the given style function. setStyle: function (style) { return this.eachLayer(function (layer) { this._setLayerStyle(layer, style); }, this); },

_setLayerStyle: function (layer, style) { if (layer.setStyle) { if (typeof style === 'function') { style = style(layer.feature); } layer.setStyle(style); } } });

// @section // There are several static functions which can be called without instantiating L.GeoJSON:

// @function geometryToLayer(featureData: Object, options? : GeoJSON options): Layer // Creates a `Layer` from a given GeoJSON feature. Can use a custom // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng) // functions if provided as options. function geometryToLayer(geojson, options) {"|data_input/cargotracker/cargotracker.txt|856878427f1f45f0962cf549a638c818
"var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;

if (!coords && !geometry) { return null; }

switch (geometry.type) { case 'Point': latlng = _coordsToLatLng(coords); return _pointToLayer(pointToLayer, geojson, latlng, options);

case 'MultiPoint': for (i = 0, len = coords.length; i < len; i++) { latlng = _coordsToLatLng(coords[i]); layers.push(_pointToLayer(pointToLayer, geojson, latlng, options)); } return new FeatureGroup(layers);

case 'LineString': case 'MultiLineString': latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng); return new Polyline(latlngs, options);

case 'Polygon': case 'MultiPolygon': latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng); return new Polygon(latlngs, options);

case 'GeometryCollection': for (i = 0, len = geometry.geometries.length; i < len; i++) { var layer = geometryToLayer({ geometry: geometry.geometries[i], type: 'Feature', properties: geojson.properties }, options);

if (layer) {

layers.push(layer);

}

}

return new FeatureGroup(layers);

default: throw new Error('Invalid GeoJSON object. '); } }"|data_input/cargotracker/cargotracker.txt|0e7ed5eef22b4689b7950da44ce4802a
"if (layer) {

layers.push(layer);

}

}

return new FeatureGroup(layers);

default: throw new Error('Invalid GeoJSON object. '); } }

function _pointToLayer(pointToLayerFn, geojson, latlng, options) { return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options); }

// @function coordsToLatLng(coords: Array): LatLng // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude) // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points. function coordsToLatLng(coords) { return new LatLng(coords[1], coords[0], coords[2]); }

// @function coordsToLatLngs(coords: Array, levelsDeep? : Number, coordsToLatLng? : Function): Array // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array. // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default). // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function. function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) { var latlngs = [];

for (var i = 0, len = coords.length, latlng; i < len; i++) { latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);

latlngs.push(latlng);

}

return latlngs;

}"|data_input/cargotracker/cargotracker.txt|8e8a5c1cd7624566b416f424dfbfc0f3
"latlngs.push(latlng);

}

return latlngs;

}

// @function latLngToCoords(latlng: LatLng, precision? : Number): Array // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng) function latLngToCoords(latlng, precision) { precision = typeof precision === 'number' ? precision : 6; return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)]; }

// @function latLngsToCoords(latlngs: Array, levelsDeep? : Number, closed? : Boolean): Array // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs) // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default. function latLngsToCoords(latlngs, levelsDeep, closed, precision) { var coords = [];

for (var i = 0, len = latlngs.length; i < len; i++) { coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision)); }

if (!levelsDeep && closed) { coords.push(coords[0]); }

return coords;

}

function getFeature(layer, newGeometry) { return layer.feature ? extend({}, layer.feature, {geometry: newGeometry}) : asFeature(newGeometry); }"|data_input/cargotracker/cargotracker.txt|e4504602d9bd444e9af5f0f7b32bf99b
